//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.0.0 (NJsonSchema v10.7.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import * as fsPromise from 'fs/promises';
import { UrlUtils, StringUtils } from '@laserfiche/lf-js-utils';
import {
  UsernamePasswordHandler,
  OAuthClientCredentialsHandler,
  HttpRequestHandler,
  DomainUtils,
  AccessKey,
  ApiException as ApiExceptionCore,
} from '@laserfiche/lf-api-client-core';
import { repositoryId } from '../test/TestHelper.js';
import { url } from 'inspector';
import { isBrowser } from '@laserfiche/lf-js-utils/dist/utils/core-utils.js';

export interface IAttributesClient {

    /**
     * - Returns the attribute key value pairs associated with the authenticated user. Alternatively, return only the attribute key value pairs that are associated with the "Everyone" group.
    - Attribute keys can be used with subsequent calls to get specific attribute values.
    - Optional query parameters: everyone (bool, default false). When true, this route does not return the attributes that are tied to the currently authenticated user, but rather the attributes assigned to the "Everyone" group. Note when this is true, the response does not include both the "Everyone" groups attribute and the currently authenticated user, but only the "Everyone" groups.
    - Default page size: 100. Allowed OData query options: Select, Count, OrderBy, Skip, Top, SkipToken, Prefer.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.everyone (optional) Boolean value that indicates whether to return attributes key value pairs associated with everyone or the currently authenticated user.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return A collection of attributes associated with the authenticated user.
     */
    listAttributes(args: { repositoryId: string, everyone?: boolean | undefined, prefer?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<AttributeCollectionResponse>;

    /**
     * - Returns the attribute associated with the key. Alternatively, return the attribute associated with the key within "Everyone" group.
    - Optional query parameters: everyone (bool, default false). When true, the server only searches for the attribute value with the given key upon the authenticated users attributes. If false, only the authenticated users attributes will be queried.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.attributeKey The requested attribute key.
     * @param args.everyone (optional) Boolean value that indicates whether to return attributes associated with everyone or the currently authenticated user.
     * @return A single attribute associated with the authenticated user.
     */
    getAttribute(args: { repositoryId: string, attributeKey: string, everyone?: boolean | undefined }): Promise<Attribute>;
}

export class AttributesClient implements IAttributesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.laserfiche.com/repository";
    }

    
  /**
   * It will continue to make the same call to get a list of attributes key value pairs of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repositoryId The requested repository ID.
   * @param args.everyone (optional) Boolean value that indicates whether to return attributes key value pairs associated with everyone or the currently authenticated user.
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of attributes key value pairs allowed per API response schema
   */
  async listAttributesForEach(args: {
    callback: (response: AttributeCollectionResponse) => Promise<boolean>;
    repositoryId: string;
    everyone?: boolean;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let { callback, repositoryId, everyone, select, orderby, top, skip, count, maxPageSize } = args;
    var response = await this.listAttributes({
      repositoryId,
      everyone,
      prefer: createMaxPageSizePreferHeaderPayload(maxPageSize),
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink) {
      response = await getNextLinkListing<AttributeCollectionResponse>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processListAttributes,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }
  /**
   * Returns the attribute key value pairs using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection.
   * @param args.maxPageSize (optional) the maximum page size or number of attribute keys allowed per API response schema.
   * @return Get trustee attribute keys with the next link successfully
   */
  async listAttributesNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<AttributeCollectionResponse> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<AttributeCollectionResponse>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processListAttributes,
      nextLink,
      maxPageSize
    );
  }

    /**
     * - Returns the attribute key value pairs associated with the authenticated user. Alternatively, return only the attribute key value pairs that are associated with the "Everyone" group.
    - Attribute keys can be used with subsequent calls to get specific attribute values.
    - Optional query parameters: everyone (bool, default false). When true, this route does not return the attributes that are tied to the currently authenticated user, but rather the attributes assigned to the "Everyone" group. Note when this is true, the response does not include both the "Everyone" groups attribute and the currently authenticated user, but only the "Everyone" groups.
    - Default page size: 100. Allowed OData query options: Select, Count, OrderBy, Skip, Top, SkipToken, Prefer.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.everyone (optional) Boolean value that indicates whether to return attributes key value pairs associated with everyone or the currently authenticated user.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return A collection of attributes associated with the authenticated user.
     */
    listAttributes(args: { repositoryId: string, everyone?: boolean | undefined, prefer?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<AttributeCollectionResponse> {
        let { repositoryId, everyone, prefer, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/Attributes?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (everyone === null)
            throw new Error("The parameter 'everyone' cannot be null.");
        else if (everyone !== undefined)
            url_ += "everyone=" + encodeURIComponent("" + everyone) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        if (prefer !== null && prefer !== undefined)
            options_.headers = Object.assign({}, options_.headers, {"Prefer": prefer !== undefined && prefer !== null ? "" + prefer : null});

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListAttributes(_response);
        });
    }

    protected processListAttributes(response: Response): Promise<AttributeCollectionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AttributeCollectionResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AttributeCollectionResponse>(null as any);
    }

    /**
     * - Returns the attribute associated with the key. Alternatively, return the attribute associated with the key within "Everyone" group.
    - Optional query parameters: everyone (bool, default false). When true, the server only searches for the attribute value with the given key upon the authenticated users attributes. If false, only the authenticated users attributes will be queried.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.attributeKey The requested attribute key.
     * @param args.everyone (optional) Boolean value that indicates whether to return attributes associated with everyone or the currently authenticated user.
     * @return A single attribute associated with the authenticated user.
     */
    getAttribute(args: { repositoryId: string, attributeKey: string, everyone?: boolean | undefined }): Promise<Attribute> {
        let { repositoryId, attributeKey, everyone } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/Attributes/{attributeKey}?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (attributeKey === undefined || attributeKey === null)
            throw new Error("The parameter 'attributeKey' must be defined.");
        url_ = url_.replace("{attributeKey}", encodeURIComponent("" + attributeKey));
        if (everyone === null)
            throw new Error("The parameter 'everyone' cannot be null.");
        else if (everyone !== undefined)
            url_ += "everyone=" + encodeURIComponent("" + everyone) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAttribute(_response);
        });
    }

    protected processGetAttribute(response: Response): Promise<Attribute> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Attribute.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Requested attribute key not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Attribute>(null as any);
    }
}

export interface IAuditReasonsClient {

    /**
     * - Returns the audit reasons associated with the authenticated user. Inherited audit reasons are included.
    - Only includes audit reasons associated with available API functionalities, like delete entry and export document.
    - If the authenticated user does not have the appropriate Laserfiche feature right, the audit reasons associated with that feature right will not be included.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return A collection of audit reasons.
     */
    listAuditReasons(args: { repositoryId: string, prefer?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<AuditReasonCollectionResponse>;
}

export class AuditReasonsClient implements IAuditReasonsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.laserfiche.com/repository";
    }

    /**
     * - Returns the audit reasons associated with the authenticated user. Inherited audit reasons are included.
    - Only includes audit reasons associated with available API functionalities, like delete entry and export document.
    - If the authenticated user does not have the appropriate Laserfiche feature right, the audit reasons associated with that feature right will not be included.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return A collection of audit reasons.
     */
    listAuditReasons(args: { repositoryId: string, prefer?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<AuditReasonCollectionResponse> {
        let { repositoryId, prefer, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/AuditReasons?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        if (prefer !== null && prefer !== undefined)
            options_.headers = Object.assign({}, options_.headers, {"Prefer": prefer !== undefined && prefer !== null ? "" + prefer : null});

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListAuditReasons(_response);
        });
    }

    protected processListAuditReasons(response: Response): Promise<AuditReasonCollectionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuditReasonCollectionResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuditReasonCollectionResponse>(null as any);
    }
}

export interface IFieldDefinitionsClient {

    /**
     * - Returns a single field definition associated with the specified ID. 
    - Useful when a route provides a minimal amount of details and more information about the specific field definition is needed.
    - Allowed OData query options: Select
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.fieldId The requested field definition ID.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.
     * @param args.select (optional) Limits the properties returned in the result.
     * @return A single field definition.
     */
    getFieldDefinition(args: { repositoryId: string, fieldId: number, culture?: string | null | undefined, select?: string | null | undefined }): Promise<FieldDefinition>;

    /**
     * - Returns a paged listing of field definitions available in the specified repository.
    - Useful when trying to find a list of all field definitions available, rather than only those assigned to a specific entry/template.
    - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return A collection of field definitions.
     */
    listFieldDefinitions(args: { repositoryId: string, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<FieldDefinitionCollectionResponse>;
}

export class FieldDefinitionsClient implements IFieldDefinitionsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.laserfiche.com/repository";
    }

    
  /**
   * It will continue to make the same call to get a list of field definitions of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repositoryId The requested repository ID.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
          The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise
          culture will not be used for formatting.  
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of field definitions allowed per API response schema.
   */
  async listFieldDefinitionsForEach(args: {
    callback: (response: FieldDefinitionCollectionResponse) => Promise<boolean>;
    repositoryId: string;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let { callback, repositoryId, prefer, culture, select, orderby, top, skip, count, maxPageSize } = args;
    var response = await this.listFieldDefinitions({
      repositoryId: repositoryId,
      prefer: createMaxPageSizePreferHeaderPayload(maxPageSize),
      culture,
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink) {
      response = await getNextLinkListing<FieldDefinitionCollectionResponse>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processListFieldDefinitions,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }
  /**
   * Returns a paged listing of field definitions available in the specified repository using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of field definitions allowed per API response schema
   * @return Get field definitions with the next link successfully
   */
  async listFieldDefinitionsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<FieldDefinitionCollectionResponse> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<FieldDefinitionCollectionResponse>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processListFieldDefinitions,
      nextLink,
      maxPageSize
    );
  }

    /**
     * - Returns a single field definition associated with the specified ID. 
    - Useful when a route provides a minimal amount of details and more information about the specific field definition is needed.
    - Allowed OData query options: Select
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.fieldId The requested field definition ID.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.
     * @param args.select (optional) Limits the properties returned in the result.
     * @return A single field definition.
     */
    getFieldDefinition(args: { repositoryId: string, fieldId: number, culture?: string | null | undefined, select?: string | null | undefined }): Promise<FieldDefinition> {
        let { repositoryId, fieldId, culture, select } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/FieldDefinitions/{fieldId}?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (fieldId === undefined || fieldId === null)
            throw new Error("The parameter 'fieldId' must be defined.");
        url_ = url_.replace("{fieldId}", encodeURIComponent("" + fieldId));
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFieldDefinition(_response);
        });
    }

    protected processGetFieldDefinition(response: Response): Promise<FieldDefinition> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FieldDefinition.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Requested field definition id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FieldDefinition>(null as any);
    }

    /**
     * - Returns a paged listing of field definitions available in the specified repository.
    - Useful when trying to find a list of all field definitions available, rather than only those assigned to a specific entry/template.
    - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return A collection of field definitions.
     */
    listFieldDefinitions(args: { repositoryId: string, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<FieldDefinitionCollectionResponse> {
        let { repositoryId, prefer, culture, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/FieldDefinitions?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        if (prefer !== null && prefer !== undefined)
            options_.headers = Object.assign({}, options_.headers, {"Prefer": prefer !== undefined && prefer !== null ? "" + prefer : null});

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListFieldDefinitions(_response);
        });
    }

    protected processListFieldDefinitions(response: Response): Promise<FieldDefinitionCollectionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FieldDefinitionCollectionResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FieldDefinitionCollectionResponse>(null as any);
    }
}

export interface ILinkDefinitionsClient {

    /**
     * - Returns the link definitions in the repository.
    - Provide a repository ID and get a paged listing of link definitions available in the repository. Useful when trying to display all link definitions available, not only links assigned to a specific entry.
    - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return A collection of link definitions.
     */
    listLinkDefinitions(args: { repositoryId: string, prefer?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<LinkDefinitionCollectionResponse>;

    /**
     * - Returns a single link definition associated with the specified ID.
    - Provide a link definition ID and get the associated link definition. Useful when a route provides a minimal amount of details and more information about the specific link definition is needed.
    - Allowed OData query options: Select
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.linkDefinitionId The requested link definition ID.
     * @param args.select (optional) Limits the properties returned in the result.
     * @return A single link definition.
     */
    getLinkDefinition(args: { repositoryId: string, linkDefinitionId: number, select?: string | null | undefined }): Promise<LinkDefinition>;
}

export class LinkDefinitionsClient implements ILinkDefinitionsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.laserfiche.com/repository";
    }

    
  /**
   * It will continue to make the same call to get a list of link definitions of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repositoryId The requested repository ID.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of link definitions allowed per API response schema.
   */
  async listLinkDefinitionsForEach(args: {
    callback: (response: LinkDefinitionCollectionResponse) => Promise<boolean>;
    repositoryId: string;
    prefer?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let { callback, repositoryId, prefer, select, orderby, top, skip, count, maxPageSize } = args;
    var response = await this.listLinkDefinitions({
      repositoryId: repositoryId,
      prefer: createMaxPageSizePreferHeaderPayload(maxPageSize),
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink) {
      response = await getNextLinkListing<LinkDefinitionCollectionResponse>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processListLinkDefinitions,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }

  /**
   * Returns all link definitions in the repository using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of link definitions allowed per API response schema
   * @return Get link definitions with the next link successfully
   */
  async listLinkDefinitionsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<LinkDefinitionCollectionResponse> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<LinkDefinitionCollectionResponse>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processListLinkDefinitions,
      nextLink,
      maxPageSize
    );
  }

    /**
     * - Returns the link definitions in the repository.
    - Provide a repository ID and get a paged listing of link definitions available in the repository. Useful when trying to display all link definitions available, not only links assigned to a specific entry.
    - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return A collection of link definitions.
     */
    listLinkDefinitions(args: { repositoryId: string, prefer?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<LinkDefinitionCollectionResponse> {
        let { repositoryId, prefer, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/LinkDefinitions?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        if (prefer !== null && prefer !== undefined)
            options_.headers = Object.assign({}, options_.headers, {"Prefer": prefer !== undefined && prefer !== null ? "" + prefer : null});

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListLinkDefinitions(_response);
        });
    }

    protected processListLinkDefinitions(response: Response): Promise<LinkDefinitionCollectionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LinkDefinitionCollectionResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LinkDefinitionCollectionResponse>(null as any);
    }

    /**
     * - Returns a single link definition associated with the specified ID.
    - Provide a link definition ID and get the associated link definition. Useful when a route provides a minimal amount of details and more information about the specific link definition is needed.
    - Allowed OData query options: Select
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.linkDefinitionId The requested link definition ID.
     * @param args.select (optional) Limits the properties returned in the result.
     * @return A single link definition.
     */
    getLinkDefinition(args: { repositoryId: string, linkDefinitionId: number, select?: string | null | undefined }): Promise<LinkDefinition> {
        let { repositoryId, linkDefinitionId, select } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/LinkDefinitions/{linkDefinitionId}?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (linkDefinitionId === undefined || linkDefinitionId === null)
            throw new Error("The parameter 'linkDefinitionId' must be defined.");
        url_ = url_.replace("{linkDefinitionId}", encodeURIComponent("" + linkDefinitionId));
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLinkDefinition(_response);
        });
    }

    protected processGetLinkDefinition(response: Response): Promise<LinkDefinition> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LinkDefinition.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Requested link definition ID not found", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LinkDefinition>(null as any);
    }
}

export interface IEntriesClient {

    /**
     * - Requests Upload URLs to upload a large file in chunks.
    - Returns an UploadId and an array of URLs to which the file chunks should be written in the same order.
    - To request a new batch of Upload URLs for the same file, set the value of UploadId to the one returned when the first batch of Upload URLs was requested. For requesting the first batch of Upload URLs, leave UploadId empty or null.
    - Example: if a file is going to be uploaded in 10 chunks, the 10 Upload URLs can be retrieved by two successive calls to this api, each call requesting 5 Upload URLs. For this, the first call should have StartingPartNumber=1 and NumberOfParts=5, and the second call should have StartingPartNumber=6 and NumberOfParts=5, along with UploadId returned in the first call.
    - Each Upload URL expires after 15 minutes.
    - Each file chunk written to an Upload URL should be at least 5 MB and at most 5 GB. There is no minimum size limit for the last chunk.
    - The value of NumberOfParts must be in the range [1, 100], meaning that in each call to this api, a maximum of 100 Upload URLs can be requested. 
    - The total number of Upload URLs for a single file is 1000, which means (StartingPartNumber + NumberOfParts) should be less than or equal to 1001.
    - Required OAuth scope: repository.Write
     * @param args.repositoryId The requested repository ID.
     * @param args.request The body of the request.
     * @return A response containing an upload id and an array of upload URLs.
     */
    createMultipartUploadUrls(args: { repositoryId: string, request: CreateMultipartUploadUrlsRequest }): Promise<CreateMultipartUploadUrlsResponse>;

    /**
     * - Imports a new file in the specified folder. The file should be already written (in chunks) to the upload URLs obtained by calling the Upload api.
    - This route does not support partial success.
    - Required OAuth scope: repository.Write
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The entry ID of the folder that the document will be created in.
     * @param args.request (optional) The metadata that will be set on the document.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag. This may be used when setting field values with tokens.
     * @return A long operation task id.
     */
    startImportUploadedParts(args: { repositoryId: string, entryId: number, request?: StartImportUploadedPartsRequest | undefined, culture?: string | null | undefined }): Promise<StartTaskResponse>;

    /**
     * - Starts an asynchronous export operation to export an entry.
    - If successful, it returns a taskId which can be used to check the status of the export operation or download the export result, otherwise, it returns an error.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The ID of entry to export.
     * @param args.request The body of the export request.
     * @param args.pageRange (optional) A comma seperated range of pages to include. Ex: 1,3,4 or 1-3,5-7,9. This value is ignored when part=Edoc.
     * @return A long operation task id.
     */
    startExportEntry(args: { repositoryId: string, entryId: number, request: StartExportEntryRequest, pageRange?: string | null | undefined }): Promise<StartTaskResponse>;

    /**
     * - Copy a new child entry in the designated folder async, and potentially return a taskId.
    - Provide the parent folder ID, and copy an entry as a child of the designated folder.
    - The status of the operation can be checked via the Tasks route.
    - Token substitution in the name of the copied entry is not supported.
    - Required OAuth scope: repository.Write
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The folder ID that the entry will be created in.
     * @param args.request Copy entry request.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag.
     * @return A long operation task id.
     */
    startCopyEntry(args: { repositoryId: string, entryId: number, request: StartCopyEntryRequest, culture?: string | null | undefined }): Promise<StartTaskResponse>;

    /**
     * - Begins a task to delete an entry, and returns a taskId.
    - Provide an entry ID, and queue a delete task to remove it from the repository (includes nested objects if the entry is a Folder type). The entry will not be deleted immediately.
    - Optionally include an audit reason ID and comment in the JSON body. This route returns a taskId, and will run as an asynchronous operation. Check the progress via the Tasks route.
    - Required OAuth scope: repository.Write
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The requested entry ID.
     * @param args.request (optional) The submitted audit reason.
     * @return A long operation task id.
     */
    startDeleteEntry(args: { repositoryId: string, entryId: number, request?: StartDeleteEntryRequest | undefined }): Promise<StartTaskResponse>;

    /**
     * - Returns a single entry object.
    - Provide an entry ID, and get the entry associated with that ID. Useful when detailed information about the entry is required, such as metadata, path information, etc.
    - If the entry is a subtype (Folder, Document, or Shortcut), the entry will automatically be converted to include those model-specific properties.
    - Allowed OData query options: Select.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The requested entry ID.
     * @param args.select (optional) Limits the properties returned in the result.
     * @return A single entry.
     */
    getEntry(args: { repositoryId: string, entryId: number, select?: string | null | undefined }): Promise<Entry>;

    /**
     * - Update an entry. (Move and/or Rename)
    - Move an entry to a new folder by setting the ParentId in the request body.
    - Rename an entry by setting the Name in the request body.
    - Required OAuth scope: repository.Write
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The requested entry ID.
     * @param args.request The request containing the folder ID that the entry will be moved to and the new name the entry will be renamed to.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag.
     * @return The updated entry.
     */
    updateEntry(args: { repositoryId: string, entryId: number, request: UpdateEntryRequest, culture?: string | null | undefined }): Promise<Entry>;

    /**
     * - Import a new document in the specified folder, and sets metadata.
    - The import may fail if the file is greater than 100 MB or time out if it takes longer than 60 seconds. These values are subject to change at anytime. Use the long operation asynchronous import if you run into these restrictions.
    - Required OAuth scope: repository.Write
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The entry ID of the folder that the document will be created in.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag. This may be used when setting field values with tokens.
     * @param args.file (optional) 
     * @param args.request (optional) 
     * @return The created entry.
     */
    importEntry(args: { repositoryId: string, entryId: number, culture?: string | null | undefined, file?: FileParameter | undefined, request?: ImportEntryRequest | undefined }): Promise<Entry>;

    /**
     * - Export an entry.
    - The export may time out if it takes longer than 60 seconds. This value is subject to change at anytime. Use the long operation asynchronous export if you run into this restriction.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The ID of entry to export.
     * @param args.request The body of the export request.
     * @param args.pageRange (optional) A comma separated range of pages to include. Ex: 1,3,4 or 1-3,5-7,9. This value is ignored when exporting as Edoc.
     * @return A link to download the exported entry.
     */
    exportEntry(args: { repositoryId: string, entryId: number, request: ExportEntryRequest, pageRange?: string | null | undefined }): Promise<ExportEntryResponse>;

    /**
     * - Returns a single entry object using the entry path.
    - Optional query parameter: fallbackToClosestAncestor. Use the fallbackToClosestAncestor query parameter to return the closest existing ancestor if the initial entry path is not found.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.fullPath The requested entry path.
     * @param args.fallbackToClosestAncestor (optional) An optional query parameter used to indicate whether or not the closest ancestor in the path should be returned if the initial entry path is not found. The default value is false.
     * @return The found entry or ancestor entry.
     */
    getEntryByPath(args: { repositoryId: string, fullPath: string, fallbackToClosestAncestor?: boolean | undefined }): Promise<GetEntryByPathResponse>;

    /**
     * - Returns the children entries of a folder in the repository.
    - Provide an entry ID (must be a folder), and get a paged listing of entries in that folder. Used as a way of navigating through the repository.
    - Entries returned in the listing are not automatically converted to their subtype (Folder, Shortcut, Document), so clients who want model-specific information should request it via the GET entry by ID route.
    - Optional query parameters: groupByOrderType (bool). This query parameter decides if results are returned in groups based on their entry type. 
    - Optionally returns field values for the entries in the folder. Each field name needs to be specified in the request. Maximum limit of 10 field names. If field values are requested, only the first value is returned if it is a multi value field. The remaining field values can be retrieved via the GET fields route. Null or Empty field values should not be used to determine if a field is assigned to the entry.
    - Default page size: 150. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer. OData $OrderBy syntax should follow: "PropertyName direction,PropertyName2 direction". Sort order can be either value "asc" or "desc".
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The folder ID.
     * @param args.groupByEntryType (optional) An optional query parameter used to indicate if the result should be grouped by entry type or not.
     * @param args.fields (optional) Optional array of field names. Field values corresponding to the given field names will be returned for each entry.
     * @param args.formatFieldValues (optional) Boolean for if field values should be formatted. Only applicable if Fields are specified.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise culture will not be used for formatting.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return A collection of children entries of a folder.
     */
    listEntries(args: { repositoryId: string, entryId: number, groupByEntryType?: boolean | undefined, fields?: string[] | null | undefined, formatFieldValues?: boolean | undefined, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<EntryCollectionResponse>;

    /**
     * - Create a new child entry in the designated folder.
    - Provide the parent folder ID, and based on the request body, create a folder/shortcut as a child entry of the designated folder.
    - Required OAuth scope: repository.Write
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The folder ID that the entry will be created in.
     * @param args.request The entry to create.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag.
     * @return The created entry.
     */
    createEntry(args: { repositoryId: string, entryId: number, request: CreateEntryRequest, culture?: string | null | undefined }): Promise<Entry>;

    /**
     * - Returns the fields assigned to an entry.
    - Provide an entry ID, and get a paged listing of all fields assigned to that entry.
    - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The requested entry ID.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.formatFieldValues (optional) An optional query parameter used to indicate if the field values should be formatted. The default value is false.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise culture will not be used for formatting.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return A collection of fields set on the entry.
     */
    listFields(args: { repositoryId: string, entryId: number, prefer?: string | null | undefined, formatFieldValues?: boolean | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<FieldCollectionResponse>;

    /**
     * - Update the field values assigned to an entry.
    - Provide the new field values to assign to the entry, and remove/reset all previously assigned field values.
    - This is an overwrite action. The request body must include all desired field values, including any existing field values that should remain assigned to the entry. Field values that are not included in the request will be deleted from the entry. If the field value that is not included is part of a template, it will still be assigned (as required by the template), but its value will be reset.
    - Required OAuth scope: repository.Write
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The entry ID of the entry that will have its fields updated.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag. This may be used when setting field values with tokens.
     * @return A collection of fields set on the entry.
     */
    setFields(args: { repositoryId: string, entryId: number, request: SetFieldsRequest, culture?: string | null | undefined }): Promise<FieldCollectionResponse>;

    /**
     * - Returns the tags assigned to an entry.
    - Provide an entry ID, and get a paged listing of tags assigned to that entry.
    - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The requested entry ID.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return A collection of tags set on the entry.
     */
    listTags(args: { repositoryId: string, entryId: number, prefer?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<TagCollectionResponse>;

    /**
     * - Assign tags to an entry.
    - Provide an entry ID and a list of tags to assign to that entry.
    - This is an overwrite action. The request must include all tags to assign to the entry, including existing tags that should remain assigned to the entry.
    - Required OAuth scope: repository.Write
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The requested entry ID.
     * @param args.request The tags to add.
     * @return A collection of tags set on the entry.
     */
    setTags(args: { repositoryId: string, entryId: number, request: SetTagsRequest }): Promise<TagCollectionResponse>;

    /**
     * - Assign links to an entry.
    - Provide an entry ID and a list of links to assign to that entry.
    - This is an overwrite action. The request must include all links to assign to the entry, including existing links that should remain assigned to the entry.
    - Required OAuth scope: repository.Write
     * @param args.repositoryId The request repository ID.
     * @param args.entryId The requested entry ID.
     * @return A collection of links set on the entry.
     */
    setLinks(args: { repositoryId: string, entryId: number, request: SetLinksRequest }): Promise<LinkCollectionResponse>;

    /**
     * - Returns the links assigned to an entry.
    - Provide an entry ID, and get a paged listing of links assigned to that entry.
    - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The requested entry ID.
     * @param args.prefer (optional) An optional odata header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return A collection of links set on the entry.
     */
    listLinks(args: { repositoryId: string, entryId: number, prefer?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<LinkCollectionResponse>;

    /**
     * - Copy a new child entry in the designated folder.
    - Provide the parent folder ID, and based on the request body, copy a child entry of the designated folder.
    - Required OAuth scope: repository.Write
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The folder ID that the entry will be created in.
     * @param args.request The entry to create.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag.
     * @return The copied entry.
     */
    copyEntry(args: { repositoryId: string, entryId: number, request: CopyEntryRequest, culture?: string | null | undefined }): Promise<Entry>;

    /**
     * - Delete the edoc associated with the provided entry ID.
    - Required OAuth scope: repository.Write
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The requested document ID.
     * @return The updated entry.
     */
    deleteElectronicDocument(args: { repositoryId: string, entryId: number }): Promise<Entry>;

    /**
     * - Delete the pages associated with the provided entry ID. If no pageRange is specified, all pages will be deleted.
    - Optional parameter: pageRange (default empty). The value should be a comma-seperated string which contains non-overlapping single values, or page ranges. Ex: "1,2,3", "1-3,5", "2-7,10-12."
    - Required OAuth scope: repository.Write
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The requested document ID.
     * @param args.pageRange (optional) The pages to be deleted.
     * @return The updated entry.
     */
    deletePages(args: { repositoryId: string, entryId: number, pageRange?: string | null | undefined }): Promise<Entry>;

    /**
     * - Returns dynamic field logic values with the current values of the fields in the template.
    - Provide an entry ID and field values in the JSON body to get dynamic field logic values.
    - Independent and non-dynamic fields in the request body will be ignored, and only related dynamic field logic values for the assigned template will be returned.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The requested entry ID.
     * @return A collection of dynamic field values.
     */
    listDynamicFieldValues(args: { repositoryId: string, entryId: number, request: ListDynamicFieldValuesRequest }): Promise<{ [key: string]: string[]; }>;

    /**
     * - Remove the currently assigned template from the specified entry.
    - Provide an entry ID to clear template value on.
    - If the entry does not have a template assigned, no change will be made.
    - Required OAuth scope: repository.Write
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The ID of the entry that will have its template removed.
     * @return The updated entry.
     */
    removeTemplate(args: { repositoryId: string, entryId: number }): Promise<Entry>;

    /**
     * - Assign a template to an entry.
    - Provide an entry ID, template name, and a list of template fields to assign to that entry.
    - Only template values will be modified. Any existing independent fields on the entry will not be modified, nor will they be added if included in the request. The only modification to fields will only occur on templated fields. If the previously assigned template includes common template fields as the newly assigned template, the common field values will not be modified.
    - Required OAuth scope: repository.Write
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The ID of entry that will have its template updated.
     * @param args.request The template and template fields that will be assigned to the entry.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag. This may be used when setting field values with tokens.
     * @return The updated entry.
     */
    setTemplate(args: { repositoryId: string, entryId: number, request: SetTemplateRequest, culture?: string | null | undefined }): Promise<Entry>;
}

export class EntriesClient implements IEntriesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.laserfiche.com/repository";
    }

    
  /**
   * This is a helper for wrapping the CreateMultipartUploadURls and the ImportUploadedParts APIs. 
   * If successful, it returns a taskId which can be used to check the status of the operation or retrieve its result, otherwise, it returns an error.
   * Required OAuth scope: repository.Write
   * @param args.repositoryId The requested repository ID.
   * @param args.entryId The entry ID of the folder that the document will be created in.
   * @param args.file The file to be imported as a new document. 
   * @param args.mimeType The mime-type of the file to be imported as a new document. 
   * @param args.request The body of the request.
   * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag. This may be used when setting field values with tokens.
   * @return A long operation task id.
  */
  async startImportEntry(args: { 
    repositoryId: string;
    entryId: number;
    file: FileParameter;
    mimeType: string;
    request: ImportEntryRequest;
    culture?: string | null | undefined;
  }): Promise<StartTaskResponse> {
    // The maximum number of URLs requested in each call to the CreateMultipartUploadUrls API.
    const numberOfUrlsRequestedInEachCall = 10;
    var thereAreMoreParts = true;   
    var eTags = new Array<string>();
    let uploadId = null;
    var dataSource = null;
    try 
    {

      if (isBrowser()) {
        dataSource = args.file.data;
      } else {
        dataSource = await fsPromise.open(args.file.fileName, 'r');
      }

      let iteration = 0;
      // Iteratively request URLs and write file parts into the URLs.
      while (thereAreMoreParts) {
        iteration++;
        // Step 1: Request a batch of URLs by calling the CreateMultipartUploadUrls API.
        var request = this.prepareRequestForCreateMultipartUploadUrlsApi(iteration, numberOfUrlsRequestedInEachCall, this.getFileName(args.file.fileName), args.mimeType, uploadId);
        let response = await this.createMultipartUploadUrls({
          repositoryId: args.repositoryId,
          request: request
        });

        if (iteration == 1) {
          uploadId = response.uploadId;
        }
        
        // Step 2: Split the file and write the parts to current batch of URLs.
        var eTagsForThisIteration: any;
        eTagsForThisIteration = await this.writeFileParts(dataSource!, response.urls!);
        eTags.push.apply(eTags, eTagsForThisIteration);

        thereAreMoreParts = eTagsForThisIteration.length == numberOfUrlsRequestedInEachCall;
      }

      // Step 3: File parts are written, and eTags are ready. Call the ImportUploadedParts API.
      var finalRequest = this.prepareRequestForImportUploadedPartsApi(uploadId!, eTags, args.request.name, args.request.autoRename, args.request.pdfOptions, args.request.importAsElectronicDocument, args.request.metadata, args.request.volumeName);
      var response = await this.startImportUploadedParts({
        repositoryId: args.repositoryId,
        entryId: args.entryId,
        request: finalRequest
      });
  
      return StartTaskResponse.fromJS(response);
  
    } finally {
      if (dataSource && !isBrowser()) {
        dataSource.close();
      }
    }
  }

  /**
   * Returns the file name of a given file path.
   * @param filePath The path to a file.
   * @returns The file name.
   */
  getFileName(filePath: string): string {
    let fileName = filePath;
    var index = filePath.lastIndexOf('/');
    if (index >= 0) {
      fileName = filePath.substring(index + 1);
    }
    return fileName;
  }
  /**
   * Prepares and returns the request body for calling the ImportUploadedParts API.
   */
  prepareRequestForImportUploadedPartsApi(uploadId: string, eTags: string[], name?: string, autoRename?: boolean, pdfOptions?: PdfImportOptions, importAsElectronicDocument?: boolean, metadata?: ImportAsyncMetadata, volumeName?: string): StartImportUploadedPartsRequest {
    var parameters ={
      uploadId: uploadId,
      partETags: eTags,
      name: name,
      autoRename: autoRename,
      pdfOptions: pdfOptions,
      importAsElectronicDocument: importAsElectronicDocument,
      metadata: metadata,
      volumeName: volumeName
    };
    return StartImportUploadedPartsRequest.fromJS(parameters);
  }

  /**
   * Takes a source for reading file data, and a set of URLs. 
   * Then reads data from the source, on a part-by-part basis, and and writes the file parts to the given URLs.
   * @returns The eTags of the parts written.
   */
  async writeFileParts(source: any, urls: string[]): Promise<string[]> {
    let partSizeInMB = 100;
    let eTags = new Array<string>(urls.length);
    var writtenParts = 0;

    var partNumber = 0;
    for (let i = 0; i < urls.length; i++) {
      partNumber++;
      var url = urls[i];
      var partData: any;
      var endOfFileReached: boolean;
      if (isBrowser()) {
        [partData, endOfFileReached] = await this.readOnePartForBrowserMode(source, partSizeInMB, partNumber);
      } else {
        [partData, endOfFileReached] = await this.readOnePartForNonBrowserMode(source, partSizeInMB);
      }

      if (endOfFileReached) {
        // There has been no more data to write.
        break;
      }
      var eTag = await this.writeFilePart(partData, url);
      writtenParts++;
      eTags[i] = eTag;
    }
    return eTags.slice(0, writtenParts);
  }

  async readOnePartForNonBrowserMode(file: fsPromise.FileHandle, partSizeInMB: number): Promise<[Uint8Array, boolean]> {
    const bufferSizeInBytes = partSizeInMB * 1024 * 1024;
    var buffer = new Uint8Array(bufferSizeInBytes);
    var readResult = await file.read(buffer, 0, bufferSizeInBytes);
    var endOfFileReached = readResult.bytesRead == 0;
    var partData = readResult.buffer.subarray(0, readResult.bytesRead);
    return [partData, endOfFileReached];
  }

  async readOnePartForBrowserMode(blob: Blob, partSizeInMB: number, partNumber: number): Promise<[Uint8Array | null, boolean]> {
    const bufferSizeInBytes = partSizeInMB * 1024 * 1024;
    var offset = (partNumber - 1) *  bufferSizeInBytes;
    var partBlob = blob.slice(offset, offset + bufferSizeInBytes);
    var endOfFileReached = false;
    var partData = null;
    var readerDone = false;
    if (partBlob) {
      const reader = new FileReader();
      reader.addEventListener("loadend", (event) => {
        var data = reader.result;
        if (data instanceof ArrayBuffer) {
          partData = new Uint8Array(data);
          endOfFileReached = partData.byteLength == 0;
        }
        readerDone = true;
      });
      reader.readAsArrayBuffer(partBlob); 
    }
    while(!readerDone) {
      await new Promise((r) => setTimeout(r, 5000));
    }
    return [partData, endOfFileReached];
  }

    /**
   * Takes a file part and a single URL, and writes the part to the given URL.
   * @returns The eTag of the part written.
   */
  async writeFilePart(part: Uint8Array, url: string): Promise<string> {
    var eTag = "";
      const response = await fetch(url, {
        method: 'PUT',
        body: part,
        headers: {'Content-Type': 'application/octet-stream'} });
      
      if (response.ok && response.body !== null && response.status == 200) {
        eTag = response.headers.get("ETag")!;
        if (eTag) {
          eTag = eTag.substring(1, eTag.length - 1); // Remove heading and trailing double-quotation
        }
      } 
    
    return eTag;
  }

  /**
   * Prepares and returns the request body for calling the CreateMultipartUploadUrls API.
   */
  prepareRequestForCreateMultipartUploadUrlsApi(iteration: number, numberOfUrlsRequestedInEachCall: number, fileName: string, mimeType: string, uploadId? : string | null): CreateMultipartUploadUrlsRequest {
    var parameters = (iteration == 1) ? {
      startingPartNumber: 1,
      numberOfParts: numberOfUrlsRequestedInEachCall,
      fileName: fileName,
      mimeType: mimeType
    } : {
      uploadId: uploadId,
      startingPartNumber: (iteration - 1) * numberOfUrlsRequestedInEachCall + 1,
      numberOfParts: numberOfUrlsRequestedInEachCall,
    };
    return CreateMultipartUploadUrlsRequest.fromJS(parameters);
  }

  /**
   * It will continue to make the same call to get a list of entry listings of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repositoryId The requested repository ID.
   * @param args.entryId The requested entry ID.
   * @param args.groupByEntryType (optional) An optional query parameter used to indicate if the result should be grouped by entry type or not.
   * @param args.fields (optional) Optional array of field names. Field values corresponding to the given field names will be returned for each entry.
   * @param args.formatFieldValues (optional) Boolean for if field values should be formatted. Only applicable if Fields are specified.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
          The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise
          culture will not be used for formatting. 
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of entry listings allowed per API response schema.
   */
  async listEntriesForEach(args: {
    callback: (response: EntryCollectionResponse) => Promise<boolean>;
    repositoryId: string;
    entryId: number;
    groupByEntryType?: boolean;
    fields?: string[];
    formatFieldValues?: boolean;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let {
      callback,
      repositoryId,
      entryId,
      groupByEntryType,
      fields,
      formatFieldValues,
      prefer,
      culture,
      select,
      orderby,
      top,
      skip,
      count,
      maxPageSize,
    } = args;
    var response = await this.listEntries({
      repositoryId: repositoryId,
      entryId,
      groupByEntryType,
      fields,
      formatFieldValues,
      prefer: createMaxPageSizePreferHeaderPayload(maxPageSize),
      culture,
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink) {
      response = await getNextLinkListing<EntryCollectionResponse>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processListEntries,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }
  /**
   * It will continue to make the same call to get a list of field values of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repositoryId The requested repository ID.
   * @param args.entryId The requested entry ID.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.formatValue (optional) An optional query parameter used to indicate if the field values should be formatted.
          The default value is false. 
   * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
          The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise
          culture will not be used for formatting. 
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of field values allowed per API response schema.
   */
  async listFieldsForEach(args: {
    callback: (response: FieldCollectionResponse) => Promise<boolean>;
    repositoryId: string;
    entryId: number;
    prefer?: string;
    formatValue?: boolean;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let { callback, repositoryId, entryId, prefer, formatValue, culture, select, orderby, top, skip, count, maxPageSize } =
      args;
    var response = await this.listFields({
      repositoryId: repositoryId,
      entryId,
      prefer: createMaxPageSizePreferHeaderPayload(maxPageSize),
      formatFieldValues: formatValue,
      culture,
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink) {
      response = await getNextLinkListing<FieldCollectionResponse>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processListFields,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }
  /**
   * It will continue to make the same call to get a list of link values from entry of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repositoryId The requested repository ID.
   * @param args.entryId The requested entry ID.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of link values from entry allowed per API response schema.
   */
  async listLinksForEach(args: {
    callback: (response: LinkCollectionResponse) => Promise<boolean>;
    repositoryId: string;
    entryId: number;
    prefer?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let { callback, repositoryId, entryId, prefer, select, orderby, top, skip, count, maxPageSize } = args;
    var response = await this.listLinks({
      repositoryId: repositoryId,
      entryId,
      prefer: createMaxPageSizePreferHeaderPayload(maxPageSize),
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink) {
      response = await getNextLinkListing<LinkCollectionResponse>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processListLinks,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }
  /**
   * It will continue to make the same call to get a list of tags assigned to entry of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repositoryId The requested repository ID.
   * @param args.entryId The requested entry ID.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of tags assigned to entry allowed per API response schema.
   */
  async listTagsForEach(args: {
    callback: (response: TagDefinitionCollectionResponse) => Promise<boolean>;
    repositoryId: string;
    entryId: number;
    prefer?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let { callback, repositoryId, entryId, prefer, select, orderby, top, skip, count, maxPageSize } = args;
    var response = await this.listTags({
      repositoryId: repositoryId,
      entryId,
      prefer: createMaxPageSizePreferHeaderPayload(maxPageSize),
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink) {
      response = await getNextLinkListing<TagDefinitionCollectionResponse>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processListTags,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }
  /**
   * Returns the children entries of a folder in the repository using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of entry listings allowed per API response schema
   * @return Get the children entries of a Folder with the next link successfully
   */
  async listEntriesNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<EntryCollectionResponse> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<EntryCollectionResponse>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processListEntries,
      nextLink,
      maxPageSize
    );
  }
  /**
   * Returns the fields assigned to an entry using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of field values allowed per API response schema
   * @return Get field values with the next link successfully
   */
  async listFieldsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<FieldCollectionResponse> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<FieldCollectionResponse>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processListFields,
      nextLink,
      maxPageSize
    );
  }
  /**
   * Returns the links assigned to an entry using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of link values from entry allowed per API response schema
   * @return Get links with the next link successfully
   */
  async listLinksNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<LinkCollectionResponse> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<LinkCollectionResponse>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processListLinks,
      nextLink,
      maxPageSize
    );
  }
  /**
   * Returns the entry tags assigned to an entry using a link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of tags assigned to entry allowed per API response schema
   * @return Get entry tags with the next link successfully
   */
  async listTagsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<TagDefinitionCollectionResponse> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<LinkCollectionResponse>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processListTags,
      nextLink,
      maxPageSize
    );
  }

    /**
     * - Requests Upload URLs to upload a large file in chunks.
    - Returns an UploadId and an array of URLs to which the file chunks should be written in the same order.
    - To request a new batch of Upload URLs for the same file, set the value of UploadId to the one returned when the first batch of Upload URLs was requested. For requesting the first batch of Upload URLs, leave UploadId empty or null.
    - Example: if a file is going to be uploaded in 10 chunks, the 10 Upload URLs can be retrieved by two successive calls to this api, each call requesting 5 Upload URLs. For this, the first call should have StartingPartNumber=1 and NumberOfParts=5, and the second call should have StartingPartNumber=6 and NumberOfParts=5, along with UploadId returned in the first call.
    - Each Upload URL expires after 15 minutes.
    - Each file chunk written to an Upload URL should be at least 5 MB and at most 5 GB. There is no minimum size limit for the last chunk.
    - The value of NumberOfParts must be in the range [1, 100], meaning that in each call to this api, a maximum of 100 Upload URLs can be requested. 
    - The total number of Upload URLs for a single file is 1000, which means (StartingPartNumber + NumberOfParts) should be less than or equal to 1001.
    - Required OAuth scope: repository.Write
     * @param args.repositoryId The requested repository ID.
     * @param args.request The body of the request.
     * @return A response containing an upload id and an array of upload URLs.
     */
    createMultipartUploadUrls(args: { repositoryId: string, request: CreateMultipartUploadUrlsRequest }): Promise<CreateMultipartUploadUrlsResponse> {
        let { repositoryId, request } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/Entries/CreateMultipartUploadUrls";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateMultipartUploadUrls(_response);
        });
    }

    protected processCreateMultipartUploadUrls(response: Response): Promise<CreateMultipartUploadUrlsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateMultipartUploadUrlsResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Requested repository not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 413) {
            return response.text().then((_responseText) => {
            let result413: any = null;
            let resultData413 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result413 = ProblemDetails.fromJS(resultData413);
            return throwException("Request is too large.", status, _responseText, _headers, result413);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreateMultipartUploadUrlsResponse>(null as any);
    }

    /**
     * - Imports a new file in the specified folder. The file should be already written (in chunks) to the upload URLs obtained by calling the Upload api.
    - This route does not support partial success.
    - Required OAuth scope: repository.Write
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The entry ID of the folder that the document will be created in.
     * @param args.request (optional) The metadata that will be set on the document.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag. This may be used when setting field values with tokens.
     * @return A long operation task id.
     */
    startImportUploadedParts(args: { repositoryId: string, entryId: number, request?: StartImportUploadedPartsRequest | undefined, culture?: string | null | undefined }): Promise<StartTaskResponse> {
        let { repositoryId, entryId, request, culture } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/Entries/{entryId}/Folder/ImportUploadedParts?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartImportUploadedParts(_response);
        });
    }

    protected processStartImportUploadedParts(response: Response): Promise<StartTaskResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 202) {
            return response.text().then((_responseText) => {
            let result202: any = null;
            let resultData202 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result202 = StartTaskResponse.fromJS(resultData202);
            return result202;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Requested repository not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 413) {
            return response.text().then((_responseText) => {
            let result413: any = null;
            let resultData413 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result413 = ProblemDetails.fromJS(resultData413);
            return throwException("Request is too large.", status, _responseText, _headers, result413);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Import operation failed due to an internal server error.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StartTaskResponse>(null as any);
    }

    /**
     * - Starts an asynchronous export operation to export an entry.
    - If successful, it returns a taskId which can be used to check the status of the export operation or download the export result, otherwise, it returns an error.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The ID of entry to export.
     * @param args.request The body of the export request.
     * @param args.pageRange (optional) A comma seperated range of pages to include. Ex: 1,3,4 or 1-3,5-7,9. This value is ignored when part=Edoc.
     * @return A long operation task id.
     */
    startExportEntry(args: { repositoryId: string, entryId: number, request: StartExportEntryRequest, pageRange?: string | null | undefined }): Promise<StartTaskResponse> {
        let { repositoryId, entryId, request, pageRange } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/Entries/{entryId}/ExportAsync?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (pageRange !== undefined && pageRange !== null)
            url_ += "pageRange=" + encodeURIComponent("" + pageRange) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartExportEntry(_response);
        });
    }

    protected processStartExportEntry(response: Response): Promise<StartTaskResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 202) {
            return response.text().then((_responseText) => {
            let result202: any = null;
            let resultData202 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result202 = StartTaskResponse.fromJS(resultData202);
            return result202;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Requested repository not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 413) {
            return response.text().then((_responseText) => {
            let result413: any = null;
            let resultData413 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result413 = ProblemDetails.fromJS(resultData413);
            return throwException("Request is too large.", status, _responseText, _headers, result413);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Export operation failed due to an internal server error.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StartTaskResponse>(null as any);
    }

    /**
     * - Copy a new child entry in the designated folder async, and potentially return a taskId.
    - Provide the parent folder ID, and copy an entry as a child of the designated folder.
    - The status of the operation can be checked via the Tasks route.
    - Token substitution in the name of the copied entry is not supported.
    - Required OAuth scope: repository.Write
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The folder ID that the entry will be created in.
     * @param args.request Copy entry request.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag.
     * @return A long operation task id.
     */
    startCopyEntry(args: { repositoryId: string, entryId: number, request: StartCopyEntryRequest, culture?: string | null | undefined }): Promise<StartTaskResponse> {
        let { repositoryId, entryId, request, culture } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/Entries/{entryId}/Folder/CopyAsync?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartCopyEntry(_response);
        });
    }

    protected processStartCopyEntry(response: Response): Promise<StartTaskResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 202) {
            return response.text().then((_responseText) => {
            let result202: any = null;
            let resultData202 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result202 = StartTaskResponse.fromJS(resultData202);
            return result202;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Requested repository not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 413) {
            return response.text().then((_responseText) => {
            let result413: any = null;
            let resultData413 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result413 = ProblemDetails.fromJS(resultData413);
            return throwException("Request is too large.", status, _responseText, _headers, result413);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Operation limit or request limit reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StartTaskResponse>(null as any);
    }

    /**
     * - Begins a task to delete an entry, and returns a taskId.
    - Provide an entry ID, and queue a delete task to remove it from the repository (includes nested objects if the entry is a Folder type). The entry will not be deleted immediately.
    - Optionally include an audit reason ID and comment in the JSON body. This route returns a taskId, and will run as an asynchronous operation. Check the progress via the Tasks route.
    - Required OAuth scope: repository.Write
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The requested entry ID.
     * @param args.request (optional) The submitted audit reason.
     * @return A long operation task id.
     */
    startDeleteEntry(args: { repositoryId: string, entryId: number, request?: StartDeleteEntryRequest | undefined }): Promise<StartTaskResponse> {
        let { repositoryId, entryId, request } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/Entries/{entryId}";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartDeleteEntry(_response);
        });
    }

    protected processStartDeleteEntry(response: Response): Promise<StartTaskResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 202) {
            return response.text().then((_responseText) => {
            let result202: any = null;
            let resultData202 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result202 = StartTaskResponse.fromJS(resultData202);
            return result202;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Requested repository not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 413) {
            return response.text().then((_responseText) => {
            let result413: any = null;
            let resultData413 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result413 = ProblemDetails.fromJS(resultData413);
            return throwException("Request is too large.", status, _responseText, _headers, result413);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Operation limit or request limit reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StartTaskResponse>(null as any);
    }

    /**
     * - Returns a single entry object.
    - Provide an entry ID, and get the entry associated with that ID. Useful when detailed information about the entry is required, such as metadata, path information, etc.
    - If the entry is a subtype (Folder, Document, or Shortcut), the entry will automatically be converted to include those model-specific properties.
    - Allowed OData query options: Select.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The requested entry ID.
     * @param args.select (optional) Limits the properties returned in the result.
     * @return A single entry.
     */
    getEntry(args: { repositoryId: string, entryId: number, select?: string | null | undefined }): Promise<Entry> {
        let { repositoryId, entryId, select } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/Entries/{entryId}?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntry(_response);
        });
    }

    protected processGetEntry(response: Response): Promise<Entry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Entry.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Requested entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry>(null as any);
    }

    /**
     * - Update an entry. (Move and/or Rename)
    - Move an entry to a new folder by setting the ParentId in the request body.
    - Rename an entry by setting the Name in the request body.
    - Required OAuth scope: repository.Write
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The requested entry ID.
     * @param args.request The request containing the folder ID that the entry will be moved to and the new name the entry will be renamed to.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag.
     * @return The updated entry.
     */
    updateEntry(args: { repositoryId: string, entryId: number, request: UpdateEntryRequest, culture?: string | null | undefined }): Promise<Entry> {
        let { repositoryId, entryId, request, culture } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/Entries/{entryId}?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateEntry(_response);
        });
    }

    protected processUpdateEntry(response: Response): Promise<Entry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Entry.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Entry name conflicts.", status, _responseText, _headers, result409);
            });
        } else if (status === 413) {
            return response.text().then((_responseText) => {
            let result413: any = null;
            let resultData413 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result413 = ProblemDetails.fromJS(resultData413);
            return throwException("Request is too large.", status, _responseText, _headers, result413);
            });
        } else if (status === 423) {
            return response.text().then((_responseText) => {
            let result423: any = null;
            let resultData423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result423 = ProblemDetails.fromJS(resultData423);
            return throwException("Entry is locked.", status, _responseText, _headers, result423);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry>(null as any);
    }

    /**
     * - Import a new document in the specified folder, and sets metadata.
    - The import may fail if the file is greater than 100 MB or time out if it takes longer than 60 seconds. These values are subject to change at anytime. Use the long operation asynchronous import if you run into these restrictions.
    - Required OAuth scope: repository.Write
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The entry ID of the folder that the document will be created in.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag. This may be used when setting field values with tokens.
     * @param args.file (optional) 
     * @param args.request (optional) 
     * @return The created entry.
     */
    importEntry(args: { repositoryId: string, entryId: number, culture?: string | null | undefined, file?: FileParameter | undefined, request?: ImportEntryRequest | undefined }): Promise<Entry> {
        let { repositoryId, entryId, culture, file, request } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/Entries/{entryId}/Folder/Import?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");
        if (request === null || request === undefined)
            throw new Error("The parameter 'request' cannot be null.");
        else
            content_.append("request", JSON.stringify(request));

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processImportEntry(_response);
        });
    }

    protected processImportEntry(response: Response): Promise<Entry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Entry.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 413) {
            return response.text().then((_responseText) => {
            let result413: any = null;
            let resultData413 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result413 = ProblemDetails.fromJS(resultData413);
            return throwException("Request is too large.", status, _responseText, _headers, result413);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Document creation is completely failed.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry>(null as any);
    }

    /**
     * - Export an entry.
    - The export may time out if it takes longer than 60 seconds. This value is subject to change at anytime. Use the long operation asynchronous export if you run into this restriction.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The ID of entry to export.
     * @param args.request The body of the export request.
     * @param args.pageRange (optional) A comma separated range of pages to include. Ex: 1,3,4 or 1-3,5-7,9. This value is ignored when exporting as Edoc.
     * @return A link to download the exported entry.
     */
    exportEntry(args: { repositoryId: string, entryId: number, request: ExportEntryRequest, pageRange?: string | null | undefined }): Promise<ExportEntryResponse> {
        let { repositoryId, entryId, request, pageRange } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/Entries/{entryId}/Export?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (pageRange !== undefined && pageRange !== null)
            url_ += "pageRange=" + encodeURIComponent("" + pageRange) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExportEntry(_response);
        });
    }

    protected processExportEntry(response: Response): Promise<ExportEntryResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExportEntryResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 413) {
            return response.text().then((_responseText) => {
            let result413: any = null;
            let resultData413 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result413 = ProblemDetails.fromJS(resultData413);
            return throwException("Request is too large.", status, _responseText, _headers, result413);
            });
        } else if (status === 423) {
            return response.text().then((_responseText) => {
            let result423: any = null;
            let resultData423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result423 = ProblemDetails.fromJS(resultData423);
            return throwException("Entry is locked.", status, _responseText, _headers, result423);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Export operation failed due to an internal server error.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExportEntryResponse>(null as any);
    }

    /**
     * - Returns a single entry object using the entry path.
    - Optional query parameter: fallbackToClosestAncestor. Use the fallbackToClosestAncestor query parameter to return the closest existing ancestor if the initial entry path is not found.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.fullPath The requested entry path.
     * @param args.fallbackToClosestAncestor (optional) An optional query parameter used to indicate whether or not the closest ancestor in the path should be returned if the initial entry path is not found. The default value is false.
     * @return The found entry or ancestor entry.
     */
    getEntryByPath(args: { repositoryId: string, fullPath: string, fallbackToClosestAncestor?: boolean | undefined }): Promise<GetEntryByPathResponse> {
        let { repositoryId, fullPath, fallbackToClosestAncestor } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/Entries/ByPath?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (fullPath === undefined || fullPath === null)
            throw new Error("The parameter 'fullPath' must be defined and cannot be null.");
        else
            url_ += "fullPath=" + encodeURIComponent("" + fullPath) + "&";
        if (fallbackToClosestAncestor === null)
            throw new Error("The parameter 'fallbackToClosestAncestor' cannot be null.");
        else if (fallbackToClosestAncestor !== undefined)
            url_ += "fallbackToClosestAncestor=" + encodeURIComponent("" + fallbackToClosestAncestor) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntryByPath(_response);
        });
    }

    protected processGetEntryByPath(response: Response): Promise<GetEntryByPathResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEntryByPathResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Requested entry path not found", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetEntryByPathResponse>(null as any);
    }

    /**
     * - Returns the children entries of a folder in the repository.
    - Provide an entry ID (must be a folder), and get a paged listing of entries in that folder. Used as a way of navigating through the repository.
    - Entries returned in the listing are not automatically converted to their subtype (Folder, Shortcut, Document), so clients who want model-specific information should request it via the GET entry by ID route.
    - Optional query parameters: groupByOrderType (bool). This query parameter decides if results are returned in groups based on their entry type. 
    - Optionally returns field values for the entries in the folder. Each field name needs to be specified in the request. Maximum limit of 10 field names. If field values are requested, only the first value is returned if it is a multi value field. The remaining field values can be retrieved via the GET fields route. Null or Empty field values should not be used to determine if a field is assigned to the entry.
    - Default page size: 150. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer. OData $OrderBy syntax should follow: "PropertyName direction,PropertyName2 direction". Sort order can be either value "asc" or "desc".
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The folder ID.
     * @param args.groupByEntryType (optional) An optional query parameter used to indicate if the result should be grouped by entry type or not.
     * @param args.fields (optional) Optional array of field names. Field values corresponding to the given field names will be returned for each entry.
     * @param args.formatFieldValues (optional) Boolean for if field values should be formatted. Only applicable if Fields are specified.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise culture will not be used for formatting.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return A collection of children entries of a folder.
     */
    listEntries(args: { repositoryId: string, entryId: number, groupByEntryType?: boolean | undefined, fields?: string[] | null | undefined, formatFieldValues?: boolean | undefined, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<EntryCollectionResponse> {
        let { repositoryId, entryId, groupByEntryType, fields, formatFieldValues, prefer, culture, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/Entries/{entryId}/Folder/Children?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (groupByEntryType === null)
            throw new Error("The parameter 'groupByEntryType' cannot be null.");
        else if (groupByEntryType !== undefined)
            url_ += "groupByEntryType=" + encodeURIComponent("" + groupByEntryType) + "&";
        if (fields !== undefined && fields !== null)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (formatFieldValues === null)
            throw new Error("The parameter 'formatFieldValues' cannot be null.");
        else if (formatFieldValues !== undefined)
            url_ += "formatFieldValues=" + encodeURIComponent("" + formatFieldValues) + "&";
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        if (prefer !== null && prefer !== undefined)
            options_.headers = Object.assign({}, options_.headers, {"Prefer": prefer !== undefined && prefer !== null ? "" + prefer : null});

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListEntries(_response);
        });
    }

    protected processListEntries(response: Response): Promise<EntryCollectionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntryCollectionResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EntryCollectionResponse>(null as any);
    }

    /**
     * - Create a new child entry in the designated folder.
    - Provide the parent folder ID, and based on the request body, create a folder/shortcut as a child entry of the designated folder.
    - Required OAuth scope: repository.Write
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The folder ID that the entry will be created in.
     * @param args.request The entry to create.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag.
     * @return The created entry.
     */
    createEntry(args: { repositoryId: string, entryId: number, request: CreateEntryRequest, culture?: string | null | undefined }): Promise<Entry> {
        let { repositoryId, entryId, request, culture } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/Entries/{entryId}/Folder/Children?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateEntry(_response);
        });
    }

    protected processCreateEntry(response: Response): Promise<Entry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Entry.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Entry name conflicts.", status, _responseText, _headers, result409);
            });
        } else if (status === 413) {
            return response.text().then((_responseText) => {
            let result413: any = null;
            let resultData413 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result413 = ProblemDetails.fromJS(resultData413);
            return throwException("Request is too large.", status, _responseText, _headers, result413);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry>(null as any);
    }

    /**
     * - Returns the fields assigned to an entry.
    - Provide an entry ID, and get a paged listing of all fields assigned to that entry.
    - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The requested entry ID.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.formatFieldValues (optional) An optional query parameter used to indicate if the field values should be formatted. The default value is false.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise culture will not be used for formatting.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return A collection of fields set on the entry.
     */
    listFields(args: { repositoryId: string, entryId: number, prefer?: string | null | undefined, formatFieldValues?: boolean | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<FieldCollectionResponse> {
        let { repositoryId, entryId, prefer, formatFieldValues, culture, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/Entries/{entryId}/Fields?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (formatFieldValues === null)
            throw new Error("The parameter 'formatFieldValues' cannot be null.");
        else if (formatFieldValues !== undefined)
            url_ += "formatFieldValues=" + encodeURIComponent("" + formatFieldValues) + "&";
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        if (prefer !== null && prefer !== undefined)
            options_.headers = Object.assign({}, options_.headers, {"Prefer": prefer !== undefined && prefer !== null ? "" + prefer : null});

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListFields(_response);
        });
    }

    protected processListFields(response: Response): Promise<FieldCollectionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FieldCollectionResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FieldCollectionResponse>(null as any);
    }

    /**
     * - Update the field values assigned to an entry.
    - Provide the new field values to assign to the entry, and remove/reset all previously assigned field values.
    - This is an overwrite action. The request body must include all desired field values, including any existing field values that should remain assigned to the entry. Field values that are not included in the request will be deleted from the entry. If the field value that is not included is part of a template, it will still be assigned (as required by the template), but its value will be reset.
    - Required OAuth scope: repository.Write
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The entry ID of the entry that will have its fields updated.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag. This may be used when setting field values with tokens.
     * @return A collection of fields set on the entry.
     */
    setFields(args: { repositoryId: string, entryId: number, request: SetFieldsRequest, culture?: string | null | undefined }): Promise<FieldCollectionResponse> {
        let { repositoryId, entryId, request, culture } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/Entries/{entryId}/Fields?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetFields(_response);
        });
    }

    protected processSetFields(response: Response): Promise<FieldCollectionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FieldCollectionResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Requested entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 413) {
            return response.text().then((_responseText) => {
            let result413: any = null;
            let resultData413 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result413 = ProblemDetails.fromJS(resultData413);
            return throwException("Request is too large.", status, _responseText, _headers, result413);
            });
        } else if (status === 423) {
            return response.text().then((_responseText) => {
            let result423: any = null;
            let resultData423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result423 = ProblemDetails.fromJS(resultData423);
            return throwException("Entry is locked.", status, _responseText, _headers, result423);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FieldCollectionResponse>(null as any);
    }

    /**
     * - Returns the tags assigned to an entry.
    - Provide an entry ID, and get a paged listing of tags assigned to that entry.
    - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The requested entry ID.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return A collection of tags set on the entry.
     */
    listTags(args: { repositoryId: string, entryId: number, prefer?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<TagCollectionResponse> {
        let { repositoryId, entryId, prefer, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/Entries/{entryId}/Tags?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        if (prefer !== null && prefer !== undefined)
            options_.headers = Object.assign({}, options_.headers, {"Prefer": prefer !== undefined && prefer !== null ? "" + prefer : null});

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListTags(_response);
        });
    }

    protected processListTags(response: Response): Promise<TagCollectionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagCollectionResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TagCollectionResponse>(null as any);
    }

    /**
     * - Assign tags to an entry.
    - Provide an entry ID and a list of tags to assign to that entry.
    - This is an overwrite action. The request must include all tags to assign to the entry, including existing tags that should remain assigned to the entry.
    - Required OAuth scope: repository.Write
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The requested entry ID.
     * @param args.request The tags to add.
     * @return A collection of tags set on the entry.
     */
    setTags(args: { repositoryId: string, entryId: number, request: SetTagsRequest }): Promise<TagCollectionResponse> {
        let { repositoryId, entryId, request } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/Entries/{entryId}/Tags";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetTags(_response);
        });
    }

    protected processSetTags(response: Response): Promise<TagCollectionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagCollectionResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 413) {
            return response.text().then((_responseText) => {
            let result413: any = null;
            let resultData413 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result413 = ProblemDetails.fromJS(resultData413);
            return throwException("Request is too large.", status, _responseText, _headers, result413);
            });
        } else if (status === 423) {
            return response.text().then((_responseText) => {
            let result423: any = null;
            let resultData423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result423 = ProblemDetails.fromJS(resultData423);
            return throwException("Entry is locked.", status, _responseText, _headers, result423);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TagCollectionResponse>(null as any);
    }

    /**
     * - Assign links to an entry.
    - Provide an entry ID and a list of links to assign to that entry.
    - This is an overwrite action. The request must include all links to assign to the entry, including existing links that should remain assigned to the entry.
    - Required OAuth scope: repository.Write
     * @param args.repositoryId The request repository ID.
     * @param args.entryId The requested entry ID.
     * @return A collection of links set on the entry.
     */
    setLinks(args: { repositoryId: string, entryId: number, request: SetLinksRequest }): Promise<LinkCollectionResponse> {
        let { repositoryId, entryId, request } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/Entries/{entryId}/Links";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetLinks(_response);
        });
    }

    protected processSetLinks(response: Response): Promise<LinkCollectionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LinkCollectionResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 413) {
            return response.text().then((_responseText) => {
            let result413: any = null;
            let resultData413 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result413 = ProblemDetails.fromJS(resultData413);
            return throwException("Request is too large.", status, _responseText, _headers, result413);
            });
        } else if (status === 423) {
            return response.text().then((_responseText) => {
            let result423: any = null;
            let resultData423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result423 = ProblemDetails.fromJS(resultData423);
            return throwException("Entry is locked.", status, _responseText, _headers, result423);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LinkCollectionResponse>(null as any);
    }

    /**
     * - Returns the links assigned to an entry.
    - Provide an entry ID, and get a paged listing of links assigned to that entry.
    - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The requested entry ID.
     * @param args.prefer (optional) An optional odata header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return A collection of links set on the entry.
     */
    listLinks(args: { repositoryId: string, entryId: number, prefer?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<LinkCollectionResponse> {
        let { repositoryId, entryId, prefer, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/Entries/{entryId}/Links?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        if (prefer !== null && prefer !== undefined)
            options_.headers = Object.assign({}, options_.headers, {"Prefer": prefer !== undefined && prefer !== null ? "" + prefer : null});

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListLinks(_response);
        });
    }

    protected processListLinks(response: Response): Promise<LinkCollectionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LinkCollectionResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LinkCollectionResponse>(null as any);
    }

    /**
     * - Copy a new child entry in the designated folder.
    - Provide the parent folder ID, and based on the request body, copy a child entry of the designated folder.
    - Required OAuth scope: repository.Write
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The folder ID that the entry will be created in.
     * @param args.request The entry to create.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag.
     * @return The copied entry.
     */
    copyEntry(args: { repositoryId: string, entryId: number, request: CopyEntryRequest, culture?: string | null | undefined }): Promise<Entry> {
        let { repositoryId, entryId, request, culture } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/Entries/{entryId}/Folder/Copy?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCopyEntry(_response);
        });
    }

    protected processCopyEntry(response: Response): Promise<Entry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Entry.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry ID not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Entry name conflicts.", status, _responseText, _headers, result409);
            });
        } else if (status === 413) {
            return response.text().then((_responseText) => {
            let result413: any = null;
            let resultData413 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result413 = ProblemDetails.fromJS(resultData413);
            return throwException("Request is too large.", status, _responseText, _headers, result413);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry>(null as any);
    }

    /**
     * - Delete the edoc associated with the provided entry ID.
    - Required OAuth scope: repository.Write
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The requested document ID.
     * @return The updated entry.
     */
    deleteElectronicDocument(args: { repositoryId: string, entryId: number }): Promise<Entry> {
        let { repositoryId, entryId } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/Entries/{entryId}/Document/Edoc";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteElectronicDocument(_response);
        });
    }

    protected processDeleteElectronicDocument(response: Response): Promise<Entry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Entry.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 423) {
            return response.text().then((_responseText) => {
            let result423: any = null;
            let resultData423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result423 = ProblemDetails.fromJS(resultData423);
            return throwException("Entry is locked.", status, _responseText, _headers, result423);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry>(null as any);
    }

    /**
     * - Delete the pages associated with the provided entry ID. If no pageRange is specified, all pages will be deleted.
    - Optional parameter: pageRange (default empty). The value should be a comma-seperated string which contains non-overlapping single values, or page ranges. Ex: "1,2,3", "1-3,5", "2-7,10-12."
    - Required OAuth scope: repository.Write
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The requested document ID.
     * @param args.pageRange (optional) The pages to be deleted.
     * @return The updated entry.
     */
    deletePages(args: { repositoryId: string, entryId: number, pageRange?: string | null | undefined }): Promise<Entry> {
        let { repositoryId, entryId, pageRange } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/Entries/{entryId}/Document/Pages?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (pageRange !== undefined && pageRange !== null)
            url_ += "pageRange=" + encodeURIComponent("" + pageRange) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeletePages(_response);
        });
    }

    protected processDeletePages(response: Response): Promise<Entry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Entry.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 423) {
            return response.text().then((_responseText) => {
            let result423: any = null;
            let resultData423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result423 = ProblemDetails.fromJS(resultData423);
            return throwException("Entry is locked.", status, _responseText, _headers, result423);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry>(null as any);
    }

    /**
     * - Returns dynamic field logic values with the current values of the fields in the template.
    - Provide an entry ID and field values in the JSON body to get dynamic field logic values.
    - Independent and non-dynamic fields in the request body will be ignored, and only related dynamic field logic values for the assigned template will be returned.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The requested entry ID.
     * @return A collection of dynamic field values.
     */
    listDynamicFieldValues(args: { repositoryId: string, entryId: number, request: ListDynamicFieldValuesRequest }): Promise<{ [key: string]: string[]; }> {
        let { repositoryId, entryId, request } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/Entries/{entryId}/Fields/GetDynamicFieldLogicValue";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListDynamicFieldValues(_response);
        });
    }

    protected processListDynamicFieldValues(response: Response): Promise<{ [key: string]: string[]; }> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : [];
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 413) {
            return response.text().then((_responseText) => {
            let result413: any = null;
            let resultData413 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result413 = ProblemDetails.fromJS(resultData413);
            return throwException("Request is too large.", status, _responseText, _headers, result413);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: string[]; }>(null as any);
    }

    /**
     * - Remove the currently assigned template from the specified entry.
    - Provide an entry ID to clear template value on.
    - If the entry does not have a template assigned, no change will be made.
    - Required OAuth scope: repository.Write
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The ID of the entry that will have its template removed.
     * @return The updated entry.
     */
    removeTemplate(args: { repositoryId: string, entryId: number }): Promise<Entry> {
        let { repositoryId, entryId } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/Entries/{entryId}/Template";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveTemplate(_response);
        });
    }

    protected processRemoveTemplate(response: Response): Promise<Entry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Entry.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 423) {
            return response.text().then((_responseText) => {
            let result423: any = null;
            let resultData423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result423 = ProblemDetails.fromJS(resultData423);
            return throwException("Entry is locked.", status, _responseText, _headers, result423);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry>(null as any);
    }

    /**
     * - Assign a template to an entry.
    - Provide an entry ID, template name, and a list of template fields to assign to that entry.
    - Only template values will be modified. Any existing independent fields on the entry will not be modified, nor will they be added if included in the request. The only modification to fields will only occur on templated fields. If the previously assigned template includes common template fields as the newly assigned template, the common field values will not be modified.
    - Required OAuth scope: repository.Write
     * @param args.repositoryId The requested repository ID.
     * @param args.entryId The ID of entry that will have its template updated.
     * @param args.request The template and template fields that will be assigned to the entry.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag. This may be used when setting field values with tokens.
     * @return The updated entry.
     */
    setTemplate(args: { repositoryId: string, entryId: number, request: SetTemplateRequest, culture?: string | null | undefined }): Promise<Entry> {
        let { repositoryId, entryId, request, culture } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/Entries/{entryId}/Template?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetTemplate(_response);
        });
    }

    protected processSetTemplate(response: Response): Promise<Entry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Entry.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 413) {
            return response.text().then((_responseText) => {
            let result413: any = null;
            let resultData413 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result413 = ProblemDetails.fromJS(resultData413);
            return throwException("Request is too large.", status, _responseText, _headers, result413);
            });
        } else if (status === 423) {
            return response.text().then((_responseText) => {
            let result423: any = null;
            let resultData423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result423 = ProblemDetails.fromJS(resultData423);
            return throwException("Entry is locked.", status, _responseText, _headers, result423);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry>(null as any);
    }
}

export interface IRepositoriesClient {

    /**
     * - Returns the repository resource list that current user has access to.
    - Required OAuth scope: repository.Read
     * @return A collection of respositories.
     */
    listRepositories(args: {  }): Promise<RepositoryCollectionResponse>;
}

export class RepositoriesClient implements IRepositoriesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.laserfiche.com/repository";
    }

    
  /**
   * Returns the repository resource list that current user has access to given the API server base URL. Only available in Laserfiche Self-Hosted.
   * @param args.baseUrl API server base URL e.g., https://{APIServerName}/LFRepositoryAPI
   * @returns Get the repository resource list successfully.
   */
  public static async getSelfHostedRepositoryList(args: { baseUrl: string }): Promise<RepositoryCollectionResponse> {
    let { baseUrl } = args;
    const baseUrlWithoutSlash: string = StringUtils.trimEnd(baseUrl, '/');
    let http = {
      fetch,
    };
    return await new RepositoriesClient(baseUrlWithoutSlash, http).listRepositories({});
  }

    /**
     * - Returns the repository resource list that current user has access to.
    - Required OAuth scope: repository.Read
     * @return A collection of respositories.
     */
    listRepositories(args: {  }): Promise<RepositoryCollectionResponse> {
        let {  } = args;
        let url_ = this.baseUrl + "/v2/Repositories";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListRepositories(_response);
        });
    }

    protected processListRepositories(response: Response): Promise<RepositoryCollectionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RepositoryCollectionResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RepositoryCollectionResponse>(null as any);
    }
}

export interface ISearchesClient {

    /**
     * - Runs a search operation on the repository.
    - The status for search operations must be checked via the Tasks route.
    - Optional body parameters: FuzzyType: (default none), which can be used to determine what is considered a match by number of letters or percentage. FuzzyFactor: integer value that determines the degree to which a search will be considered a match (integer value for NumberOfLetters, or int value representing a percentage).
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.request The Laserfiche search command to run, optionally include fuzzy search settings.
     * @return A long operation task id.
     */
    startSearchEntry(args: { repositoryId: string, request: StartSearchEntryRequest }): Promise<StartTaskResponse>;

    /**
     * - Returns a search result listing if the search is completed.
    - Search results expire after 5 minutes, but can be refreshed by retrieving the results again.
    - Optional query parameter: groupByOrderType (default false). This query parameter decides whether or not results are returned in groups based on their entry type.
    - Optional query parameter: refresh (default false). If the search listing should be refreshed to show updated values.
    - Optionally returns field values for the entries in the folder. Each field name needs to be specified in the request. Maximum limit of 10 field names. If field values are requested, only the first value is returned if it is a multi value field. The remaining field values can be retrieved via the GET fields route. Null or Empty field values should not be used to determine if a field is assigned to the entry.
    - Default page size: 150. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer. OData $OrderBy syntax should follow: "PropertyName direction,PropertyName2 direction". sort order can be either "asc" or "desc".
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.taskId The requested task ID.
     * @param args.groupByEntryType (optional) An optional query parameter used to indicate if the result should be grouped by entry type or not.
     * @param args.refresh (optional) If the search listing should be refreshed to show updated values.
     * @param args.fields (optional) Optional array of field names. Field values corresponding to the given field names will be returned for each search result.
     * @param args.formatFieldValues (optional) Boolean for if field values should be formatted. Only applicable if Fields are specified.
     * @param args.prefer (optional) An optional odata header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise culture will not be used for formatting.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return A collection of entry search results.
     */
    listSearchResults(args: { repositoryId: string, taskId: string, groupByEntryType?: boolean | undefined, refresh?: boolean | undefined, fields?: string[] | null | undefined, formatFieldValues?: boolean | undefined, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<EntryCollectionResponse>;

    /**
     * - Returns the context hits associated with a search result entry.
    - Given a taskId, and rowNumber associated with a search entry in the listing, return the context hits for that entry.
    - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.taskId The requested task ID.
     * @param args.rowNumber The search result listing row number to get context hits for.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return A collection of context hits for a search result.
     */
    listSearchContextHits(args: { repositoryId: string, taskId: string, rowNumber: number, prefer?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<SearchContextHitCollectionResponse>;
}

export class SearchesClient implements ISearchesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.laserfiche.com/repository";
    }

    
  /**
   * It will continue to make the same call to get a list of search results of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repositoryId The requested repository ID.
   * @param args.searchToken The requested searchToken.
   * @param args.groupByEntryType (optional) An optional query parameter used to indicate if the result should be grouped by entry type or not.
   * @param args.refresh (optional) If the search listing should be refreshed to show updated values.
   * @param args.fields (optional) Optional array of field names. Field values corresponding to the given field names will be returned for each entry.
   * @param args.formatFieldValues (optional) Boolean for if field values should be formatted. Only applicable if Fields are specified.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
          The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise
          culture will not be used for formatting.  
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of search results allowed per API response schema.
   */
  async listSearchResultsForEach(args: {
    callback: (response: EntryCollectionResponse) => Promise<boolean>;
    repositoryId: string;
    searchToken: string;
    groupByEntryType?: boolean;
    refresh?: boolean;
    fields?: string[];
    formatFieldValues?: boolean;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let {
      callback,
      repositoryId,
      searchToken,
      groupByEntryType,
      refresh,
      fields,
      formatFieldValues,
      prefer,
      culture,
      select,
      orderby,
      top,
      skip,
      count,
      maxPageSize,
    } = args;
    var response = await this.listSearchResults({
      repositoryId: repositoryId,
      taskId: searchToken,
      groupByEntryType,
      refresh,
      fields,
      formatFieldValues,
      prefer: createMaxPageSizePreferHeaderPayload(maxPageSize),
      culture,
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink) {
      response = await getNextLinkListing<EntryCollectionResponse>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processListSearchResults,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }
  /**
   * It will continue to make the same call to get a list of search context hits of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repositoryId The requested repository ID.
   * @param args.searchToken The requested searchToken.
   * @param args.rowNumber The search result listing row number to get context hits for.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of search context hits allowed per API response schema.
   */
  async listSearchContextHitsForEach(args: {
    callback: (response: SearchContextHitCollectionResponse) => Promise<boolean>;
    repositoryId: string;
    searchToken: string;
    rowNumber: number;
    prefer?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let { callback, repositoryId, searchToken, rowNumber, prefer, select, orderby, top, skip, count, maxPageSize } = args;
    var response = await this.listSearchContextHits({
      repositoryId: repositoryId,
      taskId: searchToken,
      rowNumber,
      prefer: createMaxPageSizePreferHeaderPayload(maxPageSize),
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink) {
      response = await getNextLinkListing<SearchContextHitCollectionResponse>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processListSearchContextHits,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }
  /**
   * Returns a search result listing if the search is completed using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of search results allowed per API response schema
   * @return Get search result with the next link successfully
   */
  async listSearchResultsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<EntryCollectionResponse> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<EntryCollectionResponse>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processListSearchResults,
      nextLink,
      maxPageSize
    );
  }
  /**
   * Returns the context hits associated with a search result entry using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of search context hits allowed per API response schema
   * @return Get search context hits with the next link successfully
   */
  async listSearchContextHitsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<SearchContextHitCollectionResponse> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<SearchContextHitCollectionResponse>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processListSearchContextHits,
      nextLink,
      maxPageSize
    );
  }

    /**
     * - Runs a search operation on the repository.
    - The status for search operations must be checked via the Tasks route.
    - Optional body parameters: FuzzyType: (default none), which can be used to determine what is considered a match by number of letters or percentage. FuzzyFactor: integer value that determines the degree to which a search will be considered a match (integer value for NumberOfLetters, or int value representing a percentage).
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.request The Laserfiche search command to run, optionally include fuzzy search settings.
     * @return A long operation task id.
     */
    startSearchEntry(args: { repositoryId: string, request: StartSearchEntryRequest }): Promise<StartTaskResponse> {
        let { repositoryId, request } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/Searches/SearchAsync";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartSearchEntry(_response);
        });
    }

    protected processStartSearchEntry(response: Response): Promise<StartTaskResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 202) {
            return response.text().then((_responseText) => {
            let result202: any = null;
            let resultData202 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result202 = StartTaskResponse.fromJS(resultData202);
            return result202;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Requested repository not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 413) {
            return response.text().then((_responseText) => {
            let result413: any = null;
            let resultData413 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result413 = ProblemDetails.fromJS(resultData413);
            return throwException("Request is too large.", status, _responseText, _headers, result413);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Operation limit or request limit reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StartTaskResponse>(null as any);
    }

    /**
     * - Returns a search result listing if the search is completed.
    - Search results expire after 5 minutes, but can be refreshed by retrieving the results again.
    - Optional query parameter: groupByOrderType (default false). This query parameter decides whether or not results are returned in groups based on their entry type.
    - Optional query parameter: refresh (default false). If the search listing should be refreshed to show updated values.
    - Optionally returns field values for the entries in the folder. Each field name needs to be specified in the request. Maximum limit of 10 field names. If field values are requested, only the first value is returned if it is a multi value field. The remaining field values can be retrieved via the GET fields route. Null or Empty field values should not be used to determine if a field is assigned to the entry.
    - Default page size: 150. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer. OData $OrderBy syntax should follow: "PropertyName direction,PropertyName2 direction". sort order can be either "asc" or "desc".
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.taskId The requested task ID.
     * @param args.groupByEntryType (optional) An optional query parameter used to indicate if the result should be grouped by entry type or not.
     * @param args.refresh (optional) If the search listing should be refreshed to show updated values.
     * @param args.fields (optional) Optional array of field names. Field values corresponding to the given field names will be returned for each search result.
     * @param args.formatFieldValues (optional) Boolean for if field values should be formatted. Only applicable if Fields are specified.
     * @param args.prefer (optional) An optional odata header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise culture will not be used for formatting.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return A collection of entry search results.
     */
    listSearchResults(args: { repositoryId: string, taskId: string, groupByEntryType?: boolean | undefined, refresh?: boolean | undefined, fields?: string[] | null | undefined, formatFieldValues?: boolean | undefined, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<EntryCollectionResponse> {
        let { repositoryId, taskId, groupByEntryType, refresh, fields, formatFieldValues, prefer, culture, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/Searches/{taskId}/Results?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        if (groupByEntryType === null)
            throw new Error("The parameter 'groupByEntryType' cannot be null.");
        else if (groupByEntryType !== undefined)
            url_ += "groupByEntryType=" + encodeURIComponent("" + groupByEntryType) + "&";
        if (refresh === null)
            throw new Error("The parameter 'refresh' cannot be null.");
        else if (refresh !== undefined)
            url_ += "refresh=" + encodeURIComponent("" + refresh) + "&";
        if (fields !== undefined && fields !== null)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (formatFieldValues === null)
            throw new Error("The parameter 'formatFieldValues' cannot be null.");
        else if (formatFieldValues !== undefined)
            url_ += "formatFieldValues=" + encodeURIComponent("" + formatFieldValues) + "&";
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        if (prefer !== null && prefer !== undefined)
            options_.headers = Object.assign({}, options_.headers, {"Prefer": prefer !== undefined && prefer !== null ? "" + prefer : null});

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListSearchResults(_response);
        });
    }

    protected processListSearchResults(response: Response): Promise<EntryCollectionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntryCollectionResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request taskId not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EntryCollectionResponse>(null as any);
    }

    /**
     * - Returns the context hits associated with a search result entry.
    - Given a taskId, and rowNumber associated with a search entry in the listing, return the context hits for that entry.
    - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.taskId The requested task ID.
     * @param args.rowNumber The search result listing row number to get context hits for.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return A collection of context hits for a search result.
     */
    listSearchContextHits(args: { repositoryId: string, taskId: string, rowNumber: number, prefer?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<SearchContextHitCollectionResponse> {
        let { repositoryId, taskId, rowNumber, prefer, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/Searches/{taskId}/Results/{rowNumber}/ContextHits?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        if (rowNumber === undefined || rowNumber === null)
            throw new Error("The parameter 'rowNumber' must be defined.");
        url_ = url_.replace("{rowNumber}", encodeURIComponent("" + rowNumber));
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        if (prefer !== null && prefer !== undefined)
            options_.headers = Object.assign({}, options_.headers, {"Prefer": prefer !== undefined && prefer !== null ? "" + prefer : null});

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListSearchContextHits(_response);
        });
    }

    protected processListSearchContextHits(response: Response): Promise<SearchContextHitCollectionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchContextHitCollectionResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request taskId not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SearchContextHitCollectionResponse>(null as any);
    }
}

export interface ISimpleSearchesClient {

    /**
     * - Runs a "simple" search operation on the repository.
    - Returns a truncated search result listing.
    - Search result listing may be truncated, depending on number of results. Additionally, searches may time out if they take too long. Use the other search route to run full searches.
    - Optionally returns field values for the entries in the folder. Each field name needs to be specified in the request. Maximum limit of 10 field names. If field values are requested, only the first value is returned if it is a multi value field. The remaining field values can be retrieved via the GET fields route. Null or Empty field values should not be used to determine if a field is assigned to the entry.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.request The Laserfiche search command to run.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @param args.fields (optional) Optional array of field names. Field values corresponding to the given field names will be returned for each search result.
     * @param args.formatFieldValues (optional) Boolean for if field values should be formatted. Only applicable if Fields are specified.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise culture will not be used for formatting.
     * @return A collection of entry search results.
     */
    searchEntry(args: { repositoryId: string, request: SearchEntryRequest, select?: string | undefined, orderby?: string | undefined, count?: boolean | undefined, fields?: string[] | null | undefined, formatFieldValues?: boolean | undefined, culture?: string | null | undefined }): Promise<EntryCollectionResponse>;
}

export class SimpleSearchesClient implements ISimpleSearchesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.laserfiche.com/repository";
    }

    /**
     * - Runs a "simple" search operation on the repository.
    - Returns a truncated search result listing.
    - Search result listing may be truncated, depending on number of results. Additionally, searches may time out if they take too long. Use the other search route to run full searches.
    - Optionally returns field values for the entries in the folder. Each field name needs to be specified in the request. Maximum limit of 10 field names. If field values are requested, only the first value is returned if it is a multi value field. The remaining field values can be retrieved via the GET fields route. Null or Empty field values should not be used to determine if a field is assigned to the entry.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.request The Laserfiche search command to run.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @param args.fields (optional) Optional array of field names. Field values corresponding to the given field names will be returned for each search result.
     * @param args.formatFieldValues (optional) Boolean for if field values should be formatted. Only applicable if Fields are specified.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise culture will not be used for formatting.
     * @return A collection of entry search results.
     */
    searchEntry(args: { repositoryId: string, request: SearchEntryRequest, select?: string | undefined, orderby?: string | undefined, count?: boolean | undefined, fields?: string[] | null | undefined, formatFieldValues?: boolean | undefined, culture?: string | null | undefined }): Promise<EntryCollectionResponse> {
        let { repositoryId, request, select, orderby, count, fields, formatFieldValues, culture } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/SimpleSearches?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (select === null)
            throw new Error("The parameter 'select' cannot be null.");
        else if (select !== undefined)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby === null)
            throw new Error("The parameter 'orderby' cannot be null.");
        else if (orderby !== undefined)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        if (fields !== undefined && fields !== null)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (formatFieldValues === null)
            throw new Error("The parameter 'formatFieldValues' cannot be null.");
        else if (formatFieldValues !== undefined)
            url_ += "formatFieldValues=" + encodeURIComponent("" + formatFieldValues) + "&";
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchEntry(_response);
        });
    }

    protected processSearchEntry(response: Response): Promise<EntryCollectionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntryCollectionResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 206) {
            return response.text().then((_responseText) => {
            let result206: any = null;
            let resultData206 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result206 = EntryCollectionResponse.fromJS(resultData206);
            return result206;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 413) {
            return response.text().then((_responseText) => {
            let result413: any = null;
            let resultData413 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result413 = ProblemDetails.fromJS(resultData413);
            return throwException("Request is too large.", status, _responseText, _headers, result413);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Operation limit or request limit reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EntryCollectionResponse>(null as any);
    }
}

export interface ITagDefinitionsClient {

    /**
     * - Returns all tag definitions in the repository.
    - Provide a repository ID and get a paged listing of tag definitions available in the repository. Useful when trying to display all tag definitions available, not only tags assigned to a specific entry.
    - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return A collection of tag definitions.
     */
    listTagDefinitions(args: { repositoryId: string, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<TagDefinitionCollectionResponse>;

    /**
     * - Returns a single tag definition.
    - Provide a tag definition ID, and get the single tag definition associated with that ID. Useful when another route provides a minimal amount of details, and more information about the specific tag is needed.
    - Allowed OData query options: Select
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.tagId The requested tag definition ID.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.
     * @param args.select (optional) Limits the properties returned in the result.
     * @return A single tag definition.
     */
    getTagDefinition(args: { repositoryId: string, tagId: number, culture?: string | null | undefined, select?: string | null | undefined }): Promise<TagDefinition>;
}

export class TagDefinitionsClient implements ITagDefinitionsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.laserfiche.com/repository";
    }

    
  /**
   * It will continue to make the same call to get a list of tag definitions of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repositoryId The requested repository ID.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
          The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise
          culture will not be used for formatting.  
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of tag definitions allowed per API response schema.
   */
  async listTagDefinitionsForEach(args: {
    callback: (response: TagDefinitionCollectionResponse) => Promise<boolean>;
    repositoryId: string;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let { callback, repositoryId, prefer, culture, select, orderby, top, skip, count, maxPageSize } = args;
    var response = await this.listTagDefinitions({
      repositoryId: repositoryId,
      prefer: createMaxPageSizePreferHeaderPayload(maxPageSize),
      culture,
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink) {
      response = await getNextLinkListing<TagDefinitionCollectionResponse>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processListTagDefinitions,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }
  /**
   * Returns all tag definitions in the repository using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of tag definitions allowed per API response schema
   * @return Get tag definitions with the next link successfully
   */
  async listTagDefinitionsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<TagDefinitionCollectionResponse> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<TagDefinitionCollectionResponse>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processListTagDefinitions,
      nextLink,
      maxPageSize
    );
  }

    /**
     * - Returns all tag definitions in the repository.
    - Provide a repository ID and get a paged listing of tag definitions available in the repository. Useful when trying to display all tag definitions available, not only tags assigned to a specific entry.
    - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return A collection of tag definitions.
     */
    listTagDefinitions(args: { repositoryId: string, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<TagDefinitionCollectionResponse> {
        let { repositoryId, prefer, culture, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/TagDefinitions?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        if (prefer !== null && prefer !== undefined)
            options_.headers = Object.assign({}, options_.headers, {"Prefer": prefer !== undefined && prefer !== null ? "" + prefer : null});

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListTagDefinitions(_response);
        });
    }

    protected processListTagDefinitions(response: Response): Promise<TagDefinitionCollectionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagDefinitionCollectionResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TagDefinitionCollectionResponse>(null as any);
    }

    /**
     * - Returns a single tag definition.
    - Provide a tag definition ID, and get the single tag definition associated with that ID. Useful when another route provides a minimal amount of details, and more information about the specific tag is needed.
    - Allowed OData query options: Select
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.tagId The requested tag definition ID.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.
     * @param args.select (optional) Limits the properties returned in the result.
     * @return A single tag definition.
     */
    getTagDefinition(args: { repositoryId: string, tagId: number, culture?: string | null | undefined, select?: string | null | undefined }): Promise<TagDefinition> {
        let { repositoryId, tagId, culture, select } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/TagDefinitions/{tagId}?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (tagId === undefined || tagId === null)
            throw new Error("The parameter 'tagId' must be defined.");
        url_ = url_.replace("{tagId}", encodeURIComponent("" + tagId));
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTagDefinition(_response);
        });
    }

    protected processGetTagDefinition(response: Response): Promise<TagDefinition> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TagDefinition.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request tag definition id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TagDefinition>(null as any);
    }
}

export interface ITasksClient {

    /**
     * - Returns the status of a set of one or more tasks.
    - Provide a comma-separated list of task IDs to get the task status, progress, and any errors that may have occurred.
    - Leave the taskIds query parameter empty, to get the list of all the task IDs associated with the current access token.
    - TaskStatus can be one of the following values: NotStarted, InProgress, Completed, or Failed.
    - This API employs long polling technique and could return the result immediately (e.g. if the export operation is failed or completed successfully) or after atmost 60 seconds.
    - Required OAuth scope: None
     * @param args.repositoryId The requested repository ID
     * @param args.taskIds (optional) An array of task IDs (string). Leave this parameter empty to get the list of all the task IDs associated with the current access token.
     * @return A collection of task progresses.
     */
    listTasks(args: { repositoryId: string, taskIds?: string[] | null | undefined }): Promise<TaskCollectionResponse>;

    /**
     * - Cancels a set of one or more tasks.
    - Provide comma-separated list of task IDs to cancel. Should be used if an operation was created in error, or is no longer necessary.
    - Leave the taskIds query parameter empty, to cancel the list of all the task IDs associated with the current access token.
    - Rollbacks must be done manually. For example, if a copy operation is started and is halfway complete when canceled, the client application is responsible for cleaning up the files that were successfully copied before the operation was canceled.
    - Required OAuth scope: None
     * @param args.repositoryId The requested repository ID
     * @param args.taskIds (optional) An array of task IDs (string). Leave this parameter empty to cancel the list of all the task IDs associated with the current access token.
     * @return A collection of task cancellation results.
     */
    cancelTasks(args: { repositoryId: string, taskIds?: string[] | null | undefined }): Promise<CancelTasksResponse>;
}

export class TasksClient implements ITasksClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.laserfiche.com/repository";
    }

    /**
     * - Returns the status of a set of one or more tasks.
    - Provide a comma-separated list of task IDs to get the task status, progress, and any errors that may have occurred.
    - Leave the taskIds query parameter empty, to get the list of all the task IDs associated with the current access token.
    - TaskStatus can be one of the following values: NotStarted, InProgress, Completed, or Failed.
    - This API employs long polling technique and could return the result immediately (e.g. if the export operation is failed or completed successfully) or after atmost 60 seconds.
    - Required OAuth scope: None
     * @param args.repositoryId The requested repository ID
     * @param args.taskIds (optional) An array of task IDs (string). Leave this parameter empty to get the list of all the task IDs associated with the current access token.
     * @return A collection of task progresses.
     */
    listTasks(args: { repositoryId: string, taskIds?: string[] | null | undefined }): Promise<TaskCollectionResponse> {
        let { repositoryId, taskIds } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/Tasks?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (taskIds !== undefined && taskIds !== null)
            taskIds && taskIds.forEach(item => { url_ += "taskIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListTasks(_response);
        });
    }

    protected processListTasks(response: Response): Promise<TaskCollectionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TaskCollectionResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Repository is not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskCollectionResponse>(null as any);
    }

    /**
     * - Cancels a set of one or more tasks.
    - Provide comma-separated list of task IDs to cancel. Should be used if an operation was created in error, or is no longer necessary.
    - Leave the taskIds query parameter empty, to cancel the list of all the task IDs associated with the current access token.
    - Rollbacks must be done manually. For example, if a copy operation is started and is halfway complete when canceled, the client application is responsible for cleaning up the files that were successfully copied before the operation was canceled.
    - Required OAuth scope: None
     * @param args.repositoryId The requested repository ID
     * @param args.taskIds (optional) An array of task IDs (string). Leave this parameter empty to cancel the list of all the task IDs associated with the current access token.
     * @return A collection of task cancellation results.
     */
    cancelTasks(args: { repositoryId: string, taskIds?: string[] | null | undefined }): Promise<CancelTasksResponse> {
        let { repositoryId, taskIds } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/Tasks?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (taskIds !== undefined && taskIds !== null)
            taskIds && taskIds.forEach(item => { url_ += "taskIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCancelTasks(_response);
        });
    }

    protected processCancelTasks(response: Response): Promise<CancelTasksResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CancelTasksResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Repository is not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CancelTasksResponse>(null as any);
    }
}

export interface ITemplateDefinitionsClient {

    /**
     * - Returns all template definitions (including field definitions) in the repository. If a template name query parameter is given, then a single template definition is returned.
    - Provide a repository ID, and get a paged listing of template definitions available in the repository. Useful when trying to find a list of all template definitions available, rather than a specific one.
    - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.templateName (optional) An optional query parameter. Can be used to get a single template definition using the template name.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return A collection of template definitions.
     */
    listTemplateDefinitions(args: { repositoryId: string, templateName?: string | null | undefined, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<TemplateDefinitionCollectionResponse>;

    /**
     * - Returns a single template definition (including field definitions, if relevant).
    - Provide a template definition ID, and get the single template definition associated with that ID. Useful when a route provides a minimal amount of details, and more information about the specific template is needed.
    - Allowed OData query options: Select
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.templateId The requested template definition ID.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.
     * @param args.select (optional) Limits the properties returned in the result.
     * @return A single template definition.
     */
    getTemplateDefinition(args: { repositoryId: string, templateId: number, culture?: string | null | undefined, select?: string | null | undefined }): Promise<TemplateDefinition>;

    /**
     * - Returns the field definitions assigned to a template definition.
    - Provide a template definition ID, and get a paged listing of the field definitions assigned to that template. 
    - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.templateId The requested template definition ID.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return A collection of template field definitions.
     */
    listTemplateFieldDefinitionsByTemplateId(args: { repositoryId: string, templateId: number, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<TemplateFieldDefinitionCollectionResponse>;

    /**
     * - Returns the field definitions assigned to a template definition.
    - Provide a template definition name, and get a paged listing of the field definitions assigned to that template. 
    - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.templateName A required query parameter for the requested template name.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return A collection of template field definitions.
     */
    listTemplateFieldDefinitionsByTemplateName(args: { repositoryId: string, templateName: string, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<TemplateFieldDefinitionCollectionResponse>;
}

export class TemplateDefinitionsClient implements ITemplateDefinitionsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.laserfiche.com/repository";
    }

    
  /**
   * Given a maximum page size, it will continue to make the same call to get a list of template definitions of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repositoryId The requested repository ID.
   * @param args.templateName (optional) An optional query parameter. Can be used to get a single template definition using the template name.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
          The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise
          culture will not be used for formatting.  
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of template definitions allowed per API response schema.
   */
  async listTemplateDefinitionsForEach(args: {
    callback: (response: TemplateDefinitionCollectionResponse) => Promise<boolean>;
    repositoryId: string;
    templateName?: string;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let { callback, repositoryId, templateName, prefer, culture, select, orderby, top, skip, count, maxPageSize } = args;
    var response = await this.listTemplateDefinitions({
      repositoryId: repositoryId,
      templateName,
      prefer: createMaxPageSizePreferHeaderPayload(maxPageSize),
      culture,
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink) {
      response = await getNextLinkListing<TemplateDefinitionCollectionResponse>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processListTemplateDefinitions,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }
  /**
   * It will continue to make the same call to get a list of template field definitions of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repositoryId The requested repository ID.
   * @param args.templateName (optional) An optional query parameter. Can be used to get a single template definition using the template name.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
          The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise
          culture will not be used for formatting.  
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of template field definitions allowed per API response schema.
   */
  async listTemplateFieldDefinitionsByTemplateIdForEach(args: {
    callback: (response: TemplateFieldDefinitionCollectionResponse) => Promise<boolean>;
    repositoryId: string;
    templateId: number;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let { callback, repositoryId, templateId, prefer, culture, select, orderby, top, skip, count, maxPageSize } = args;
    var response = await this.listTemplateFieldDefinitionsByTemplateId({
      repositoryId: repositoryId,
      templateId,
      prefer: createMaxPageSizePreferHeaderPayload(maxPageSize),
      culture,
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink) {
      response = await getNextLinkListing<TemplateFieldDefinitionCollectionResponse>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processListTemplateFieldDefinitionsByTemplateId,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }
  /**
   * It will continue to make the same call to get a list of template field definitions by template name of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repositoryId The requested repository ID.
   * @param args.templateName (optional) An optional query parameter. Can be used to get a single template definition using the template name.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
          The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise
          culture will not be used for formatting.  
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of template field definitions by template name allowed per API response schema.
   */
  async listTemplateFieldDefinitionsByTemplateNameForEach(args: {
    callback: (response: TemplateFieldDefinitionCollectionResponse) => Promise<boolean>;
    repositoryId: string;
    templateName: string;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let { callback, repositoryId, templateName, prefer, culture, select, orderby, top, skip, count, maxPageSize } = args;
    var response = await this.listTemplateFieldDefinitionsByTemplateName({
      repositoryId: repositoryId,
      templateName,
      prefer: createMaxPageSizePreferHeaderPayload(maxPageSize),
      culture,
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink) {
      response = await getNextLinkListing<TemplateFieldDefinitionCollectionResponse>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processListTemplateFieldDefinitionsByTemplateName,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }
  /**
   * Returns all template definitions (including field definitions) in the repository using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of template definitions allowed per API response schema
   * @return Get template definitions with the next link successfully
   */
  async listTemplateDefinitionsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<TemplateDefinitionCollectionResponse> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<TemplateDefinitionCollectionResponse>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processListTemplateDefinitions,
      nextLink,
      maxPageSize
    );
  }
  /**
   * Returns the field definitions assigned to a template definition using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of template field definitions allowed per API response schema
   * @return Get field definitions with the next link successfully
   */
  async listTemplateFieldDefinitionsByTemplateIdNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<TemplateFieldDefinitionCollectionResponse> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<TemplateFieldDefinitionCollectionResponse>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processListTemplateFieldDefinitionsByTemplateId,
      nextLink,
      maxPageSize
    );
  }
  /**
   * Returns the field definitions assigned to a template definition by template name using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of template field definitions by template name allowed per API response schema
   * @return Get field definitions by template name with the next link successfully
   */
  async listTemplateFieldDefinitionsByTemplateNameNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<TemplateFieldDefinitionCollectionResponse> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<TemplateFieldDefinitionCollectionResponse>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processListTemplateFieldDefinitionsByTemplateName,
      nextLink,
      maxPageSize
    );
  }

    /**
     * - Returns all template definitions (including field definitions) in the repository. If a template name query parameter is given, then a single template definition is returned.
    - Provide a repository ID, and get a paged listing of template definitions available in the repository. Useful when trying to find a list of all template definitions available, rather than a specific one.
    - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.templateName (optional) An optional query parameter. Can be used to get a single template definition using the template name.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return A collection of template definitions.
     */
    listTemplateDefinitions(args: { repositoryId: string, templateName?: string | null | undefined, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<TemplateDefinitionCollectionResponse> {
        let { repositoryId, templateName, prefer, culture, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/TemplateDefinitions?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (templateName !== undefined && templateName !== null)
            url_ += "templateName=" + encodeURIComponent("" + templateName) + "&";
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        if (prefer !== null && prefer !== undefined)
            options_.headers = Object.assign({}, options_.headers, {"Prefer": prefer !== undefined && prefer !== null ? "" + prefer : null});

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListTemplateDefinitions(_response);
        });
    }

    protected processListTemplateDefinitions(response: Response): Promise<TemplateDefinitionCollectionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TemplateDefinitionCollectionResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request template name not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TemplateDefinitionCollectionResponse>(null as any);
    }

    /**
     * - Returns a single template definition (including field definitions, if relevant).
    - Provide a template definition ID, and get the single template definition associated with that ID. Useful when a route provides a minimal amount of details, and more information about the specific template is needed.
    - Allowed OData query options: Select
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.templateId The requested template definition ID.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.
     * @param args.select (optional) Limits the properties returned in the result.
     * @return A single template definition.
     */
    getTemplateDefinition(args: { repositoryId: string, templateId: number, culture?: string | null | undefined, select?: string | null | undefined }): Promise<TemplateDefinition> {
        let { repositoryId, templateId, culture, select } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/TemplateDefinitions/{templateId}?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (templateId === undefined || templateId === null)
            throw new Error("The parameter 'templateId' must be defined.");
        url_ = url_.replace("{templateId}", encodeURIComponent("" + templateId));
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTemplateDefinition(_response);
        });
    }

    protected processGetTemplateDefinition(response: Response): Promise<TemplateDefinition> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TemplateDefinition.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request template id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TemplateDefinition>(null as any);
    }

    /**
     * - Returns the field definitions assigned to a template definition.
    - Provide a template definition ID, and get a paged listing of the field definitions assigned to that template. 
    - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.templateId The requested template definition ID.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return A collection of template field definitions.
     */
    listTemplateFieldDefinitionsByTemplateId(args: { repositoryId: string, templateId: number, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<TemplateFieldDefinitionCollectionResponse> {
        let { repositoryId, templateId, prefer, culture, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/TemplateDefinitions/{templateId}/FieldDefinitions?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (templateId === undefined || templateId === null)
            throw new Error("The parameter 'templateId' must be defined.");
        url_ = url_.replace("{templateId}", encodeURIComponent("" + templateId));
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        if (prefer !== null && prefer !== undefined)
            options_.headers = Object.assign({}, options_.headers, {"Prefer": prefer !== undefined && prefer !== null ? "" + prefer : null});

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListTemplateFieldDefinitionsByTemplateId(_response);
        });
    }

    protected processListTemplateFieldDefinitionsByTemplateId(response: Response): Promise<TemplateFieldDefinitionCollectionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TemplateFieldDefinitionCollectionResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request template id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TemplateFieldDefinitionCollectionResponse>(null as any);
    }

    /**
     * - Returns the field definitions assigned to a template definition.
    - Provide a template definition name, and get a paged listing of the field definitions assigned to that template. 
    - Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
    - Required OAuth scope: repository.Read
     * @param args.repositoryId The requested repository ID.
     * @param args.templateName A required query parameter for the requested template name.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting. The value should be a standard language tag.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return A collection of template field definitions.
     */
    listTemplateFieldDefinitionsByTemplateName(args: { repositoryId: string, templateName: string, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<TemplateFieldDefinitionCollectionResponse> {
        let { repositoryId, templateName, prefer, culture, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v2/Repositories/{repositoryId}/TemplateDefinitions/FieldDefinitions?";
        if (repositoryId === undefined || repositoryId === null)
            throw new Error("The parameter 'repositoryId' must be defined.");
        url_ = url_.replace("{repositoryId}", encodeURIComponent("" + repositoryId));
        if (templateName === undefined || templateName === null)
            throw new Error("The parameter 'templateName' must be defined and cannot be null.");
        else
            url_ += "templateName=" + encodeURIComponent("" + templateName) + "&";
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        if (prefer !== null && prefer !== undefined)
            options_.headers = Object.assign({}, options_.headers, {"Prefer": prefer !== undefined && prefer !== null ? "" + prefer : null});

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListTemplateFieldDefinitionsByTemplateName(_response);
        });
    }

    protected processListTemplateFieldDefinitionsByTemplateName(response: Response): Promise<TemplateFieldDefinitionCollectionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TemplateFieldDefinitionCollectionResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request template name not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TemplateFieldDefinitionCollectionResponse>(null as any);
    }
}

/** Response containing a collection of Attribute. */
export class AttributeCollectionResponse implements IAttributeCollectionResponse {
    /** A URL to retrieve the next page of the requested collection. */
    odataNextLink?: string | undefined;
    /** The total count of items within a collection. */
    odataCount?: number | undefined;
    value?: Attribute[];

    
    
    constructor(data?: IAttributeCollectionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.odataNextLink = _data["@odata.nextLink"];
            this.odataCount = _data["@odata.count"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(Attribute.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AttributeCollectionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AttributeCollectionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["@odata.nextLink"] = this.odataNextLink;
        data["@odata.count"] = this.odataCount;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

/** Response containing a collection of Attribute. */
export interface IAttributeCollectionResponse {
    /** A URL to retrieve the next page of the requested collection. */
    odataNextLink?: string | undefined;
    /** The total count of items within a collection. */
    odataCount?: number | undefined;
    value?: Attribute[];
}

/** Represents a trustee attribute. */
export class Attribute implements IAttribute {
    key?: string | undefined;
    value?: string | undefined;

    
    
    constructor(data?: IAttribute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Attribute {
        data = typeof data === 'object' ? data : {};
        let result = new Attribute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

/** Represents a trustee attribute. */
export interface IAttribute {
    key?: string | undefined;
    value?: string | undefined;
}

/** A machine-readable format for specifying errors in HTTP API responses based on https://tools.ietf.org/html/rfc7807. */
export class ProblemDetails implements IProblemDetails {
    /** The problem type. */
    type?: string | undefined;
    /** A short, human-readable summary of the problem type. */
    title?: string | undefined;
    /** The HTTP status code. */
    status!: number;
    /** A human-readable explanation specific to this occurrence of the problem. */
    detail?: string | undefined;
    /** A URI reference that identifies the specific occurrence of the problem. */
    instance?: string | undefined;
    /** The operation id. */
    operationId?: string | undefined;
    /** The error source. */
    errorSource?: string | undefined;
    /** The error code. */
    errorCode?: number | undefined;
    /** The trace id. */
    traceId?: string | undefined;
    /** The instance detail. */
    instanceDetail?: string | undefined;

    
    
    extensions: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            this.operationId = _data["operationId"];
            this.errorSource = _data["errorSource"];
            this.errorCode = _data["errorCode"];
            this.traceId = _data["traceId"];
            this.instanceDetail = _data["instanceDetail"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        data["operationId"] = this.operationId;
        data["errorSource"] = this.errorSource;
        data["errorCode"] = this.errorCode;
        data["traceId"] = this.traceId;
        data["instanceDetail"] = this.instanceDetail;
        return data;
    }
}

/** A machine-readable format for specifying errors in HTTP API responses based on https://tools.ietf.org/html/rfc7807. */
export interface IProblemDetails {
    /** The problem type. */
    type?: string | undefined;
    /** A short, human-readable summary of the problem type. */
    title?: string | undefined;
    /** The HTTP status code. */
    status: number;
    /** A human-readable explanation specific to this occurrence of the problem. */
    detail?: string | undefined;
    /** A URI reference that identifies the specific occurrence of the problem. */
    instance?: string | undefined;
    /** The operation id. */
    operationId?: string | undefined;
    /** The error source. */
    errorSource?: string | undefined;
    /** The error code. */
    errorCode?: number | undefined;
    /** The trace id. */
    traceId?: string | undefined;
    /** The instance detail. */
    instanceDetail?: string | undefined;
}

/** Response containing a collection of AuditReason. */
export class AuditReasonCollectionResponse implements IAuditReasonCollectionResponse {
    /** A URL to retrieve the next page of the requested collection. */
    odataNextLink?: string | undefined;
    /** The total count of items within a collection. */
    odataCount?: number | undefined;
    value?: AuditReason[];

    
    
    constructor(data?: IAuditReasonCollectionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.odataNextLink = _data["@odata.nextLink"];
            this.odataCount = _data["@odata.count"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(AuditReason.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AuditReasonCollectionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuditReasonCollectionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["@odata.nextLink"] = this.odataNextLink;
        data["@odata.count"] = this.odataCount;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

/** Response containing a collection of AuditReason. */
export interface IAuditReasonCollectionResponse {
    /** A URL to retrieve the next page of the requested collection. */
    odataNextLink?: string | undefined;
    /** The total count of items within a collection. */
    odataCount?: number | undefined;
    value?: AuditReason[];
}

/** Represents a user-defined audit reason for an audit event. */
export class AuditReason implements IAuditReason {
    /** The audit reason id. */
    id?: number;
    /** The audit reason text. */
    name?: string | undefined;
    /** The audit event type for this audit reason. */
    auditEventType?: AuditEventType;

    
    
    constructor(data?: IAuditReason) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.auditEventType = _data["auditEventType"];
        }
    }

    static fromJS(data: any): AuditReason {
        data = typeof data === 'object' ? data : {};
        let result = new AuditReason();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["auditEventType"] = this.auditEventType;
        return data;
    }
}

/** Represents a user-defined audit reason for an audit event. */
export interface IAuditReason {
    /** The audit reason id. */
    id?: number;
    /** The audit reason text. */
    name?: string | undefined;
    /** The audit event type for this audit reason. */
    auditEventType?: AuditEventType;
}

/** Enumeration of Laserfiche audit event types. */
export enum AuditEventType {
    DeleteEntry = "DeleteEntry",
    ExportDocument = "ExportDocument",
}

/** Represents a field definition. */
export class FieldDefinition implements IFieldDefinition {
    /** The name of the field. */
    name?: string | undefined;
    /** The localized name of the field. */
    displayName?: string | undefined;
    /** The ID of the field. */
    id?: number;
    /** The description of the field. */
    description?: string | undefined;
    /** The type of the field. */
    fieldType?: FieldType;
    /** The length of the field for variable length data types. */
    length?: number;
    /** The default value of the field for new entries that are assigned to a template the represented field is a member of. */
    defaultValue?: string | undefined;
    /** A boolean indicating if the represented template field supports multiple values. */
    isMultiValue?: boolean;
    /** A boolean indicating if the represented field must have a value set on entries assigned to a template that the field is a member of. */
    isRequired?: boolean;
    /** The constraint for values stored in the represented field. */
    constraint?: string | undefined;
    /** The error string that will be returned when the field constraint is violated when setting a value for this field. */
    constraintError?: string | undefined;
    /** The list of items assigned to the represented field. */
    listValues?: string[] | undefined;
    /** The display format of the represented field. */
    format?: FieldFormat;
    /** The name of the currency that will be using when formatting the represented field when the Format property is set to the Currency member of the WFieldFormat enumeration. */
    currency?: string | undefined;
    /** The custom format pattern for fields that are configured to use a custom format. */
    formatPattern?: string | undefined;

    
    
    constructor(data?: IFieldDefinition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.id = _data["id"];
            this.description = _data["description"];
            this.fieldType = _data["fieldType"];
            this.length = _data["length"];
            this.defaultValue = _data["defaultValue"];
            this.isMultiValue = _data["isMultiValue"];
            this.isRequired = _data["isRequired"];
            this.constraint = _data["constraint"];
            this.constraintError = _data["constraintError"];
            if (Array.isArray(_data["listValues"])) {
                this.listValues = [] as any;
                for (let item of _data["listValues"])
                    this.listValues!.push(item);
            }
            this.format = _data["format"];
            this.currency = _data["currency"];
            this.formatPattern = _data["formatPattern"];
        }
    }

    static fromJS(data: any): FieldDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new FieldDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["id"] = this.id;
        data["description"] = this.description;
        data["fieldType"] = this.fieldType;
        data["length"] = this.length;
        data["defaultValue"] = this.defaultValue;
        data["isMultiValue"] = this.isMultiValue;
        data["isRequired"] = this.isRequired;
        data["constraint"] = this.constraint;
        data["constraintError"] = this.constraintError;
        if (Array.isArray(this.listValues)) {
            data["listValues"] = [];
            for (let item of this.listValues)
                data["listValues"].push(item);
        }
        data["format"] = this.format;
        data["currency"] = this.currency;
        data["formatPattern"] = this.formatPattern;
        return data;
    }
}

/** Represents a field definition. */
export interface IFieldDefinition {
    /** The name of the field. */
    name?: string | undefined;
    /** The localized name of the field. */
    displayName?: string | undefined;
    /** The ID of the field. */
    id?: number;
    /** The description of the field. */
    description?: string | undefined;
    /** The type of the field. */
    fieldType?: FieldType;
    /** The length of the field for variable length data types. */
    length?: number;
    /** The default value of the field for new entries that are assigned to a template the represented field is a member of. */
    defaultValue?: string | undefined;
    /** A boolean indicating if the represented template field supports multiple values. */
    isMultiValue?: boolean;
    /** A boolean indicating if the represented field must have a value set on entries assigned to a template that the field is a member of. */
    isRequired?: boolean;
    /** The constraint for values stored in the represented field. */
    constraint?: string | undefined;
    /** The error string that will be returned when the field constraint is violated when setting a value for this field. */
    constraintError?: string | undefined;
    /** The list of items assigned to the represented field. */
    listValues?: string[] | undefined;
    /** The display format of the represented field. */
    format?: FieldFormat;
    /** The name of the currency that will be using when formatting the represented field when the Format property is set to the Currency member of the WFieldFormat enumeration. */
    currency?: string | undefined;
    /** The custom format pattern for fields that are configured to use a custom format. */
    formatPattern?: string | undefined;
}

/** Enumeration of Laserfiche template field types. */
export enum FieldType {
    DateTime = "DateTime",
    Blob = "Blob",
    Date = "Date",
    ShortInteger = "ShortInteger",
    LongInteger = "LongInteger",
    List = "List",
    Number = "Number",
    String = "String",
    Time = "Time",
}

/** Enumeration of Laserfiche template field formats. */
export enum FieldFormat {
    None = "None",
    ShortDate = "ShortDate",
    LongDate = "LongDate",
    ShortDateTime = "ShortDateTime",
    LongDateTime = "LongDateTime",
    ShortTime = "ShortTime",
    LongTime = "LongTime",
    GeneralNumber = "GeneralNumber",
    Currency = "Currency",
    Percent = "Percent",
    Scientific = "Scientific",
    Custom = "Custom",
}

/** Response containing a collection of FieldDefinition. */
export class FieldDefinitionCollectionResponse implements IFieldDefinitionCollectionResponse {
    /** A URL to retrieve the next page of the requested collection. */
    odataNextLink?: string | undefined;
    /** The total count of items within a collection. */
    odataCount?: number | undefined;
    value?: FieldDefinition[];

    
    
    constructor(data?: IFieldDefinitionCollectionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.odataNextLink = _data["@odata.nextLink"];
            this.odataCount = _data["@odata.count"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(FieldDefinition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FieldDefinitionCollectionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new FieldDefinitionCollectionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["@odata.nextLink"] = this.odataNextLink;
        data["@odata.count"] = this.odataCount;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

/** Response containing a collection of FieldDefinition. */
export interface IFieldDefinitionCollectionResponse {
    /** A URL to retrieve the next page of the requested collection. */
    odataNextLink?: string | undefined;
    /** The total count of items within a collection. */
    odataCount?: number | undefined;
    value?: FieldDefinition[];
}

/** Response containing a collection of LinkDefinition. */
export class LinkDefinitionCollectionResponse implements ILinkDefinitionCollectionResponse {
    /** A URL to retrieve the next page of the requested collection. */
    odataNextLink?: string | undefined;
    /** The total count of items within a collection. */
    odataCount?: number | undefined;
    value?: LinkDefinition[];

    
    
    constructor(data?: ILinkDefinitionCollectionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.odataNextLink = _data["@odata.nextLink"];
            this.odataCount = _data["@odata.count"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(LinkDefinition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LinkDefinitionCollectionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LinkDefinitionCollectionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["@odata.nextLink"] = this.odataNextLink;
        data["@odata.count"] = this.odataCount;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

/** Response containing a collection of LinkDefinition. */
export interface ILinkDefinitionCollectionResponse {
    /** A URL to retrieve the next page of the requested collection. */
    odataNextLink?: string | undefined;
    /** The total count of items within a collection. */
    odataCount?: number | undefined;
    value?: LinkDefinition[];
}

/** Represents an entry link definition. */
export class LinkDefinition implements ILinkDefinition {
    /** The ID of the link definition. */
    id?: number;
    /** The label for the source entry in the link definition. */
    sourceLabel?: string | undefined;
    /** The label for the target entry in the link definition. */
    targetLabel?: string | undefined;
    /** The description of the link definition. */
    description?: string | undefined;

    
    
    constructor(data?: ILinkDefinition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sourceLabel = _data["sourceLabel"];
            this.targetLabel = _data["targetLabel"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): LinkDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new LinkDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sourceLabel"] = this.sourceLabel;
        data["targetLabel"] = this.targetLabel;
        data["description"] = this.description;
        return data;
    }
}

/** Represents an entry link definition. */
export interface ILinkDefinition {
    /** The ID of the link definition. */
    id?: number;
    /** The label for the source entry in the link definition. */
    sourceLabel?: string | undefined;
    /** The label for the target entry in the link definition. */
    targetLabel?: string | undefined;
    /** The description of the link definition. */
    description?: string | undefined;
}

/** Response for CreateMultipartUploadUrls. */
export class CreateMultipartUploadUrlsResponse implements ICreateMultipartUploadUrlsResponse {
    /** A unique identifier for the whole upload process. */
    uploadId?: string | undefined;
    /** A list of URLs to which the file chunk should be written. */
    urls?: string[] | undefined;

    
    
    constructor(data?: ICreateMultipartUploadUrlsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uploadId = _data["uploadId"];
            if (Array.isArray(_data["urls"])) {
                this.urls = [] as any;
                for (let item of _data["urls"])
                    this.urls!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateMultipartUploadUrlsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMultipartUploadUrlsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uploadId"] = this.uploadId;
        if (Array.isArray(this.urls)) {
            data["urls"] = [];
            for (let item of this.urls)
                data["urls"].push(item);
        }
        return data;
    }
}

/** Response for CreateMultipartUploadUrls. */
export interface ICreateMultipartUploadUrlsResponse {
    /** A unique identifier for the whole upload process. */
    uploadId?: string | undefined;
    /** A list of URLs to which the file chunk should be written. */
    urls?: string[] | undefined;
}

/** Request body for creating multipart upload urls. */
export class CreateMultipartUploadUrlsRequest implements ICreateMultipartUploadUrlsRequest {
    /** A unique identifier for the whole upload process. */
    uploadId?: string | undefined;
    /** Determines the starting position of the requested parts among all the parts associated with this upload. */
    startingPartNumber?: number;
    /** The value must be in the range [1, 100], meaning that in each call to the CreateMultipartUploadUrlsResult api, a maximum of 100 Upload URLs can be requested. Further, each file chunk written to an Upload URL should be at least 5 MB. There is no minimum size limit for the last chunk. */
    numberOfParts?: number;
    /** The name of the file to be uploaded. */
    fileName?: string | undefined;
    /** The mime-type of the file to be uploaded. */
    mimeType?: string | undefined;

    
    
    constructor(data?: ICreateMultipartUploadUrlsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.uploadId = "";
            this.startingPartNumber = 1;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uploadId = _data["uploadId"] !== undefined ? _data["uploadId"] : "";
            this.startingPartNumber = _data["startingPartNumber"] !== undefined ? _data["startingPartNumber"] : 1;
            this.numberOfParts = _data["numberOfParts"];
            this.fileName = _data["fileName"];
            this.mimeType = _data["mimeType"];
        }
    }

    static fromJS(data: any): CreateMultipartUploadUrlsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMultipartUploadUrlsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uploadId"] = this.uploadId;
        data["startingPartNumber"] = this.startingPartNumber;
        data["numberOfParts"] = this.numberOfParts;
        data["fileName"] = this.fileName;
        data["mimeType"] = this.mimeType;
        return data;
    }
}

/** Request body for creating multipart upload urls. */
export interface ICreateMultipartUploadUrlsRequest {
    /** A unique identifier for the whole upload process. */
    uploadId?: string | undefined;
    /** Determines the starting position of the requested parts among all the parts associated with this upload. */
    startingPartNumber?: number;
    /** The value must be in the range [1, 100], meaning that in each call to the CreateMultipartUploadUrlsResult api, a maximum of 100 Upload URLs can be requested. Further, each file chunk written to an Upload URL should be at least 5 MB. There is no minimum size limit for the last chunk. */
    numberOfParts?: number;
    /** The name of the file to be uploaded. */
    fileName?: string | undefined;
    /** The mime-type of the file to be uploaded. */
    mimeType?: string | undefined;
}

/** Response containing a long operation task id. */
export class StartTaskResponse implements IStartTaskResponse {
    /** A task ID that can be used to check on the status of the task. */
    taskId?: string | undefined;

    
    
    constructor(data?: IStartTaskResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.taskId = _data["taskId"];
        }
    }

    static fromJS(data: any): StartTaskResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StartTaskResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskId"] = this.taskId;
        return data;
    }
}

/** Response containing a long operation task id. */
export interface IStartTaskResponse {
    /** A task ID that can be used to check on the status of the task. */
    taskId?: string | undefined;
}

/** Request body for starting an asynchronous import entry task. */
export class StartImportUploadedPartsRequest implements IStartImportUploadedPartsRequest {
    /** The UploadId received when calling the CreateMultipartUploadUrls API to request upload URLs. */
    uploadId?: string | undefined;
    /** The array of the ETag values received when writing the file chunks into the upload URLs. */
    partETags?: string[] | undefined;
    /** The name of the file. */
    name?: string | undefined;
    /** Indicates if the entry should be automatically renamed if an entry already exists with the given name in the folder. The default value is false. */
    autoRename?: boolean;
    pdfOptions?: PdfImportOptions | undefined;
    /** Determines whether the document should be imported as an electronic document. If set to true, the documented is imported as an electronic document. If set to false, the documented is converted to Laserfiche pages. The default value is false. */
    importAsElectronicDocument?: boolean;
    metadata?: ImportAsyncMetadata | undefined;
    /** The name of the volume to use. Will use the default parent entry volume if not specified. This is ignored in Laserfiche Cloud. */
    volumeName?: string | undefined;

    
    
    constructor(data?: IStartImportUploadedPartsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.autoRename = false;
            this.importAsElectronicDocument = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.uploadId = _data["uploadId"];
            if (Array.isArray(_data["partETags"])) {
                this.partETags = [] as any;
                for (let item of _data["partETags"])
                    this.partETags!.push(item);
            }
            this.name = _data["name"];
            this.autoRename = _data["autoRename"] !== undefined ? _data["autoRename"] : false;
            this.pdfOptions = _data["pdfOptions"] ? PdfImportOptions.fromJS(_data["pdfOptions"]) : <any>undefined;
            this.importAsElectronicDocument = _data["importAsElectronicDocument"] !== undefined ? _data["importAsElectronicDocument"] : false;
            this.metadata = _data["metadata"] ? ImportAsyncMetadata.fromJS(_data["metadata"]) : <any>undefined;
            this.volumeName = _data["volumeName"];
        }
    }

    static fromJS(data: any): StartImportUploadedPartsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new StartImportUploadedPartsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uploadId"] = this.uploadId;
        if (Array.isArray(this.partETags)) {
            data["partETags"] = [];
            for (let item of this.partETags)
                data["partETags"].push(item);
        }
        data["name"] = this.name;
        data["autoRename"] = this.autoRename;
        data["pdfOptions"] = this.pdfOptions ? this.pdfOptions.toJSON() : <any>undefined;
        data["importAsElectronicDocument"] = this.importAsElectronicDocument;
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        data["volumeName"] = this.volumeName;
        return data;
    }
}

/** Request body for starting an asynchronous import entry task. */
export interface IStartImportUploadedPartsRequest {
    /** The UploadId received when calling the CreateMultipartUploadUrls API to request upload URLs. */
    uploadId?: string | undefined;
    /** The array of the ETag values received when writing the file chunks into the upload URLs. */
    partETags?: string[] | undefined;
    /** The name of the file. */
    name?: string | undefined;
    /** Indicates if the entry should be automatically renamed if an entry already exists with the given name in the folder. The default value is false. */
    autoRename?: boolean;
    pdfOptions?: PdfImportOptions | undefined;
    /** Determines whether the document should be imported as an electronic document. If set to true, the documented is imported as an electronic document. If set to false, the documented is converted to Laserfiche pages. The default value is false. */
    importAsElectronicDocument?: boolean;
    metadata?: ImportAsyncMetadata | undefined;
    /** The name of the volume to use. Will use the default parent entry volume if not specified. This is ignored in Laserfiche Cloud. */
    volumeName?: string | undefined;
}

/** PDF-related options for importing an entry. */
export class PdfImportOptions implements IPdfImportOptions {
    generateText?: boolean;
    /** Determines whether the import operation should also generate page images. This only works for certain file types, for example PDF files.  */
    generatePages?: boolean;
    generatePagesImageType?: GeneratePagesImageType;
    /** Determines whether the PDF document should be imported as an electronic document. If set to true, the import operation keeps the PDF electronic document. If set to false, the import operation does not keep the PDF electronic document. The default value is true. */
    keepPdfAfterImport?: boolean;

    
    
    constructor(data?: IPdfImportOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.generateText = false;
            this.generatePages = false;
            this.generatePagesImageType = GeneratePagesImageType.StandardColor;
            this.keepPdfAfterImport = true;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.generateText = _data["generateText"] !== undefined ? _data["generateText"] : false;
            this.generatePages = _data["generatePages"] !== undefined ? _data["generatePages"] : false;
            this.generatePagesImageType = _data["generatePagesImageType"] !== undefined ? _data["generatePagesImageType"] : GeneratePagesImageType.StandardColor;
            this.keepPdfAfterImport = _data["keepPdfAfterImport"] !== undefined ? _data["keepPdfAfterImport"] : true;
        }
    }

    static fromJS(data: any): PdfImportOptions {
        data = typeof data === 'object' ? data : {};
        let result = new PdfImportOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["generateText"] = this.generateText;
        data["generatePages"] = this.generatePages;
        data["generatePagesImageType"] = this.generatePagesImageType;
        data["keepPdfAfterImport"] = this.keepPdfAfterImport;
        return data;
    }
}

/** PDF-related options for importing an entry. */
export interface IPdfImportOptions {
    generateText?: boolean;
    /** Determines whether the import operation should also generate page images. This only works for certain file types, for example PDF files.  */
    generatePages?: boolean;
    generatePagesImageType?: GeneratePagesImageType;
    /** Determines whether the PDF document should be imported as an electronic document. If set to true, the import operation keeps the PDF electronic document. If set to false, the import operation does not keep the PDF electronic document. The default value is true. */
    keepPdfAfterImport?: boolean;
}

export enum GeneratePagesImageType {
    BlackAndWhite = "BlackAndWhite",
    StandardColor = "StandardColor",
    HighQualityColor = "HighQualityColor",
}

export class ImportAsyncMetadata implements IImportAsyncMetadata {
    /** The name of the template assigned to the entry. */
    templateName?: string | undefined;
    /** The fields that will be assigned to the entry. */
    fields?: FieldToUpdate[] | undefined;
    /** The tags that will be assigned to the entry. */
    tags?: string[] | undefined;
    /** The links that will be assigned to the entry. */
    links?: LinkToUpdate[] | undefined;

    
    
    constructor(data?: IImportAsyncMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.templateName = _data["templateName"];
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(FieldToUpdate.fromJS(item));
            }
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(LinkToUpdate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ImportAsyncMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new ImportAsyncMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateName"] = this.templateName;
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        return data;
    }
}

export interface IImportAsyncMetadata {
    /** The name of the template assigned to the entry. */
    templateName?: string | undefined;
    /** The fields that will be assigned to the entry. */
    fields?: FieldToUpdate[] | undefined;
    /** The tags that will be assigned to the entry. */
    tags?: string[] | undefined;
    /** The links that will be assigned to the entry. */
    links?: LinkToUpdate[] | undefined;
}

/** The request body containing fields that will be assigned to the entry. */
export class FieldToUpdate implements IFieldToUpdate {
    name!: string;
    /** The field values that will be assigned to the field. */
    values?: string[] | undefined;

    
    
    constructor(data?: IFieldToUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(item);
            }
        }
    }

    static fromJS(data: any): FieldToUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new FieldToUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        return data;
    }
}

/** The request body containing fields that will be assigned to the entry. */
export interface IFieldToUpdate {
    name: string;
    /** The field values that will be assigned to the field. */
    values?: string[] | undefined;
}

export class LinkToUpdate implements ILinkToUpdate {
    /** The id of the link definition to be assigned to the entry. */
    linkDefinitionId?: number;
    /** The id of the other entry to be linked to the entry. */
    otherEntryId?: number;
    /** Whether the entry is the source for the link. */
    isSource?: boolean;
    /** Custom properties (key, value pairs) to be added to the link. */
    customProperties?: { [key: string]: string; } | undefined;

    
    
    constructor(data?: ILinkToUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.isSource = true;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.linkDefinitionId = _data["linkDefinitionId"];
            this.otherEntryId = _data["otherEntryId"];
            this.isSource = _data["isSource"] !== undefined ? _data["isSource"] : true;
            if (_data["customProperties"]) {
                this.customProperties = {} as any;
                for (let key in _data["customProperties"]) {
                    if (_data["customProperties"].hasOwnProperty(key))
                        (<any>this.customProperties)![key] = _data["customProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): LinkToUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new LinkToUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["linkDefinitionId"] = this.linkDefinitionId;
        data["otherEntryId"] = this.otherEntryId;
        data["isSource"] = this.isSource;
        if (this.customProperties) {
            data["customProperties"] = {};
            for (let key in this.customProperties) {
                if (this.customProperties.hasOwnProperty(key))
                    (<any>data["customProperties"])[key] = this.customProperties[key];
            }
        }
        return data;
    }
}

export interface ILinkToUpdate {
    /** The id of the link definition to be assigned to the entry. */
    linkDefinitionId?: number;
    /** The id of the other entry to be linked to the entry. */
    otherEntryId?: number;
    /** Whether the entry is the source for the link. */
    isSource?: boolean;
    /** Custom properties (key, value pairs) to be added to the link. */
    customProperties?: { [key: string]: string; } | undefined;
}

/** Request body for starting an asynchronous export entry task. */
export class StartExportEntryRequest implements IStartExportEntryRequest {
    /** The reason id for this audit event. */
    auditReasonId?: number;
    /** The comment for this audit event. */
    auditReasonComment?: string | undefined;
    /** Specifies the part of the document to export. */
    part!: ExportEntryRequestPart;
    /** The options applied when exporting as Image. */
    imageOptions?: ExportEntryRequestImageOptions | undefined;
    /** The options applied when exporting as Text. */
    textOptions?: ExportEntryRequestTextOptions | undefined;

    
    
    constructor(data?: IStartExportEntryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.auditReasonComment = "";
        }
    }

    init(_data?: any) {
        if (_data) {
            this.auditReasonId = _data["auditReasonId"];
            this.auditReasonComment = _data["auditReasonComment"] !== undefined ? _data["auditReasonComment"] : "";
            this.part = _data["part"];
            this.imageOptions = _data["imageOptions"] ? ExportEntryRequestImageOptions.fromJS(_data["imageOptions"]) : <any>undefined;
            this.textOptions = _data["textOptions"] ? ExportEntryRequestTextOptions.fromJS(_data["textOptions"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StartExportEntryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new StartExportEntryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["auditReasonId"] = this.auditReasonId;
        data["auditReasonComment"] = this.auditReasonComment;
        data["part"] = this.part;
        data["imageOptions"] = this.imageOptions ? this.imageOptions.toJSON() : <any>undefined;
        data["textOptions"] = this.textOptions ? this.textOptions.toJSON() : <any>undefined;
        return data;
    }
}

/** Request body for starting an asynchronous export entry task. */
export interface IStartExportEntryRequest {
    /** The reason id for this audit event. */
    auditReasonId?: number;
    /** The comment for this audit event. */
    auditReasonComment?: string | undefined;
    /** Specifies the part of the document to export. */
    part: ExportEntryRequestPart;
    /** The options applied when exporting as Image. */
    imageOptions?: ExportEntryRequestImageOptions | undefined;
    /** The options applied when exporting as Text. */
    textOptions?: ExportEntryRequestTextOptions | undefined;
}

/** Enumeration of the entry parts to export. */
export enum ExportEntryRequestPart {
    Image = "Image",
    Text = "Text",
    Edoc = "Edoc",
}

/** Represents the options when exporting the image part of an entry. */
export class ExportEntryRequestImageOptions implements IExportEntryRequestImageOptions {
    /** The image format to export as. Options include: MultiPageTIFF, SinglePageTIFF, PNG, PDF and JPEG. The default value is MultiPageTIFF. MultiPageTIFF format is a single multi-page TIFF file. SinglePageTIFF format is multiple single-page TIFF files (in a single zip file). */
    format?: ExportEntryRequestImageFormat;
    /** The quality level for JPEG compression when exporting images. The value must be between 0 and 100 (inclusive). The default value is 70. */
    jPEGCompressionLevel?: number;
    /** Indicates if the annotations need to be included. The default value is true. */
    includeAnnotations?: boolean;
    /** Indicates if the annotations on the image need to be converted to PDF annotations when exporting to PDF format. The default value is true. This option is only applicable when exporting to PDF format and IncludeAnnotations is true. */
    convertPdfAnnotations?: boolean;
    /** The page prefix of the individual files, when exporting to multi-file format (e.g.zip). The value must have a length of atmost 10 characters and only valid characters that can be included in file names are allowed. The default value is ", Page ". */
    pagePrefix?: string | undefined;
    /** Indicates if redactions are included. The default value is true. */
    includeRedactions?: boolean;
    /** The watermark element added to each image. */
    watermark?: ExportEntryRequestWatermark | undefined;

    
    
    constructor(data?: IExportEntryRequestImageOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.format = ExportEntryRequestImageFormat.MultiPageTIFF;
            this.jPEGCompressionLevel = 70;
            this.includeAnnotations = true;
            this.convertPdfAnnotations = true;
            this.pagePrefix = ", Page ";
            this.includeRedactions = true;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.format = _data["format"] !== undefined ? _data["format"] : ExportEntryRequestImageFormat.MultiPageTIFF;
            this.jPEGCompressionLevel = _data["jPEGCompressionLevel"] !== undefined ? _data["jPEGCompressionLevel"] : 70;
            this.includeAnnotations = _data["includeAnnotations"] !== undefined ? _data["includeAnnotations"] : true;
            this.convertPdfAnnotations = _data["convertPdfAnnotations"] !== undefined ? _data["convertPdfAnnotations"] : true;
            this.pagePrefix = _data["pagePrefix"] !== undefined ? _data["pagePrefix"] : ", Page ";
            this.includeRedactions = _data["includeRedactions"] !== undefined ? _data["includeRedactions"] : true;
            this.watermark = _data["watermark"] ? ExportEntryRequestWatermark.fromJS(_data["watermark"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExportEntryRequestImageOptions {
        data = typeof data === 'object' ? data : {};
        let result = new ExportEntryRequestImageOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["format"] = this.format;
        data["jPEGCompressionLevel"] = this.jPEGCompressionLevel;
        data["includeAnnotations"] = this.includeAnnotations;
        data["convertPdfAnnotations"] = this.convertPdfAnnotations;
        data["pagePrefix"] = this.pagePrefix;
        data["includeRedactions"] = this.includeRedactions;
        data["watermark"] = this.watermark ? this.watermark.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents the options when exporting the image part of an entry. */
export interface IExportEntryRequestImageOptions {
    /** The image format to export as. Options include: MultiPageTIFF, SinglePageTIFF, PNG, PDF and JPEG. The default value is MultiPageTIFF. MultiPageTIFF format is a single multi-page TIFF file. SinglePageTIFF format is multiple single-page TIFF files (in a single zip file). */
    format?: ExportEntryRequestImageFormat;
    /** The quality level for JPEG compression when exporting images. The value must be between 0 and 100 (inclusive). The default value is 70. */
    jPEGCompressionLevel?: number;
    /** Indicates if the annotations need to be included. The default value is true. */
    includeAnnotations?: boolean;
    /** Indicates if the annotations on the image need to be converted to PDF annotations when exporting to PDF format. The default value is true. This option is only applicable when exporting to PDF format and IncludeAnnotations is true. */
    convertPdfAnnotations?: boolean;
    /** The page prefix of the individual files, when exporting to multi-file format (e.g.zip). The value must have a length of atmost 10 characters and only valid characters that can be included in file names are allowed. The default value is ", Page ". */
    pagePrefix?: string | undefined;
    /** Indicates if redactions are included. The default value is true. */
    includeRedactions?: boolean;
    /** The watermark element added to each image. */
    watermark?: ExportEntryRequestWatermark | undefined;
}

/** Enumeration of formats when exporting the image part of an entry. */
export enum ExportEntryRequestImageFormat {
    MultiPageTIFF = "MultiPageTIFF",
    SinglePageTIFF = "SinglePageTIFF",
    PNG = "PNG",
    PDF = "PDF",
    JPEG = "JPEG",
}

/** Represents the watermark added to the images when exporting an entry. */
export class ExportEntryRequestWatermark implements IExportEntryRequestWatermark {
    /** The text of the watermark. The value must be a string with a length of atmost 100 characters. */
    text?: string | undefined;
    /** The position of the watermark. The default value is DeadCenter. */
    position?: WatermarkPosition;
    /** The rotation angle of the watermark. The value must be between 0 and 360 (inclusive). */
    rotationAngle?: number;
    /** The percentage of the page that the watermark spans on. The value must be between 1 and 100 (inclusive). The default value is 50. */
    pageSpanPercentage?: number;

    
    
    constructor(data?: IExportEntryRequestWatermark) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.text = "";
            this.position = WatermarkPosition.DeadCenter;
            this.rotationAngle = 0;
            this.pageSpanPercentage = 50;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"] !== undefined ? _data["text"] : "";
            this.position = _data["position"] !== undefined ? _data["position"] : WatermarkPosition.DeadCenter;
            this.rotationAngle = _data["rotationAngle"] !== undefined ? _data["rotationAngle"] : 0;
            this.pageSpanPercentage = _data["pageSpanPercentage"] !== undefined ? _data["pageSpanPercentage"] : 50;
        }
    }

    static fromJS(data: any): ExportEntryRequestWatermark {
        data = typeof data === 'object' ? data : {};
        let result = new ExportEntryRequestWatermark();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["position"] = this.position;
        data["rotationAngle"] = this.rotationAngle;
        data["pageSpanPercentage"] = this.pageSpanPercentage;
        return data;
    }
}

/** Represents the watermark added to the images when exporting an entry. */
export interface IExportEntryRequestWatermark {
    /** The text of the watermark. The value must be a string with a length of atmost 100 characters. */
    text?: string | undefined;
    /** The position of the watermark. The default value is DeadCenter. */
    position?: WatermarkPosition;
    /** The rotation angle of the watermark. The value must be between 0 and 360 (inclusive). */
    rotationAngle?: number;
    /** The percentage of the page that the watermark spans on. The value must be between 1 and 100 (inclusive). The default value is 50. */
    pageSpanPercentage?: number;
}

/** An enumeration of possible positions on a page for watermarks. */
export enum WatermarkPosition {
    TopLeft = "TopLeft",
    TopCenter = "TopCenter",
    TopRight = "TopRight",
    MiddleLeft = "MiddleLeft",
    DeadCenter = "DeadCenter",
    MiddleRight = "MiddleRight",
    BottomLeft = "BottomLeft",
    BottomCenter = "BottomCenter",
    BottomRight = "BottomRight",
}

/** Represents the options when exporting the text part of an entry. */
export class ExportEntryRequestTextOptions implements IExportEntryRequestTextOptions {
    /** Indicates if redactions are included. The default value is true. */
    includeRedactions?: boolean;
    /** The character that replaces the original character in a redacted text. The value must be a string of length 1 and must not be a whitespace character. The default value is 'X'. */
    redactionCharacter?: string | undefined;

    
    
    constructor(data?: IExportEntryRequestTextOptions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.includeRedactions = true;
            this.redactionCharacter = "X";
        }
    }

    init(_data?: any) {
        if (_data) {
            this.includeRedactions = _data["includeRedactions"] !== undefined ? _data["includeRedactions"] : true;
            this.redactionCharacter = _data["redactionCharacter"] !== undefined ? _data["redactionCharacter"] : "X";
        }
    }

    static fromJS(data: any): ExportEntryRequestTextOptions {
        data = typeof data === 'object' ? data : {};
        let result = new ExportEntryRequestTextOptions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["includeRedactions"] = this.includeRedactions;
        data["redactionCharacter"] = this.redactionCharacter;
        return data;
    }
}

/** Represents the options when exporting the text part of an entry. */
export interface IExportEntryRequestTextOptions {
    /** Indicates if redactions are included. The default value is true. */
    includeRedactions?: boolean;
    /** The character that replaces the original character in a redacted text. The value must be a string of length 1 and must not be a whitespace character. The default value is 'X'. */
    redactionCharacter?: string | undefined;
}

/** Request body for starting an asynchronous copy entry task. */
export class StartCopyEntryRequest implements IStartCopyEntryRequest {
    /** The name of the entry. */
    name!: string;
    /** Indicates if the entry should be automatically renamed if an entry already exists with the given name in the folder. The default value is false. */
    autoRename?: boolean;
    /** The source entry Id to copy. */
    sourceId!: number;
    /** The name of the volume to use. Will use the default parent entry volume if not specified. This is ignored in Laserfiche Cloud. */
    volumeName?: string | undefined;

    
    
    constructor(data?: IStartCopyEntryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.autoRename = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.autoRename = _data["autoRename"] !== undefined ? _data["autoRename"] : false;
            this.sourceId = _data["sourceId"];
            this.volumeName = _data["volumeName"];
        }
    }

    static fromJS(data: any): StartCopyEntryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new StartCopyEntryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["autoRename"] = this.autoRename;
        data["sourceId"] = this.sourceId;
        data["volumeName"] = this.volumeName;
        return data;
    }
}

/** Request body for starting an asynchronous copy entry task. */
export interface IStartCopyEntryRequest {
    /** The name of the entry. */
    name: string;
    /** Indicates if the entry should be automatically renamed if an entry already exists with the given name in the folder. The default value is false. */
    autoRename?: boolean;
    /** The source entry Id to copy. */
    sourceId: number;
    /** The name of the volume to use. Will use the default parent entry volume if not specified. This is ignored in Laserfiche Cloud. */
    volumeName?: string | undefined;
}

/** Request body for starting an asynchronous delete entry task. */
export class StartDeleteEntryRequest implements IStartDeleteEntryRequest {
    /** The reason id for this audit event. */
    auditReasonId?: number | undefined;
    /** The comment for this audit event. */
    auditReasonComment?: string | undefined;

    
    
    constructor(data?: IStartDeleteEntryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.auditReasonId = _data["auditReasonId"];
            this.auditReasonComment = _data["auditReasonComment"];
        }
    }

    static fromJS(data: any): StartDeleteEntryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new StartDeleteEntryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["auditReasonId"] = this.auditReasonId;
        data["auditReasonComment"] = this.auditReasonComment;
        return data;
    }
}

/** Request body for starting an asynchronous delete entry task. */
export interface IStartDeleteEntryRequest {
    /** The reason id for this audit event. */
    auditReasonId?: number | undefined;
    /** The comment for this audit event. */
    auditReasonComment?: string | undefined;
}

export abstract class Entry implements IEntry {
    /** The ID of the entry. */
    id?: number;
    /** The name of the entry. */
    name?: string | undefined;
    /** The ID of the parent entry. */
    parentId?: number | undefined;
    /** The full path in the Laserfiche repository to the entry. */
    fullPath?: string | undefined;
    /** The path in the Laserfiche repository to the parent folder. */
    folderPath?: string | undefined;
    /** The name of the user that created this entry. */
    creator?: string | undefined;
    /** The creation time of the entry. */
    creationTime?: Date;
    /** The last modification time of the entry. */
    lastModifiedTime?: Date;
    /** The type of the entry. */
    entryType?: EntryType;
    /** A boolean indicating if this entry is a container object; it can have other entries as children. */
    isContainer?: boolean;
    /** A boolean indicating if this entry is a leaf object; it cannot have other entries as children. */
    isLeaf?: boolean;
    /** The name of the template assigned to this entry. */
    templateName?: string | undefined;
    /** The id of the template assigned to this entry. */
    templateId?: number;
    /** The names of the fields assigned to the template assigned to this entry. */
    templateFieldNames?: string[] | undefined;
    /** The name of the volume that this entry is associated with. */
    volumeName?: string | undefined;
    /** Row number assigned to this entry in the listing. */
    rowNumber?: number | undefined;
    /** The fields assigned to this entry. */
    fields?: Field[] | undefined;
    protected _discriminator: string;

    
    
    constructor(data?: IEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "Entry";
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.parentId = _data["parentId"];
            this.fullPath = _data["fullPath"];
            this.folderPath = _data["folderPath"];
            this.creator = _data["creator"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifiedTime = _data["lastModifiedTime"] ? new Date(_data["lastModifiedTime"].toString()) : <any>undefined;
            this.entryType = _data["entryType"];
            this.isContainer = _data["isContainer"];
            this.isLeaf = _data["isLeaf"];
            this.templateName = _data["templateName"];
            this.templateId = _data["templateId"];
            if (Array.isArray(_data["templateFieldNames"])) {
                this.templateFieldNames = [] as any;
                for (let item of _data["templateFieldNames"])
                    this.templateFieldNames!.push(item);
            }
            this.volumeName = _data["volumeName"];
            this.rowNumber = _data["rowNumber"];
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(Field.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Entry {
        data = typeof data === 'object' ? data : {};
        if (data["entryType"] === "Document") {
            let result = new Document();
            result.init(data);
            return result;
        }
        if (data["entryType"] === "Shortcut") {
            let result = new Shortcut();
            result.init(data);
            return result;
        }
        if (data["entryType"] === "Folder") {
            let result = new Folder();
            result.init(data);
            return result;
        }
        if (data["entryType"] === "RecordSeries") {
            let result = new RecordSeries();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'Entry' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entryType"] = this._discriminator;
        data["id"] = this.id;
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        data["fullPath"] = this.fullPath;
        data["folderPath"] = this.folderPath;
        data["creator"] = this.creator;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifiedTime"] = this.lastModifiedTime ? this.lastModifiedTime.toISOString() : <any>undefined;
        data["entryType"] = this.entryType;
        data["isContainer"] = this.isContainer;
        data["isLeaf"] = this.isLeaf;
        data["templateName"] = this.templateName;
        data["templateId"] = this.templateId;
        if (Array.isArray(this.templateFieldNames)) {
            data["templateFieldNames"] = [];
            for (let item of this.templateFieldNames)
                data["templateFieldNames"].push(item);
        }
        data["volumeName"] = this.volumeName;
        data["rowNumber"] = this.rowNumber;
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEntry {
    /** The ID of the entry. */
    id?: number;
    /** The name of the entry. */
    name?: string | undefined;
    /** The ID of the parent entry. */
    parentId?: number | undefined;
    /** The full path in the Laserfiche repository to the entry. */
    fullPath?: string | undefined;
    /** The path in the Laserfiche repository to the parent folder. */
    folderPath?: string | undefined;
    /** The name of the user that created this entry. */
    creator?: string | undefined;
    /** The creation time of the entry. */
    creationTime?: Date;
    /** The last modification time of the entry. */
    lastModifiedTime?: Date;
    /** The type of the entry. */
    entryType?: EntryType;
    /** A boolean indicating if this entry is a container object; it can have other entries as children. */
    isContainer?: boolean;
    /** A boolean indicating if this entry is a leaf object; it cannot have other entries as children. */
    isLeaf?: boolean;
    /** The name of the template assigned to this entry. */
    templateName?: string | undefined;
    /** The id of the template assigned to this entry. */
    templateId?: number;
    /** The names of the fields assigned to the template assigned to this entry. */
    templateFieldNames?: string[] | undefined;
    /** The name of the volume that this entry is associated with. */
    volumeName?: string | undefined;
    /** Row number assigned to this entry in the listing. */
    rowNumber?: number | undefined;
    /** The fields assigned to this entry. */
    fields?: Field[] | undefined;
}

export enum EntryType {
    Folder = "Folder",
    RecordSeries = "RecordSeries",
    Document = "Document",
    Shortcut = "Shortcut",
}

/** Represents a field set on an entry. */
export class Field implements IField {
    /** The name of the field. */
    name?: string | undefined;
    /** The type of the field. The possible field types are listed below. */
    fieldType?: FieldType;
    /** The ID of the field. */
    id?: number;
    /** A boolean indicating if the represented field supports multiple values. */
    isMultiValue?: boolean;
    /** A boolean indicating if the represented field must have a value set on entries assigned to a template that the field is a member of. */
    isRequired?: boolean;
    /** A boolean indicating if there are more field values. */
    hasMoreValues?: boolean;
    /** The group id of the multi value field group. If the field is not a part of a multi value field group, then there is no group id. */
    groupId?: number | undefined;
    /** The values assigned to the field. */
    values?: string[] | undefined;

    
    
    constructor(data?: IField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.fieldType = _data["fieldType"];
            this.id = _data["id"];
            this.isMultiValue = _data["isMultiValue"];
            this.isRequired = _data["isRequired"];
            this.hasMoreValues = _data["hasMoreValues"];
            this.groupId = _data["groupId"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(item);
            }
        }
    }

    static fromJS(data: any): Field {
        data = typeof data === 'object' ? data : {};
        let result = new Field();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["fieldType"] = this.fieldType;
        data["id"] = this.id;
        data["isMultiValue"] = this.isMultiValue;
        data["isRequired"] = this.isRequired;
        data["hasMoreValues"] = this.hasMoreValues;
        data["groupId"] = this.groupId;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        return data;
    }
}

/** Represents a field set on an entry. */
export interface IField {
    /** The name of the field. */
    name?: string | undefined;
    /** The type of the field. The possible field types are listed below. */
    fieldType?: FieldType;
    /** The ID of the field. */
    id?: number;
    /** A boolean indicating if the represented field supports multiple values. */
    isMultiValue?: boolean;
    /** A boolean indicating if the represented field must have a value set on entries assigned to a template that the field is a member of. */
    isRequired?: boolean;
    /** A boolean indicating if there are more field values. */
    hasMoreValues?: boolean;
    /** The group id of the multi value field group. If the field is not a part of a multi value field group, then there is no group id. */
    groupId?: number | undefined;
    /** The values assigned to the field. */
    values?: string[] | undefined;
}

/** Represents a Laserfiche record series. */
export class RecordSeries extends Entry implements IRecordSeries {

    
    
    constructor(data?: IRecordSeries) {
        super(data);
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "RecordSeries";
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): RecordSeries {
        data = typeof data === 'object' ? data : {};
        let result = new RecordSeries();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

/** Represents a Laserfiche record series. */
export interface IRecordSeries extends IEntry {
}

/** Represents a document in a Laserfiche repository. */
export class Document extends Entry implements IDocument {
    /** The size of the electronic document attached to the represented document, if there is one, in bytes. */
    elecDocumentSize?: number;
    /** The extension for the document. */
    extension?: string | undefined;
    /** A boolean indicating if there is an electronic document attached to the represented document. */
    isElectronicDocument?: boolean;
    /** A boolean indicating if the represented document is a record. */
    isRecord?: boolean;
    /** The MIME type of the electronic document. */
    mimeType?: string | undefined;
    /** The page count of the represented document. */
    pageCount?: number;
    /** A boolean indicating if the represented document is checked out. */
    isCheckedOut?: boolean;
    /** A boolean indicating if the represented document is under version control. */
    isUnderVersionControl?: boolean;

    
    
    constructor(data?: IDocument) {
        super(data);
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "Document";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.elecDocumentSize = _data["elecDocumentSize"];
            this.extension = _data["extension"];
            this.isElectronicDocument = _data["isElectronicDocument"];
            this.isRecord = _data["isRecord"];
            this.mimeType = _data["mimeType"];
            this.pageCount = _data["pageCount"];
            this.isCheckedOut = _data["isCheckedOut"];
            this.isUnderVersionControl = _data["isUnderVersionControl"];
        }
    }

    static fromJS(data: any): Document {
        data = typeof data === 'object' ? data : {};
        let result = new Document();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elecDocumentSize"] = this.elecDocumentSize;
        data["extension"] = this.extension;
        data["isElectronicDocument"] = this.isElectronicDocument;
        data["isRecord"] = this.isRecord;
        data["mimeType"] = this.mimeType;
        data["pageCount"] = this.pageCount;
        data["isCheckedOut"] = this.isCheckedOut;
        data["isUnderVersionControl"] = this.isUnderVersionControl;
        super.toJSON(data);
        return data;
    }
}

/** Represents a document in a Laserfiche repository. */
export interface IDocument extends IEntry {
    /** The size of the electronic document attached to the represented document, if there is one, in bytes. */
    elecDocumentSize?: number;
    /** The extension for the document. */
    extension?: string | undefined;
    /** A boolean indicating if there is an electronic document attached to the represented document. */
    isElectronicDocument?: boolean;
    /** A boolean indicating if the represented document is a record. */
    isRecord?: boolean;
    /** The MIME type of the electronic document. */
    mimeType?: string | undefined;
    /** The page count of the represented document. */
    pageCount?: number;
    /** A boolean indicating if the represented document is checked out. */
    isCheckedOut?: boolean;
    /** A boolean indicating if the represented document is under version control. */
    isUnderVersionControl?: boolean;
}

/** Represents an entry shortcut in a Laserfiche repository. */
export class Shortcut extends Entry implements IShortcut {
    /** The entry ID of the shortcut target. */
    targetId?: number;
    /** The extension of the shortcut target. */
    extension?: string | undefined;
    /** The entry type of the shortcut target. */
    targetType?: EntryType;

    
    
    constructor(data?: IShortcut) {
        super(data);
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "Shortcut";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.targetId = _data["targetId"];
            this.extension = _data["extension"];
            this.targetType = _data["targetType"];
        }
    }

    static fromJS(data: any): Shortcut {
        data = typeof data === 'object' ? data : {};
        let result = new Shortcut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetId"] = this.targetId;
        data["extension"] = this.extension;
        data["targetType"] = this.targetType;
        super.toJSON(data);
        return data;
    }
}

/** Represents an entry shortcut in a Laserfiche repository. */
export interface IShortcut extends IEntry {
    /** The entry ID of the shortcut target. */
    targetId?: number;
    /** The extension of the shortcut target. */
    extension?: string | undefined;
    /** The entry type of the shortcut target. */
    targetType?: EntryType;
}

/** Represents a folder (standard or record folder) in a Laserfiche repository. */
export class Folder extends Entry implements IFolder {
    /** A boolean indicating if the folder that this instance represents is known to be a record folder. */
    isRecordFolder?: boolean;
    /** A boolean indicating if the folder that this instance represents is known to directly or indirectly under a record series in the repository. */
    isUnderRecordSeries?: boolean;
    /** The entries in this folder. */
    children?: Entry[] | undefined;

    
    
    constructor(data?: IFolder) {
        super(data);
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "Folder";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.isRecordFolder = _data["isRecordFolder"];
            this.isUnderRecordSeries = _data["isUnderRecordSeries"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(Entry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Folder {
        data = typeof data === 'object' ? data : {};
        let result = new Folder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isRecordFolder"] = this.isRecordFolder;
        data["isUnderRecordSeries"] = this.isUnderRecordSeries;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Represents a folder (standard or record folder) in a Laserfiche repository. */
export interface IFolder extends IEntry {
    /** A boolean indicating if the folder that this instance represents is known to be a record folder. */
    isRecordFolder?: boolean;
    /** A boolean indicating if the folder that this instance represents is known to directly or indirectly under a record series in the repository. */
    isUnderRecordSeries?: boolean;
    /** The entries in this folder. */
    children?: Entry[] | undefined;
}

export abstract class IHeaderDictionary implements IIHeaderDictionary {
    item?: any[];
    contentLength?: number | undefined;
    accept?: any[];
    acceptCharset?: any[];
    acceptEncoding?: any[];
    acceptLanguage?: any[];
    acceptRanges?: any[];
    accessControlAllowCredentials?: any[];
    accessControlAllowHeaders?: any[];
    accessControlAllowMethods?: any[];
    accessControlAllowOrigin?: any[];
    accessControlExposeHeaders?: any[];
    accessControlMaxAge?: any[];
    accessControlRequestHeaders?: any[];
    accessControlRequestMethod?: any[];
    age?: any[];
    allow?: any[];
    altSvc?: any[];
    authorization?: any[];
    baggage?: any[];
    cacheControl?: any[];
    connection?: any[];
    contentDisposition?: any[];
    contentEncoding?: any[];
    contentLanguage?: any[];
    contentLocation?: any[];
    contentMD5?: any[];
    contentRange?: any[];
    contentSecurityPolicy?: any[];
    contentSecurityPolicyReportOnly?: any[];
    contentType?: any[];
    correlationContext?: any[];
    cookie?: any[];
    date?: any[];
    eTag?: any[];
    expires?: any[];
    expect?: any[];
    from?: any[];
    grpcAcceptEncoding?: any[];
    grpcEncoding?: any[];
    grpcMessage?: any[];
    grpcStatus?: any[];
    grpcTimeout?: any[];
    host?: any[];
    keepAlive?: any[];
    ifMatch?: any[];
    ifModifiedSince?: any[];
    ifNoneMatch?: any[];
    ifRange?: any[];
    ifUnmodifiedSince?: any[];
    lastModified?: any[];
    link?: any[];
    location?: any[];
    maxForwards?: any[];
    origin?: any[];
    pragma?: any[];
    proxyAuthenticate?: any[];
    proxyAuthorization?: any[];
    proxyConnection?: any[];
    range?: any[];
    referer?: any[];
    retryAfter?: any[];
    requestId?: any[];
    secWebSocketAccept?: any[];
    secWebSocketKey?: any[];
    secWebSocketProtocol?: any[];
    secWebSocketVersion?: any[];
    secWebSocketExtensions?: any[];
    server?: any[];
    setCookie?: any[];
    strictTransportSecurity?: any[];
    tE?: any[];
    trailer?: any[];
    transferEncoding?: any[];
    translate?: any[];
    traceParent?: any[];
    traceState?: any[];
    upgrade?: any[];
    upgradeInsecureRequests?: any[];
    userAgent?: any[];
    vary?: any[];
    via?: any[];
    warning?: any[];
    webSocketSubProtocols?: any[];
    wWWAuthenticate?: any[];
    xContentTypeOptions?: any[];
    xFrameOptions?: any[];
    xPoweredBy?: any[];
    xRequestedWith?: any[];
    xUACompatible?: any[];
    xXSSProtection?: any[];

    
    
    constructor(data?: IIHeaderDictionary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Item"])) {
                this.item = [] as any;
                for (let item of _data["Item"])
                    this.item!.push(item);
            }
            this.contentLength = _data["ContentLength"];
            if (Array.isArray(_data["Accept"])) {
                this.accept = [] as any;
                for (let item of _data["Accept"])
                    this.accept!.push(item);
            }
            if (Array.isArray(_data["AcceptCharset"])) {
                this.acceptCharset = [] as any;
                for (let item of _data["AcceptCharset"])
                    this.acceptCharset!.push(item);
            }
            if (Array.isArray(_data["AcceptEncoding"])) {
                this.acceptEncoding = [] as any;
                for (let item of _data["AcceptEncoding"])
                    this.acceptEncoding!.push(item);
            }
            if (Array.isArray(_data["AcceptLanguage"])) {
                this.acceptLanguage = [] as any;
                for (let item of _data["AcceptLanguage"])
                    this.acceptLanguage!.push(item);
            }
            if (Array.isArray(_data["AcceptRanges"])) {
                this.acceptRanges = [] as any;
                for (let item of _data["AcceptRanges"])
                    this.acceptRanges!.push(item);
            }
            if (Array.isArray(_data["AccessControlAllowCredentials"])) {
                this.accessControlAllowCredentials = [] as any;
                for (let item of _data["AccessControlAllowCredentials"])
                    this.accessControlAllowCredentials!.push(item);
            }
            if (Array.isArray(_data["AccessControlAllowHeaders"])) {
                this.accessControlAllowHeaders = [] as any;
                for (let item of _data["AccessControlAllowHeaders"])
                    this.accessControlAllowHeaders!.push(item);
            }
            if (Array.isArray(_data["AccessControlAllowMethods"])) {
                this.accessControlAllowMethods = [] as any;
                for (let item of _data["AccessControlAllowMethods"])
                    this.accessControlAllowMethods!.push(item);
            }
            if (Array.isArray(_data["AccessControlAllowOrigin"])) {
                this.accessControlAllowOrigin = [] as any;
                for (let item of _data["AccessControlAllowOrigin"])
                    this.accessControlAllowOrigin!.push(item);
            }
            if (Array.isArray(_data["AccessControlExposeHeaders"])) {
                this.accessControlExposeHeaders = [] as any;
                for (let item of _data["AccessControlExposeHeaders"])
                    this.accessControlExposeHeaders!.push(item);
            }
            if (Array.isArray(_data["AccessControlMaxAge"])) {
                this.accessControlMaxAge = [] as any;
                for (let item of _data["AccessControlMaxAge"])
                    this.accessControlMaxAge!.push(item);
            }
            if (Array.isArray(_data["AccessControlRequestHeaders"])) {
                this.accessControlRequestHeaders = [] as any;
                for (let item of _data["AccessControlRequestHeaders"])
                    this.accessControlRequestHeaders!.push(item);
            }
            if (Array.isArray(_data["AccessControlRequestMethod"])) {
                this.accessControlRequestMethod = [] as any;
                for (let item of _data["AccessControlRequestMethod"])
                    this.accessControlRequestMethod!.push(item);
            }
            if (Array.isArray(_data["Age"])) {
                this.age = [] as any;
                for (let item of _data["Age"])
                    this.age!.push(item);
            }
            if (Array.isArray(_data["Allow"])) {
                this.allow = [] as any;
                for (let item of _data["Allow"])
                    this.allow!.push(item);
            }
            if (Array.isArray(_data["AltSvc"])) {
                this.altSvc = [] as any;
                for (let item of _data["AltSvc"])
                    this.altSvc!.push(item);
            }
            if (Array.isArray(_data["Authorization"])) {
                this.authorization = [] as any;
                for (let item of _data["Authorization"])
                    this.authorization!.push(item);
            }
            if (Array.isArray(_data["Baggage"])) {
                this.baggage = [] as any;
                for (let item of _data["Baggage"])
                    this.baggage!.push(item);
            }
            if (Array.isArray(_data["CacheControl"])) {
                this.cacheControl = [] as any;
                for (let item of _data["CacheControl"])
                    this.cacheControl!.push(item);
            }
            if (Array.isArray(_data["Connection"])) {
                this.connection = [] as any;
                for (let item of _data["Connection"])
                    this.connection!.push(item);
            }
            if (Array.isArray(_data["ContentDisposition"])) {
                this.contentDisposition = [] as any;
                for (let item of _data["ContentDisposition"])
                    this.contentDisposition!.push(item);
            }
            if (Array.isArray(_data["ContentEncoding"])) {
                this.contentEncoding = [] as any;
                for (let item of _data["ContentEncoding"])
                    this.contentEncoding!.push(item);
            }
            if (Array.isArray(_data["ContentLanguage"])) {
                this.contentLanguage = [] as any;
                for (let item of _data["ContentLanguage"])
                    this.contentLanguage!.push(item);
            }
            if (Array.isArray(_data["ContentLocation"])) {
                this.contentLocation = [] as any;
                for (let item of _data["ContentLocation"])
                    this.contentLocation!.push(item);
            }
            if (Array.isArray(_data["ContentMD5"])) {
                this.contentMD5 = [] as any;
                for (let item of _data["ContentMD5"])
                    this.contentMD5!.push(item);
            }
            if (Array.isArray(_data["ContentRange"])) {
                this.contentRange = [] as any;
                for (let item of _data["ContentRange"])
                    this.contentRange!.push(item);
            }
            if (Array.isArray(_data["ContentSecurityPolicy"])) {
                this.contentSecurityPolicy = [] as any;
                for (let item of _data["ContentSecurityPolicy"])
                    this.contentSecurityPolicy!.push(item);
            }
            if (Array.isArray(_data["ContentSecurityPolicyReportOnly"])) {
                this.contentSecurityPolicyReportOnly = [] as any;
                for (let item of _data["ContentSecurityPolicyReportOnly"])
                    this.contentSecurityPolicyReportOnly!.push(item);
            }
            if (Array.isArray(_data["ContentType"])) {
                this.contentType = [] as any;
                for (let item of _data["ContentType"])
                    this.contentType!.push(item);
            }
            if (Array.isArray(_data["CorrelationContext"])) {
                this.correlationContext = [] as any;
                for (let item of _data["CorrelationContext"])
                    this.correlationContext!.push(item);
            }
            if (Array.isArray(_data["Cookie"])) {
                this.cookie = [] as any;
                for (let item of _data["Cookie"])
                    this.cookie!.push(item);
            }
            if (Array.isArray(_data["Date"])) {
                this.date = [] as any;
                for (let item of _data["Date"])
                    this.date!.push(item);
            }
            if (Array.isArray(_data["ETag"])) {
                this.eTag = [] as any;
                for (let item of _data["ETag"])
                    this.eTag!.push(item);
            }
            if (Array.isArray(_data["Expires"])) {
                this.expires = [] as any;
                for (let item of _data["Expires"])
                    this.expires!.push(item);
            }
            if (Array.isArray(_data["Expect"])) {
                this.expect = [] as any;
                for (let item of _data["Expect"])
                    this.expect!.push(item);
            }
            if (Array.isArray(_data["From"])) {
                this.from = [] as any;
                for (let item of _data["From"])
                    this.from!.push(item);
            }
            if (Array.isArray(_data["GrpcAcceptEncoding"])) {
                this.grpcAcceptEncoding = [] as any;
                for (let item of _data["GrpcAcceptEncoding"])
                    this.grpcAcceptEncoding!.push(item);
            }
            if (Array.isArray(_data["GrpcEncoding"])) {
                this.grpcEncoding = [] as any;
                for (let item of _data["GrpcEncoding"])
                    this.grpcEncoding!.push(item);
            }
            if (Array.isArray(_data["GrpcMessage"])) {
                this.grpcMessage = [] as any;
                for (let item of _data["GrpcMessage"])
                    this.grpcMessage!.push(item);
            }
            if (Array.isArray(_data["GrpcStatus"])) {
                this.grpcStatus = [] as any;
                for (let item of _data["GrpcStatus"])
                    this.grpcStatus!.push(item);
            }
            if (Array.isArray(_data["GrpcTimeout"])) {
                this.grpcTimeout = [] as any;
                for (let item of _data["GrpcTimeout"])
                    this.grpcTimeout!.push(item);
            }
            if (Array.isArray(_data["Host"])) {
                this.host = [] as any;
                for (let item of _data["Host"])
                    this.host!.push(item);
            }
            if (Array.isArray(_data["KeepAlive"])) {
                this.keepAlive = [] as any;
                for (let item of _data["KeepAlive"])
                    this.keepAlive!.push(item);
            }
            if (Array.isArray(_data["IfMatch"])) {
                this.ifMatch = [] as any;
                for (let item of _data["IfMatch"])
                    this.ifMatch!.push(item);
            }
            if (Array.isArray(_data["IfModifiedSince"])) {
                this.ifModifiedSince = [] as any;
                for (let item of _data["IfModifiedSince"])
                    this.ifModifiedSince!.push(item);
            }
            if (Array.isArray(_data["IfNoneMatch"])) {
                this.ifNoneMatch = [] as any;
                for (let item of _data["IfNoneMatch"])
                    this.ifNoneMatch!.push(item);
            }
            if (Array.isArray(_data["IfRange"])) {
                this.ifRange = [] as any;
                for (let item of _data["IfRange"])
                    this.ifRange!.push(item);
            }
            if (Array.isArray(_data["IfUnmodifiedSince"])) {
                this.ifUnmodifiedSince = [] as any;
                for (let item of _data["IfUnmodifiedSince"])
                    this.ifUnmodifiedSince!.push(item);
            }
            if (Array.isArray(_data["LastModified"])) {
                this.lastModified = [] as any;
                for (let item of _data["LastModified"])
                    this.lastModified!.push(item);
            }
            if (Array.isArray(_data["Link"])) {
                this.link = [] as any;
                for (let item of _data["Link"])
                    this.link!.push(item);
            }
            if (Array.isArray(_data["Location"])) {
                this.location = [] as any;
                for (let item of _data["Location"])
                    this.location!.push(item);
            }
            if (Array.isArray(_data["MaxForwards"])) {
                this.maxForwards = [] as any;
                for (let item of _data["MaxForwards"])
                    this.maxForwards!.push(item);
            }
            if (Array.isArray(_data["Origin"])) {
                this.origin = [] as any;
                for (let item of _data["Origin"])
                    this.origin!.push(item);
            }
            if (Array.isArray(_data["Pragma"])) {
                this.pragma = [] as any;
                for (let item of _data["Pragma"])
                    this.pragma!.push(item);
            }
            if (Array.isArray(_data["ProxyAuthenticate"])) {
                this.proxyAuthenticate = [] as any;
                for (let item of _data["ProxyAuthenticate"])
                    this.proxyAuthenticate!.push(item);
            }
            if (Array.isArray(_data["ProxyAuthorization"])) {
                this.proxyAuthorization = [] as any;
                for (let item of _data["ProxyAuthorization"])
                    this.proxyAuthorization!.push(item);
            }
            if (Array.isArray(_data["ProxyConnection"])) {
                this.proxyConnection = [] as any;
                for (let item of _data["ProxyConnection"])
                    this.proxyConnection!.push(item);
            }
            if (Array.isArray(_data["Range"])) {
                this.range = [] as any;
                for (let item of _data["Range"])
                    this.range!.push(item);
            }
            if (Array.isArray(_data["Referer"])) {
                this.referer = [] as any;
                for (let item of _data["Referer"])
                    this.referer!.push(item);
            }
            if (Array.isArray(_data["RetryAfter"])) {
                this.retryAfter = [] as any;
                for (let item of _data["RetryAfter"])
                    this.retryAfter!.push(item);
            }
            if (Array.isArray(_data["RequestId"])) {
                this.requestId = [] as any;
                for (let item of _data["RequestId"])
                    this.requestId!.push(item);
            }
            if (Array.isArray(_data["SecWebSocketAccept"])) {
                this.secWebSocketAccept = [] as any;
                for (let item of _data["SecWebSocketAccept"])
                    this.secWebSocketAccept!.push(item);
            }
            if (Array.isArray(_data["SecWebSocketKey"])) {
                this.secWebSocketKey = [] as any;
                for (let item of _data["SecWebSocketKey"])
                    this.secWebSocketKey!.push(item);
            }
            if (Array.isArray(_data["SecWebSocketProtocol"])) {
                this.secWebSocketProtocol = [] as any;
                for (let item of _data["SecWebSocketProtocol"])
                    this.secWebSocketProtocol!.push(item);
            }
            if (Array.isArray(_data["SecWebSocketVersion"])) {
                this.secWebSocketVersion = [] as any;
                for (let item of _data["SecWebSocketVersion"])
                    this.secWebSocketVersion!.push(item);
            }
            if (Array.isArray(_data["SecWebSocketExtensions"])) {
                this.secWebSocketExtensions = [] as any;
                for (let item of _data["SecWebSocketExtensions"])
                    this.secWebSocketExtensions!.push(item);
            }
            if (Array.isArray(_data["Server"])) {
                this.server = [] as any;
                for (let item of _data["Server"])
                    this.server!.push(item);
            }
            if (Array.isArray(_data["SetCookie"])) {
                this.setCookie = [] as any;
                for (let item of _data["SetCookie"])
                    this.setCookie!.push(item);
            }
            if (Array.isArray(_data["StrictTransportSecurity"])) {
                this.strictTransportSecurity = [] as any;
                for (let item of _data["StrictTransportSecurity"])
                    this.strictTransportSecurity!.push(item);
            }
            if (Array.isArray(_data["TE"])) {
                this.tE = [] as any;
                for (let item of _data["TE"])
                    this.tE!.push(item);
            }
            if (Array.isArray(_data["Trailer"])) {
                this.trailer = [] as any;
                for (let item of _data["Trailer"])
                    this.trailer!.push(item);
            }
            if (Array.isArray(_data["TransferEncoding"])) {
                this.transferEncoding = [] as any;
                for (let item of _data["TransferEncoding"])
                    this.transferEncoding!.push(item);
            }
            if (Array.isArray(_data["Translate"])) {
                this.translate = [] as any;
                for (let item of _data["Translate"])
                    this.translate!.push(item);
            }
            if (Array.isArray(_data["TraceParent"])) {
                this.traceParent = [] as any;
                for (let item of _data["TraceParent"])
                    this.traceParent!.push(item);
            }
            if (Array.isArray(_data["TraceState"])) {
                this.traceState = [] as any;
                for (let item of _data["TraceState"])
                    this.traceState!.push(item);
            }
            if (Array.isArray(_data["Upgrade"])) {
                this.upgrade = [] as any;
                for (let item of _data["Upgrade"])
                    this.upgrade!.push(item);
            }
            if (Array.isArray(_data["UpgradeInsecureRequests"])) {
                this.upgradeInsecureRequests = [] as any;
                for (let item of _data["UpgradeInsecureRequests"])
                    this.upgradeInsecureRequests!.push(item);
            }
            if (Array.isArray(_data["UserAgent"])) {
                this.userAgent = [] as any;
                for (let item of _data["UserAgent"])
                    this.userAgent!.push(item);
            }
            if (Array.isArray(_data["Vary"])) {
                this.vary = [] as any;
                for (let item of _data["Vary"])
                    this.vary!.push(item);
            }
            if (Array.isArray(_data["Via"])) {
                this.via = [] as any;
                for (let item of _data["Via"])
                    this.via!.push(item);
            }
            if (Array.isArray(_data["Warning"])) {
                this.warning = [] as any;
                for (let item of _data["Warning"])
                    this.warning!.push(item);
            }
            if (Array.isArray(_data["WebSocketSubProtocols"])) {
                this.webSocketSubProtocols = [] as any;
                for (let item of _data["WebSocketSubProtocols"])
                    this.webSocketSubProtocols!.push(item);
            }
            if (Array.isArray(_data["WWWAuthenticate"])) {
                this.wWWAuthenticate = [] as any;
                for (let item of _data["WWWAuthenticate"])
                    this.wWWAuthenticate!.push(item);
            }
            if (Array.isArray(_data["XContentTypeOptions"])) {
                this.xContentTypeOptions = [] as any;
                for (let item of _data["XContentTypeOptions"])
                    this.xContentTypeOptions!.push(item);
            }
            if (Array.isArray(_data["XFrameOptions"])) {
                this.xFrameOptions = [] as any;
                for (let item of _data["XFrameOptions"])
                    this.xFrameOptions!.push(item);
            }
            if (Array.isArray(_data["XPoweredBy"])) {
                this.xPoweredBy = [] as any;
                for (let item of _data["XPoweredBy"])
                    this.xPoweredBy!.push(item);
            }
            if (Array.isArray(_data["XRequestedWith"])) {
                this.xRequestedWith = [] as any;
                for (let item of _data["XRequestedWith"])
                    this.xRequestedWith!.push(item);
            }
            if (Array.isArray(_data["XUACompatible"])) {
                this.xUACompatible = [] as any;
                for (let item of _data["XUACompatible"])
                    this.xUACompatible!.push(item);
            }
            if (Array.isArray(_data["XXSSProtection"])) {
                this.xXSSProtection = [] as any;
                for (let item of _data["XXSSProtection"])
                    this.xXSSProtection!.push(item);
            }
        }
    }

    static fromJS(data: any): IHeaderDictionary {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IHeaderDictionary' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.item)) {
            data["Item"] = [];
            for (let item of this.item)
                data["Item"].push(item);
        }
        data["ContentLength"] = this.contentLength;
        if (Array.isArray(this.accept)) {
            data["Accept"] = [];
            for (let item of this.accept)
                data["Accept"].push(item);
        }
        if (Array.isArray(this.acceptCharset)) {
            data["AcceptCharset"] = [];
            for (let item of this.acceptCharset)
                data["AcceptCharset"].push(item);
        }
        if (Array.isArray(this.acceptEncoding)) {
            data["AcceptEncoding"] = [];
            for (let item of this.acceptEncoding)
                data["AcceptEncoding"].push(item);
        }
        if (Array.isArray(this.acceptLanguage)) {
            data["AcceptLanguage"] = [];
            for (let item of this.acceptLanguage)
                data["AcceptLanguage"].push(item);
        }
        if (Array.isArray(this.acceptRanges)) {
            data["AcceptRanges"] = [];
            for (let item of this.acceptRanges)
                data["AcceptRanges"].push(item);
        }
        if (Array.isArray(this.accessControlAllowCredentials)) {
            data["AccessControlAllowCredentials"] = [];
            for (let item of this.accessControlAllowCredentials)
                data["AccessControlAllowCredentials"].push(item);
        }
        if (Array.isArray(this.accessControlAllowHeaders)) {
            data["AccessControlAllowHeaders"] = [];
            for (let item of this.accessControlAllowHeaders)
                data["AccessControlAllowHeaders"].push(item);
        }
        if (Array.isArray(this.accessControlAllowMethods)) {
            data["AccessControlAllowMethods"] = [];
            for (let item of this.accessControlAllowMethods)
                data["AccessControlAllowMethods"].push(item);
        }
        if (Array.isArray(this.accessControlAllowOrigin)) {
            data["AccessControlAllowOrigin"] = [];
            for (let item of this.accessControlAllowOrigin)
                data["AccessControlAllowOrigin"].push(item);
        }
        if (Array.isArray(this.accessControlExposeHeaders)) {
            data["AccessControlExposeHeaders"] = [];
            for (let item of this.accessControlExposeHeaders)
                data["AccessControlExposeHeaders"].push(item);
        }
        if (Array.isArray(this.accessControlMaxAge)) {
            data["AccessControlMaxAge"] = [];
            for (let item of this.accessControlMaxAge)
                data["AccessControlMaxAge"].push(item);
        }
        if (Array.isArray(this.accessControlRequestHeaders)) {
            data["AccessControlRequestHeaders"] = [];
            for (let item of this.accessControlRequestHeaders)
                data["AccessControlRequestHeaders"].push(item);
        }
        if (Array.isArray(this.accessControlRequestMethod)) {
            data["AccessControlRequestMethod"] = [];
            for (let item of this.accessControlRequestMethod)
                data["AccessControlRequestMethod"].push(item);
        }
        if (Array.isArray(this.age)) {
            data["Age"] = [];
            for (let item of this.age)
                data["Age"].push(item);
        }
        if (Array.isArray(this.allow)) {
            data["Allow"] = [];
            for (let item of this.allow)
                data["Allow"].push(item);
        }
        if (Array.isArray(this.altSvc)) {
            data["AltSvc"] = [];
            for (let item of this.altSvc)
                data["AltSvc"].push(item);
        }
        if (Array.isArray(this.authorization)) {
            data["Authorization"] = [];
            for (let item of this.authorization)
                data["Authorization"].push(item);
        }
        if (Array.isArray(this.baggage)) {
            data["Baggage"] = [];
            for (let item of this.baggage)
                data["Baggage"].push(item);
        }
        if (Array.isArray(this.cacheControl)) {
            data["CacheControl"] = [];
            for (let item of this.cacheControl)
                data["CacheControl"].push(item);
        }
        if (Array.isArray(this.connection)) {
            data["Connection"] = [];
            for (let item of this.connection)
                data["Connection"].push(item);
        }
        if (Array.isArray(this.contentDisposition)) {
            data["ContentDisposition"] = [];
            for (let item of this.contentDisposition)
                data["ContentDisposition"].push(item);
        }
        if (Array.isArray(this.contentEncoding)) {
            data["ContentEncoding"] = [];
            for (let item of this.contentEncoding)
                data["ContentEncoding"].push(item);
        }
        if (Array.isArray(this.contentLanguage)) {
            data["ContentLanguage"] = [];
            for (let item of this.contentLanguage)
                data["ContentLanguage"].push(item);
        }
        if (Array.isArray(this.contentLocation)) {
            data["ContentLocation"] = [];
            for (let item of this.contentLocation)
                data["ContentLocation"].push(item);
        }
        if (Array.isArray(this.contentMD5)) {
            data["ContentMD5"] = [];
            for (let item of this.contentMD5)
                data["ContentMD5"].push(item);
        }
        if (Array.isArray(this.contentRange)) {
            data["ContentRange"] = [];
            for (let item of this.contentRange)
                data["ContentRange"].push(item);
        }
        if (Array.isArray(this.contentSecurityPolicy)) {
            data["ContentSecurityPolicy"] = [];
            for (let item of this.contentSecurityPolicy)
                data["ContentSecurityPolicy"].push(item);
        }
        if (Array.isArray(this.contentSecurityPolicyReportOnly)) {
            data["ContentSecurityPolicyReportOnly"] = [];
            for (let item of this.contentSecurityPolicyReportOnly)
                data["ContentSecurityPolicyReportOnly"].push(item);
        }
        if (Array.isArray(this.contentType)) {
            data["ContentType"] = [];
            for (let item of this.contentType)
                data["ContentType"].push(item);
        }
        if (Array.isArray(this.correlationContext)) {
            data["CorrelationContext"] = [];
            for (let item of this.correlationContext)
                data["CorrelationContext"].push(item);
        }
        if (Array.isArray(this.cookie)) {
            data["Cookie"] = [];
            for (let item of this.cookie)
                data["Cookie"].push(item);
        }
        if (Array.isArray(this.date)) {
            data["Date"] = [];
            for (let item of this.date)
                data["Date"].push(item);
        }
        if (Array.isArray(this.eTag)) {
            data["ETag"] = [];
            for (let item of this.eTag)
                data["ETag"].push(item);
        }
        if (Array.isArray(this.expires)) {
            data["Expires"] = [];
            for (let item of this.expires)
                data["Expires"].push(item);
        }
        if (Array.isArray(this.expect)) {
            data["Expect"] = [];
            for (let item of this.expect)
                data["Expect"].push(item);
        }
        if (Array.isArray(this.from)) {
            data["From"] = [];
            for (let item of this.from)
                data["From"].push(item);
        }
        if (Array.isArray(this.grpcAcceptEncoding)) {
            data["GrpcAcceptEncoding"] = [];
            for (let item of this.grpcAcceptEncoding)
                data["GrpcAcceptEncoding"].push(item);
        }
        if (Array.isArray(this.grpcEncoding)) {
            data["GrpcEncoding"] = [];
            for (let item of this.grpcEncoding)
                data["GrpcEncoding"].push(item);
        }
        if (Array.isArray(this.grpcMessage)) {
            data["GrpcMessage"] = [];
            for (let item of this.grpcMessage)
                data["GrpcMessage"].push(item);
        }
        if (Array.isArray(this.grpcStatus)) {
            data["GrpcStatus"] = [];
            for (let item of this.grpcStatus)
                data["GrpcStatus"].push(item);
        }
        if (Array.isArray(this.grpcTimeout)) {
            data["GrpcTimeout"] = [];
            for (let item of this.grpcTimeout)
                data["GrpcTimeout"].push(item);
        }
        if (Array.isArray(this.host)) {
            data["Host"] = [];
            for (let item of this.host)
                data["Host"].push(item);
        }
        if (Array.isArray(this.keepAlive)) {
            data["KeepAlive"] = [];
            for (let item of this.keepAlive)
                data["KeepAlive"].push(item);
        }
        if (Array.isArray(this.ifMatch)) {
            data["IfMatch"] = [];
            for (let item of this.ifMatch)
                data["IfMatch"].push(item);
        }
        if (Array.isArray(this.ifModifiedSince)) {
            data["IfModifiedSince"] = [];
            for (let item of this.ifModifiedSince)
                data["IfModifiedSince"].push(item);
        }
        if (Array.isArray(this.ifNoneMatch)) {
            data["IfNoneMatch"] = [];
            for (let item of this.ifNoneMatch)
                data["IfNoneMatch"].push(item);
        }
        if (Array.isArray(this.ifRange)) {
            data["IfRange"] = [];
            for (let item of this.ifRange)
                data["IfRange"].push(item);
        }
        if (Array.isArray(this.ifUnmodifiedSince)) {
            data["IfUnmodifiedSince"] = [];
            for (let item of this.ifUnmodifiedSince)
                data["IfUnmodifiedSince"].push(item);
        }
        if (Array.isArray(this.lastModified)) {
            data["LastModified"] = [];
            for (let item of this.lastModified)
                data["LastModified"].push(item);
        }
        if (Array.isArray(this.link)) {
            data["Link"] = [];
            for (let item of this.link)
                data["Link"].push(item);
        }
        if (Array.isArray(this.location)) {
            data["Location"] = [];
            for (let item of this.location)
                data["Location"].push(item);
        }
        if (Array.isArray(this.maxForwards)) {
            data["MaxForwards"] = [];
            for (let item of this.maxForwards)
                data["MaxForwards"].push(item);
        }
        if (Array.isArray(this.origin)) {
            data["Origin"] = [];
            for (let item of this.origin)
                data["Origin"].push(item);
        }
        if (Array.isArray(this.pragma)) {
            data["Pragma"] = [];
            for (let item of this.pragma)
                data["Pragma"].push(item);
        }
        if (Array.isArray(this.proxyAuthenticate)) {
            data["ProxyAuthenticate"] = [];
            for (let item of this.proxyAuthenticate)
                data["ProxyAuthenticate"].push(item);
        }
        if (Array.isArray(this.proxyAuthorization)) {
            data["ProxyAuthorization"] = [];
            for (let item of this.proxyAuthorization)
                data["ProxyAuthorization"].push(item);
        }
        if (Array.isArray(this.proxyConnection)) {
            data["ProxyConnection"] = [];
            for (let item of this.proxyConnection)
                data["ProxyConnection"].push(item);
        }
        if (Array.isArray(this.range)) {
            data["Range"] = [];
            for (let item of this.range)
                data["Range"].push(item);
        }
        if (Array.isArray(this.referer)) {
            data["Referer"] = [];
            for (let item of this.referer)
                data["Referer"].push(item);
        }
        if (Array.isArray(this.retryAfter)) {
            data["RetryAfter"] = [];
            for (let item of this.retryAfter)
                data["RetryAfter"].push(item);
        }
        if (Array.isArray(this.requestId)) {
            data["RequestId"] = [];
            for (let item of this.requestId)
                data["RequestId"].push(item);
        }
        if (Array.isArray(this.secWebSocketAccept)) {
            data["SecWebSocketAccept"] = [];
            for (let item of this.secWebSocketAccept)
                data["SecWebSocketAccept"].push(item);
        }
        if (Array.isArray(this.secWebSocketKey)) {
            data["SecWebSocketKey"] = [];
            for (let item of this.secWebSocketKey)
                data["SecWebSocketKey"].push(item);
        }
        if (Array.isArray(this.secWebSocketProtocol)) {
            data["SecWebSocketProtocol"] = [];
            for (let item of this.secWebSocketProtocol)
                data["SecWebSocketProtocol"].push(item);
        }
        if (Array.isArray(this.secWebSocketVersion)) {
            data["SecWebSocketVersion"] = [];
            for (let item of this.secWebSocketVersion)
                data["SecWebSocketVersion"].push(item);
        }
        if (Array.isArray(this.secWebSocketExtensions)) {
            data["SecWebSocketExtensions"] = [];
            for (let item of this.secWebSocketExtensions)
                data["SecWebSocketExtensions"].push(item);
        }
        if (Array.isArray(this.server)) {
            data["Server"] = [];
            for (let item of this.server)
                data["Server"].push(item);
        }
        if (Array.isArray(this.setCookie)) {
            data["SetCookie"] = [];
            for (let item of this.setCookie)
                data["SetCookie"].push(item);
        }
        if (Array.isArray(this.strictTransportSecurity)) {
            data["StrictTransportSecurity"] = [];
            for (let item of this.strictTransportSecurity)
                data["StrictTransportSecurity"].push(item);
        }
        if (Array.isArray(this.tE)) {
            data["TE"] = [];
            for (let item of this.tE)
                data["TE"].push(item);
        }
        if (Array.isArray(this.trailer)) {
            data["Trailer"] = [];
            for (let item of this.trailer)
                data["Trailer"].push(item);
        }
        if (Array.isArray(this.transferEncoding)) {
            data["TransferEncoding"] = [];
            for (let item of this.transferEncoding)
                data["TransferEncoding"].push(item);
        }
        if (Array.isArray(this.translate)) {
            data["Translate"] = [];
            for (let item of this.translate)
                data["Translate"].push(item);
        }
        if (Array.isArray(this.traceParent)) {
            data["TraceParent"] = [];
            for (let item of this.traceParent)
                data["TraceParent"].push(item);
        }
        if (Array.isArray(this.traceState)) {
            data["TraceState"] = [];
            for (let item of this.traceState)
                data["TraceState"].push(item);
        }
        if (Array.isArray(this.upgrade)) {
            data["Upgrade"] = [];
            for (let item of this.upgrade)
                data["Upgrade"].push(item);
        }
        if (Array.isArray(this.upgradeInsecureRequests)) {
            data["UpgradeInsecureRequests"] = [];
            for (let item of this.upgradeInsecureRequests)
                data["UpgradeInsecureRequests"].push(item);
        }
        if (Array.isArray(this.userAgent)) {
            data["UserAgent"] = [];
            for (let item of this.userAgent)
                data["UserAgent"].push(item);
        }
        if (Array.isArray(this.vary)) {
            data["Vary"] = [];
            for (let item of this.vary)
                data["Vary"].push(item);
        }
        if (Array.isArray(this.via)) {
            data["Via"] = [];
            for (let item of this.via)
                data["Via"].push(item);
        }
        if (Array.isArray(this.warning)) {
            data["Warning"] = [];
            for (let item of this.warning)
                data["Warning"].push(item);
        }
        if (Array.isArray(this.webSocketSubProtocols)) {
            data["WebSocketSubProtocols"] = [];
            for (let item of this.webSocketSubProtocols)
                data["WebSocketSubProtocols"].push(item);
        }
        if (Array.isArray(this.wWWAuthenticate)) {
            data["WWWAuthenticate"] = [];
            for (let item of this.wWWAuthenticate)
                data["WWWAuthenticate"].push(item);
        }
        if (Array.isArray(this.xContentTypeOptions)) {
            data["XContentTypeOptions"] = [];
            for (let item of this.xContentTypeOptions)
                data["XContentTypeOptions"].push(item);
        }
        if (Array.isArray(this.xFrameOptions)) {
            data["XFrameOptions"] = [];
            for (let item of this.xFrameOptions)
                data["XFrameOptions"].push(item);
        }
        if (Array.isArray(this.xPoweredBy)) {
            data["XPoweredBy"] = [];
            for (let item of this.xPoweredBy)
                data["XPoweredBy"].push(item);
        }
        if (Array.isArray(this.xRequestedWith)) {
            data["XRequestedWith"] = [];
            for (let item of this.xRequestedWith)
                data["XRequestedWith"].push(item);
        }
        if (Array.isArray(this.xUACompatible)) {
            data["XUACompatible"] = [];
            for (let item of this.xUACompatible)
                data["XUACompatible"].push(item);
        }
        if (Array.isArray(this.xXSSProtection)) {
            data["XXSSProtection"] = [];
            for (let item of this.xXSSProtection)
                data["XXSSProtection"].push(item);
        }
        return data;
    }
}

export interface IIHeaderDictionary {
    item?: any[];
    contentLength?: number | undefined;
    accept?: any[];
    acceptCharset?: any[];
    acceptEncoding?: any[];
    acceptLanguage?: any[];
    acceptRanges?: any[];
    accessControlAllowCredentials?: any[];
    accessControlAllowHeaders?: any[];
    accessControlAllowMethods?: any[];
    accessControlAllowOrigin?: any[];
    accessControlExposeHeaders?: any[];
    accessControlMaxAge?: any[];
    accessControlRequestHeaders?: any[];
    accessControlRequestMethod?: any[];
    age?: any[];
    allow?: any[];
    altSvc?: any[];
    authorization?: any[];
    baggage?: any[];
    cacheControl?: any[];
    connection?: any[];
    contentDisposition?: any[];
    contentEncoding?: any[];
    contentLanguage?: any[];
    contentLocation?: any[];
    contentMD5?: any[];
    contentRange?: any[];
    contentSecurityPolicy?: any[];
    contentSecurityPolicyReportOnly?: any[];
    contentType?: any[];
    correlationContext?: any[];
    cookie?: any[];
    date?: any[];
    eTag?: any[];
    expires?: any[];
    expect?: any[];
    from?: any[];
    grpcAcceptEncoding?: any[];
    grpcEncoding?: any[];
    grpcMessage?: any[];
    grpcStatus?: any[];
    grpcTimeout?: any[];
    host?: any[];
    keepAlive?: any[];
    ifMatch?: any[];
    ifModifiedSince?: any[];
    ifNoneMatch?: any[];
    ifRange?: any[];
    ifUnmodifiedSince?: any[];
    lastModified?: any[];
    link?: any[];
    location?: any[];
    maxForwards?: any[];
    origin?: any[];
    pragma?: any[];
    proxyAuthenticate?: any[];
    proxyAuthorization?: any[];
    proxyConnection?: any[];
    range?: any[];
    referer?: any[];
    retryAfter?: any[];
    requestId?: any[];
    secWebSocketAccept?: any[];
    secWebSocketKey?: any[];
    secWebSocketProtocol?: any[];
    secWebSocketVersion?: any[];
    secWebSocketExtensions?: any[];
    server?: any[];
    setCookie?: any[];
    strictTransportSecurity?: any[];
    tE?: any[];
    trailer?: any[];
    transferEncoding?: any[];
    translate?: any[];
    traceParent?: any[];
    traceState?: any[];
    upgrade?: any[];
    upgradeInsecureRequests?: any[];
    userAgent?: any[];
    vary?: any[];
    via?: any[];
    warning?: any[];
    webSocketSubProtocols?: any[];
    wWWAuthenticate?: any[];
    xContentTypeOptions?: any[];
    xFrameOptions?: any[];
    xPoweredBy?: any[];
    xRequestedWith?: any[];
    xUACompatible?: any[];
    xXSSProtection?: any[];
}

/** Request body for importing an entry. */
export class ImportEntryRequest implements IImportEntryRequest {
    /** The name of the file. */
    name?: string | undefined;
    /** Indicates if the entry should be automatically renamed if an entry already exists with the given name in the folder. The default value is false. */
    autoRename?: boolean;
    pdfOptions?: PdfImportOptions | undefined;
    /** Determines whether the document should be imported as an electronic document. If set to true, the documented is imported as an electronic document. If set to false, the documented is converted to Laserfiche pages. The default value is false. */
    importAsElectronicDocument?: boolean;
    metadata?: ImportAsyncMetadata | undefined;
    /** The name of the volume to use. Will use the default parent entry volume if not specified. This is ignored in Laserfiche Cloud. */
    volumeName?: string | undefined;

    
    
    constructor(data?: IImportEntryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.autoRename = false;
            this.importAsElectronicDocument = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.autoRename = _data["autoRename"] !== undefined ? _data["autoRename"] : false;
            this.pdfOptions = _data["pdfOptions"] ? PdfImportOptions.fromJS(_data["pdfOptions"]) : <any>undefined;
            this.importAsElectronicDocument = _data["importAsElectronicDocument"] !== undefined ? _data["importAsElectronicDocument"] : false;
            this.metadata = _data["metadata"] ? ImportAsyncMetadata.fromJS(_data["metadata"]) : <any>undefined;
            this.volumeName = _data["volumeName"];
        }
    }

    static fromJS(data: any): ImportEntryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ImportEntryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["autoRename"] = this.autoRename;
        data["pdfOptions"] = this.pdfOptions ? this.pdfOptions.toJSON() : <any>undefined;
        data["importAsElectronicDocument"] = this.importAsElectronicDocument;
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        data["volumeName"] = this.volumeName;
        return data;
    }
}

/** Request body for importing an entry. */
export interface IImportEntryRequest {
    /** The name of the file. */
    name?: string | undefined;
    /** Indicates if the entry should be automatically renamed if an entry already exists with the given name in the folder. The default value is false. */
    autoRename?: boolean;
    pdfOptions?: PdfImportOptions | undefined;
    /** Determines whether the document should be imported as an electronic document. If set to true, the documented is imported as an electronic document. If set to false, the documented is converted to Laserfiche pages. The default value is false. */
    importAsElectronicDocument?: boolean;
    metadata?: ImportAsyncMetadata | undefined;
    /** The name of the volume to use. Will use the default parent entry volume if not specified. This is ignored in Laserfiche Cloud. */
    volumeName?: string | undefined;
}

/** Response containing a link to download the exported entry. */
export class ExportEntryResponse implements IExportEntryResponse {
    value?: string;

    
    
    constructor(data?: IExportEntryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ExportEntryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ExportEntryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data;
    }
}

/** Response containing a link to download the exported entry. */
export interface IExportEntryResponse {
    value?: string;
}

/** Request body for exporting an entry. */
export class ExportEntryRequest implements IExportEntryRequest {
    /** The reason id for this audit event. */
    auditReasonId?: number;
    /** The comment for this audit event. */
    auditReasonComment?: string | undefined;
    /** The part of the document to export. Options include: Image, Text, Edoc. */
    part!: ExportEntryRequestPart;
    /** The options applied when exporting as Image. */
    imageOptions?: ExportEntryRequestImageOptions | undefined;
    /** The options applied when exporting as Text. */
    textOptions?: ExportEntryRequestTextOptions | undefined;

    
    
    constructor(data?: IExportEntryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.auditReasonComment = "";
        }
    }

    init(_data?: any) {
        if (_data) {
            this.auditReasonId = _data["auditReasonId"];
            this.auditReasonComment = _data["auditReasonComment"] !== undefined ? _data["auditReasonComment"] : "";
            this.part = _data["part"];
            this.imageOptions = _data["imageOptions"] ? ExportEntryRequestImageOptions.fromJS(_data["imageOptions"]) : <any>undefined;
            this.textOptions = _data["textOptions"] ? ExportEntryRequestTextOptions.fromJS(_data["textOptions"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ExportEntryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ExportEntryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["auditReasonId"] = this.auditReasonId;
        data["auditReasonComment"] = this.auditReasonComment;
        data["part"] = this.part;
        data["imageOptions"] = this.imageOptions ? this.imageOptions.toJSON() : <any>undefined;
        data["textOptions"] = this.textOptions ? this.textOptions.toJSON() : <any>undefined;
        return data;
    }
}

/** Request body for exporting an entry. */
export interface IExportEntryRequest {
    /** The reason id for this audit event. */
    auditReasonId?: number;
    /** The comment for this audit event. */
    auditReasonComment?: string | undefined;
    /** The part of the document to export. Options include: Image, Text, Edoc. */
    part: ExportEntryRequestPart;
    /** The options applied when exporting as Image. */
    imageOptions?: ExportEntryRequestImageOptions | undefined;
    /** The options applied when exporting as Text. */
    textOptions?: ExportEntryRequestTextOptions | undefined;
}

/** Response containing an entry or ancestor entry found by entry path. */
export class GetEntryByPathResponse implements IGetEntryByPathResponse {
    /** The entry found by path. This property is set if entry is found. */
    entry?: Entry | undefined;
    /** The closest entry ancestor. This property is set if entry is not found and fallbackToClosestAncestor is set to true. */
    ancestorEntry?: Entry | undefined;

    
    
    constructor(data?: IGetEntryByPathResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entry = _data["entry"] ? Entry.fromJS(_data["entry"]) : <any>undefined;
            this.ancestorEntry = _data["ancestorEntry"] ? Entry.fromJS(_data["ancestorEntry"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetEntryByPathResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetEntryByPathResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entry"] = this.entry ? this.entry.toJSON() : <any>undefined;
        data["ancestorEntry"] = this.ancestorEntry ? this.ancestorEntry.toJSON() : <any>undefined;
        return data;
    }
}

/** Response containing an entry or ancestor entry found by entry path. */
export interface IGetEntryByPathResponse {
    /** The entry found by path. This property is set if entry is found. */
    entry?: Entry | undefined;
    /** The closest entry ancestor. This property is set if entry is not found and fallbackToClosestAncestor is set to true. */
    ancestorEntry?: Entry | undefined;
}

/** Request body for updating an entry. */
export class UpdateEntryRequest implements IUpdateEntryRequest {
    /** The ID of the parent entry that the entry will be moved to. */
    parentId?: number | undefined;
    /** The name that will be assigned to the entry. */
    name?: string | undefined;
    /** Indicates if the entry should be automatically renamed if an entry already exists with the given name in the folder. The default value is false. */
    autoRename?: boolean;

    
    
    constructor(data?: IUpdateEntryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.autoRename = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.name = _data["name"];
            this.autoRename = _data["autoRename"] !== undefined ? _data["autoRename"] : false;
        }
    }

    static fromJS(data: any): UpdateEntryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEntryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["name"] = this.name;
        data["autoRename"] = this.autoRename;
        return data;
    }
}

/** Request body for updating an entry. */
export interface IUpdateEntryRequest {
    /** The ID of the parent entry that the entry will be moved to. */
    parentId?: number | undefined;
    /** The name that will be assigned to the entry. */
    name?: string | undefined;
    /** Indicates if the entry should be automatically renamed if an entry already exists with the given name in the folder. The default value is false. */
    autoRename?: boolean;
}

/** Response containing a collection of Entry. */
export class EntryCollectionResponse implements IEntryCollectionResponse {
    /** A URL to retrieve the next page of the requested collection. */
    odataNextLink?: string | undefined;
    /** The total count of items within a collection. */
    odataCount?: number | undefined;
    value?: Entry[];

    
    
    constructor(data?: IEntryCollectionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.odataNextLink = _data["@odata.nextLink"];
            this.odataCount = _data["@odata.count"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(Entry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EntryCollectionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EntryCollectionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["@odata.nextLink"] = this.odataNextLink;
        data["@odata.count"] = this.odataCount;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

/** Response containing a collection of Entry. */
export interface IEntryCollectionResponse {
    /** A URL to retrieve the next page of the requested collection. */
    odataNextLink?: string | undefined;
    /** The total count of items within a collection. */
    odataCount?: number | undefined;
    value?: Entry[];
}

/** Response containing a collection of Field. */
export class FieldCollectionResponse implements IFieldCollectionResponse {
    /** A URL to retrieve the next page of the requested collection. */
    odataNextLink?: string | undefined;
    /** The total count of items within a collection. */
    odataCount?: number | undefined;
    value?: Field[];

    
    
    constructor(data?: IFieldCollectionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.odataNextLink = _data["@odata.nextLink"];
            this.odataCount = _data["@odata.count"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(Field.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FieldCollectionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new FieldCollectionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["@odata.nextLink"] = this.odataNextLink;
        data["@odata.count"] = this.odataCount;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

/** Response containing a collection of Field. */
export interface IFieldCollectionResponse {
    /** A URL to retrieve the next page of the requested collection. */
    odataNextLink?: string | undefined;
    /** The total count of items within a collection. */
    odataCount?: number | undefined;
    value?: Field[];
}

/** Request body for setting fields on an entry. */
export class SetFieldsRequest implements ISetFieldsRequest {
    /** The fields that will be assigned to the entry. */
    fields?: FieldToUpdate[] | undefined;

    
    
    constructor(data?: ISetFieldsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(FieldToUpdate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SetFieldsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SetFieldsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        return data;
    }
}

/** Request body for setting fields on an entry. */
export interface ISetFieldsRequest {
    /** The fields that will be assigned to the entry. */
    fields?: FieldToUpdate[] | undefined;
}

/** Response containing a collection of Tag. */
export class TagCollectionResponse implements ITagCollectionResponse {
    /** A URL to retrieve the next page of the requested collection. */
    odataNextLink?: string | undefined;
    /** The total count of items within a collection. */
    odataCount?: number | undefined;
    value?: Tag[];

    
    
    constructor(data?: ITagCollectionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.odataNextLink = _data["@odata.nextLink"];
            this.odataCount = _data["@odata.count"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(Tag.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TagCollectionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TagCollectionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["@odata.nextLink"] = this.odataNextLink;
        data["@odata.count"] = this.odataCount;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

/** Response containing a collection of Tag. */
export interface ITagCollectionResponse {
    /** A URL to retrieve the next page of the requested collection. */
    odataNextLink?: string | undefined;
    /** The total count of items within a collection. */
    odataCount?: number | undefined;
    value?: Tag[];
}

/** Represents a tag set on an entry. */
export class Tag implements ITag {
    /** The ID of the tag definition. */
    id?: number;
    /** The name of the tag definition. */
    name?: string | undefined;
    /** The localized name of the tag definition. */
    displayName?: string | undefined;
    /** The description of the tag definition. */
    description?: string | undefined;
    /** A boolean indicating whether or not the tag definition is classified as a security tag (true) or an informational tag (false). */
    isSecure?: boolean;
    /** The watermark properties associated with the tag definition. */
    watermark?: TagDefinitionWatermark | undefined;

    
    
    constructor(data?: ITag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isSecure = _data["isSecure"];
            this.watermark = _data["watermark"] ? TagDefinitionWatermark.fromJS(_data["watermark"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Tag {
        data = typeof data === 'object' ? data : {};
        let result = new Tag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isSecure"] = this.isSecure;
        data["watermark"] = this.watermark ? this.watermark.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents a tag set on an entry. */
export interface ITag {
    /** The ID of the tag definition. */
    id?: number;
    /** The name of the tag definition. */
    name?: string | undefined;
    /** The localized name of the tag definition. */
    displayName?: string | undefined;
    /** The description of the tag definition. */
    description?: string | undefined;
    /** A boolean indicating whether or not the tag definition is classified as a security tag (true) or an informational tag (false). */
    isSecure?: boolean;
    /** The watermark properties associated with the tag definition. */
    watermark?: TagDefinitionWatermark | undefined;
}

/** Represents a watermark associated with a tag defintion. */
export class TagDefinitionWatermark implements ITagDefinitionWatermark {
    /** The watermark text associated with the tag defintion. */
    text?: string | undefined;
    /** The percentage of the page that the watermark associated with the tag definition spans on. */
    pageSpanPercentage?: number;
    /** The position of the watermark on the page. */
    position?: WatermarkPosition;
    /** The rotation angle, in degrees, of the watermark associated with the tag definition. */
    rotationAngle?: number;
    /** A boolean indicating whether or not the watermark associated with the tag is mandatory. */
    isMandatory?: boolean;
    /** The opacity of the watermark associated with the tag definition. Valid value ranges from 0 to 100, with -1 as the default values. */
    opacity?: number;

    
    
    constructor(data?: ITagDefinitionWatermark) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.pageSpanPercentage = _data["pageSpanPercentage"];
            this.position = _data["position"];
            this.rotationAngle = _data["rotationAngle"];
            this.isMandatory = _data["isMandatory"];
            this.opacity = _data["opacity"];
        }
    }

    static fromJS(data: any): TagDefinitionWatermark {
        data = typeof data === 'object' ? data : {};
        let result = new TagDefinitionWatermark();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["pageSpanPercentage"] = this.pageSpanPercentage;
        data["position"] = this.position;
        data["rotationAngle"] = this.rotationAngle;
        data["isMandatory"] = this.isMandatory;
        data["opacity"] = this.opacity;
        return data;
    }
}

/** Represents a watermark associated with a tag defintion. */
export interface ITagDefinitionWatermark {
    /** The watermark text associated with the tag defintion. */
    text?: string | undefined;
    /** The percentage of the page that the watermark associated with the tag definition spans on. */
    pageSpanPercentage?: number;
    /** The position of the watermark on the page. */
    position?: WatermarkPosition;
    /** The rotation angle, in degrees, of the watermark associated with the tag definition. */
    rotationAngle?: number;
    /** A boolean indicating whether or not the watermark associated with the tag is mandatory. */
    isMandatory?: boolean;
    /** The opacity of the watermark associated with the tag definition. Valid value ranges from 0 to 100, with -1 as the default values. */
    opacity?: number;
}

/** Request body for setting tags on an entry. */
export class SetTagsRequest implements ISetTagsRequest {
    /** The tag names to assign to the entry. */
    tags?: string[] | undefined;

    
    
    constructor(data?: ISetTagsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): SetTagsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SetTagsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }
}

/** Request body for setting tags on an entry. */
export interface ISetTagsRequest {
    /** The tag names to assign to the entry. */
    tags?: string[] | undefined;
}

/** Response containing a collection of Link. */
export class LinkCollectionResponse implements ILinkCollectionResponse {
    /** A URL to retrieve the next page of the requested collection. */
    odataNextLink?: string | undefined;
    /** The total count of items within a collection. */
    odataCount?: number | undefined;
    value?: Link[];

    
    
    constructor(data?: ILinkCollectionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.odataNextLink = _data["@odata.nextLink"];
            this.odataCount = _data["@odata.count"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(Link.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LinkCollectionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LinkCollectionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["@odata.nextLink"] = this.odataNextLink;
        data["@odata.count"] = this.odataCount;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

/** Response containing a collection of Link. */
export interface ILinkCollectionResponse {
    /** A URL to retrieve the next page of the requested collection. */
    odataNextLink?: string | undefined;
    /** The total count of items within a collection. */
    odataCount?: number | undefined;
    value?: Link[];
}

/** Represents a link between a source entry and a target entry. */
export class Link implements ILink {
    /** The ID of the represented link. */
    id?: number;
    /** The description for the represented link. */
    description?: string | undefined;
    /** The ID of the source entry of the represented link. */
    sourceId?: number;
    /** The full path to the source entry of the represented link. */
    sourceFullPath?: string | undefined;
    /** The label for the source entry in the link definition. */
    sourceLabel?: string | undefined;
    /** The navigation link to the source entry. */
    sourceLink?: string | undefined;
    /** The ID of the target entry of the represented link. */
    targetId?: number;
    /** The full path to the target entry of the represented link. */
    targetFullPath?: string | undefined;
    /** The label for the target entry in the link definition. */
    targetLabel?: string | undefined;
    /** The navigation link to the target entry. */
    targetLink?: string | undefined;
    /** The ID of the link definition. */
    linkDefinitionId?: number;
    /** The description of the link definition. */
    linkDefinitionDescription?: string | undefined;
    /** The custom properties for the represented link. */
    customProperties?: { [key: string]: string; } | undefined;

    
    
    constructor(data?: ILink) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.description = _data["description"];
            this.sourceId = _data["sourceId"];
            this.sourceFullPath = _data["sourceFullPath"];
            this.sourceLabel = _data["sourceLabel"];
            this.sourceLink = _data["sourceLink"];
            this.targetId = _data["targetId"];
            this.targetFullPath = _data["targetFullPath"];
            this.targetLabel = _data["targetLabel"];
            this.targetLink = _data["targetLink"];
            this.linkDefinitionId = _data["linkDefinitionId"];
            this.linkDefinitionDescription = _data["linkDefinitionDescription"];
            if (_data["customProperties"]) {
                this.customProperties = {} as any;
                for (let key in _data["customProperties"]) {
                    if (_data["customProperties"].hasOwnProperty(key))
                        (<any>this.customProperties)![key] = _data["customProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): Link {
        data = typeof data === 'object' ? data : {};
        let result = new Link();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["description"] = this.description;
        data["sourceId"] = this.sourceId;
        data["sourceFullPath"] = this.sourceFullPath;
        data["sourceLabel"] = this.sourceLabel;
        data["sourceLink"] = this.sourceLink;
        data["targetId"] = this.targetId;
        data["targetFullPath"] = this.targetFullPath;
        data["targetLabel"] = this.targetLabel;
        data["targetLink"] = this.targetLink;
        data["linkDefinitionId"] = this.linkDefinitionId;
        data["linkDefinitionDescription"] = this.linkDefinitionDescription;
        if (this.customProperties) {
            data["customProperties"] = {};
            for (let key in this.customProperties) {
                if (this.customProperties.hasOwnProperty(key))
                    (<any>data["customProperties"])[key] = this.customProperties[key];
            }
        }
        return data;
    }
}

/** Represents a link between a source entry and a target entry. */
export interface ILink {
    /** The ID of the represented link. */
    id?: number;
    /** The description for the represented link. */
    description?: string | undefined;
    /** The ID of the source entry of the represented link. */
    sourceId?: number;
    /** The full path to the source entry of the represented link. */
    sourceFullPath?: string | undefined;
    /** The label for the source entry in the link definition. */
    sourceLabel?: string | undefined;
    /** The navigation link to the source entry. */
    sourceLink?: string | undefined;
    /** The ID of the target entry of the represented link. */
    targetId?: number;
    /** The full path to the target entry of the represented link. */
    targetFullPath?: string | undefined;
    /** The label for the target entry in the link definition. */
    targetLabel?: string | undefined;
    /** The navigation link to the target entry. */
    targetLink?: string | undefined;
    /** The ID of the link definition. */
    linkDefinitionId?: number;
    /** The description of the link definition. */
    linkDefinitionDescription?: string | undefined;
    /** The custom properties for the represented link. */
    customProperties?: { [key: string]: string; } | undefined;
}

/** Request body for setting links on an entry. */
export class SetLinksRequest implements ISetLinksRequest {
    /** The links that will be assigned to the entry. */
    links?: LinkToUpdate[] | undefined;

    
    
    constructor(data?: ISetLinksRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(LinkToUpdate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SetLinksRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SetLinksRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        return data;
    }
}

/** Request body for setting links on an entry. */
export interface ISetLinksRequest {
    /** The links that will be assigned to the entry. */
    links?: LinkToUpdate[] | undefined;
}

/** Request body for copying an entry. */
export class CopyEntryRequest implements ICopyEntryRequest {
    /** The name of the entry. */
    name!: string;
    /** Indicates if the entry should be automatically renamed if an entry already exists with the given name in the folder. The default value is false. */
    autoRename?: boolean;
    /** The SourceId is needed for some operations that require a source/destination. One example is the Copy operation. */
    sourceId?: number;
    /** The name of the volume to use. Will use the default parent entry volume if not specified. This is ignored in Laserfiche Cloud. */
    volumeName?: string | undefined;

    
    
    constructor(data?: ICopyEntryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.autoRename = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.autoRename = _data["autoRename"] !== undefined ? _data["autoRename"] : false;
            this.sourceId = _data["sourceId"];
            this.volumeName = _data["volumeName"];
        }
    }

    static fromJS(data: any): CopyEntryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CopyEntryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["autoRename"] = this.autoRename;
        data["sourceId"] = this.sourceId;
        data["volumeName"] = this.volumeName;
        return data;
    }
}

/** Request body for copying an entry. */
export interface ICopyEntryRequest {
    /** The name of the entry. */
    name: string;
    /** Indicates if the entry should be automatically renamed if an entry already exists with the given name in the folder. The default value is false. */
    autoRename?: boolean;
    /** The SourceId is needed for some operations that require a source/destination. One example is the Copy operation. */
    sourceId?: number;
    /** The name of the volume to use. Will use the default parent entry volume if not specified. This is ignored in Laserfiche Cloud. */
    volumeName?: string | undefined;
}

/** Request body for creating an entry. */
export class CreateEntryRequest implements ICreateEntryRequest {
    /** The name of the entry. */
    name!: string;
    /** Indicates if the entry should be automatically renamed if an entry already exists with the given name in the folder. The default value is false. */
    autoRename?: boolean;
    /** The type of the entry. */
    entryType!: CreateEntryRequestEntryType;
    /** The TargetId is only needed for creating a shortcut. This will be the entry ID of the shortcut target. */
    targetId?: number;
    /** The name of the volume to use. Will use the default parent entry volume if not specified. This is ignored in Laserfiche Cloud. */
    volumeName?: string | undefined;

    
    
    constructor(data?: ICreateEntryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.autoRename = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.autoRename = _data["autoRename"] !== undefined ? _data["autoRename"] : false;
            this.entryType = _data["entryType"];
            this.targetId = _data["targetId"];
            this.volumeName = _data["volumeName"];
        }
    }

    static fromJS(data: any): CreateEntryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEntryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["autoRename"] = this.autoRename;
        data["entryType"] = this.entryType;
        data["targetId"] = this.targetId;
        data["volumeName"] = this.volumeName;
        return data;
    }
}

/** Request body for creating an entry. */
export interface ICreateEntryRequest {
    /** The name of the entry. */
    name: string;
    /** Indicates if the entry should be automatically renamed if an entry already exists with the given name in the folder. The default value is false. */
    autoRename?: boolean;
    /** The type of the entry. */
    entryType: CreateEntryRequestEntryType;
    /** The TargetId is only needed for creating a shortcut. This will be the entry ID of the shortcut target. */
    targetId?: number;
    /** The name of the volume to use. Will use the default parent entry volume if not specified. This is ignored in Laserfiche Cloud. */
    volumeName?: string | undefined;
}

export enum CreateEntryRequestEntryType {
    Folder = "Folder",
    Shortcut = "Shortcut",
}

/** Request body for listing dynamic field values for an entry. */
export class ListDynamicFieldValuesRequest implements IListDynamicFieldValuesRequest {
    /** The template id. */
    templateId!: number;
    /** The dynamic fields. */
    fieldValues?: { [key: string]: string; } | undefined;

    
    
    constructor(data?: IListDynamicFieldValuesRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.templateId = _data["templateId"];
            if (_data["fieldValues"]) {
                this.fieldValues = {} as any;
                for (let key in _data["fieldValues"]) {
                    if (_data["fieldValues"].hasOwnProperty(key))
                        (<any>this.fieldValues)![key] = _data["fieldValues"][key];
                }
            }
        }
    }

    static fromJS(data: any): ListDynamicFieldValuesRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListDynamicFieldValuesRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateId"] = this.templateId;
        if (this.fieldValues) {
            data["fieldValues"] = {};
            for (let key in this.fieldValues) {
                if (this.fieldValues.hasOwnProperty(key))
                    (<any>data["fieldValues"])[key] = this.fieldValues[key];
            }
        }
        return data;
    }
}

/** Request body for listing dynamic field values for an entry. */
export interface IListDynamicFieldValuesRequest {
    /** The template id. */
    templateId: number;
    /** The dynamic fields. */
    fieldValues?: { [key: string]: string; } | undefined;
}

/** Request body for setting a template and template fields on an entry. */
export class SetTemplateRequest implements ISetTemplateRequest {
    /** The template that will be assigned to the entry. */
    templateName!: string;
    /** The template fields that will be assigned to the entry. */
    fields?: FieldToUpdate[] | undefined;

    
    
    constructor(data?: ISetTemplateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.templateName = _data["templateName"];
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(FieldToUpdate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SetTemplateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SetTemplateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateName"] = this.templateName;
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        return data;
    }
}

/** Request body for setting a template and template fields on an entry. */
export interface ISetTemplateRequest {
    /** The template that will be assigned to the entry. */
    templateName: string;
    /** The template fields that will be assigned to the entry. */
    fields?: FieldToUpdate[] | undefined;
}

/** Response containing a collection of Repository. */
export class RepositoryCollectionResponse implements IRepositoryCollectionResponse {
    value?: Repository[];

    
    
    constructor(data?: IRepositoryCollectionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(Repository.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RepositoryCollectionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RepositoryCollectionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

/** Response containing a collection of Repository. */
export interface IRepositoryCollectionResponse {
    value?: Repository[];
}

/** Represents a Laserfiche repository. */
export class Repository implements IRepository {
    /** The repository id. */
    id?: string | undefined;
    /** The repository name. */
    name?: string | undefined;
    /** The corresponding repository Web Client url. */
    webClientUrl?: string | undefined;

    
    
    constructor(data?: IRepository) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.webClientUrl = _data["webClientUrl"];
        }
    }

    static fromJS(data: any): Repository {
        data = typeof data === 'object' ? data : {};
        let result = new Repository();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["webClientUrl"] = this.webClientUrl;
        return data;
    }
}

/** Represents a Laserfiche repository. */
export interface IRepository {
    /** The repository id. */
    id?: string | undefined;
    /** The repository name. */
    name?: string | undefined;
    /** The corresponding repository Web Client url. */
    webClientUrl?: string | undefined;
}

/** Request body for starting an asynchronous search entry task. */
export class StartSearchEntryRequest implements IStartSearchEntryRequest {
    /** Search command for advanced search */
    searchCommand!: string;
    /** Fuzzy type (None, Percentage, or NumberOfLetters) */
    fuzzyType?: FuzzyType;
    /** Fuzzy factor (percentage as int or int value) */
    fuzzyFactor?: number;

    
    
    constructor(data?: IStartSearchEntryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchCommand = _data["searchCommand"];
            this.fuzzyType = _data["fuzzyType"];
            this.fuzzyFactor = _data["fuzzyFactor"];
        }
    }

    static fromJS(data: any): StartSearchEntryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new StartSearchEntryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchCommand"] = this.searchCommand;
        data["fuzzyType"] = this.fuzzyType;
        data["fuzzyFactor"] = this.fuzzyFactor;
        return data;
    }
}

/** Request body for starting an asynchronous search entry task. */
export interface IStartSearchEntryRequest {
    /** Search command for advanced search */
    searchCommand: string;
    /** Fuzzy type (None, Percentage, or NumberOfLetters) */
    fuzzyType?: FuzzyType;
    /** Fuzzy factor (percentage as int or int value) */
    fuzzyFactor?: number;
}

export enum FuzzyType {
    None = "None",
    Percentage = "Percentage",
    NumberOfLetters = "NumberOfLetters",
}

/** Response containing a collection of SearchContextHit. */
export class SearchContextHitCollectionResponse implements ISearchContextHitCollectionResponse {
    /** A URL to retrieve the next page of the requested collection. */
    odataNextLink?: string | undefined;
    /** The total count of items within a collection. */
    odataCount?: number | undefined;
    value?: SearchContextHit[];

    
    
    constructor(data?: ISearchContextHitCollectionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.odataNextLink = _data["@odata.nextLink"];
            this.odataCount = _data["@odata.count"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(SearchContextHit.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SearchContextHitCollectionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SearchContextHitCollectionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["@odata.nextLink"] = this.odataNextLink;
        data["@odata.count"] = this.odataCount;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

/** Response containing a collection of SearchContextHit. */
export interface ISearchContextHitCollectionResponse {
    /** A URL to retrieve the next page of the requested collection. */
    odataNextLink?: string | undefined;
    /** The total count of items within a collection. */
    odataCount?: number | undefined;
    value?: SearchContextHit[];
}

/** Represents a context hit for a search result. */
export class SearchContextHit implements ISearchContextHit {
    hitType?: HitType;
    /** A boolean indicating if this context hit occurs on an annotation. */
    isAnnotationHit?: boolean;
    /** The ID of the annotation that the context hit is in. */
    annotationId?: number;
    /** The page number in the document of the search hit's context. */
    pageNumber?: number;
    /** The offset from the beginning of the page of the starting character of the search hit's context line. */
    pageOffset?: number;
    /** The line of context for the search hit. */
    context?: string | undefined;
    /** The character offset from the beginning of the context line of the start of the first highlight. */
    highlight1Offset?: number;
    /** The length of the first highlight in characters. */
    highlight1Length?: number;
    /** The character offset from the beginning of the context line of the start of the second highlight. */
    highlight2Offset?: number;
    /** The length of the second highlight in characters. */
    highlight2Length?: number;
    /** The number of words in the context hit. */
    hitWidth?: number;
    /** The number of hits in the electronic document. */
    edocHitCount?: number;
    /** The number of hits in the template. */
    fieldHitCount?: number;
    /** The name of a template field containing the hit. */
    fieldName?: string | undefined;
    /** The hit number. */
    hitNumber?: number;

    
    
    constructor(data?: ISearchContextHit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hitType = _data["hitType"];
            this.isAnnotationHit = _data["isAnnotationHit"];
            this.annotationId = _data["annotationId"];
            this.pageNumber = _data["pageNumber"];
            this.pageOffset = _data["pageOffset"];
            this.context = _data["context"];
            this.highlight1Offset = _data["highlight1Offset"];
            this.highlight1Length = _data["highlight1Length"];
            this.highlight2Offset = _data["highlight2Offset"];
            this.highlight2Length = _data["highlight2Length"];
            this.hitWidth = _data["hitWidth"];
            this.edocHitCount = _data["edocHitCount"];
            this.fieldHitCount = _data["fieldHitCount"];
            this.fieldName = _data["fieldName"];
            this.hitNumber = _data["hitNumber"];
        }
    }

    static fromJS(data: any): SearchContextHit {
        data = typeof data === 'object' ? data : {};
        let result = new SearchContextHit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hitType"] = this.hitType;
        data["isAnnotationHit"] = this.isAnnotationHit;
        data["annotationId"] = this.annotationId;
        data["pageNumber"] = this.pageNumber;
        data["pageOffset"] = this.pageOffset;
        data["context"] = this.context;
        data["highlight1Offset"] = this.highlight1Offset;
        data["highlight1Length"] = this.highlight1Length;
        data["highlight2Offset"] = this.highlight2Offset;
        data["highlight2Length"] = this.highlight2Length;
        data["hitWidth"] = this.hitWidth;
        data["edocHitCount"] = this.edocHitCount;
        data["fieldHitCount"] = this.fieldHitCount;
        data["fieldName"] = this.fieldName;
        data["hitNumber"] = this.hitNumber;
        return data;
    }
}

/** Represents a context hit for a search result. */
export interface ISearchContextHit {
    hitType?: HitType;
    /** A boolean indicating if this context hit occurs on an annotation. */
    isAnnotationHit?: boolean;
    /** The ID of the annotation that the context hit is in. */
    annotationId?: number;
    /** The page number in the document of the search hit's context. */
    pageNumber?: number;
    /** The offset from the beginning of the page of the starting character of the search hit's context line. */
    pageOffset?: number;
    /** The line of context for the search hit. */
    context?: string | undefined;
    /** The character offset from the beginning of the context line of the start of the first highlight. */
    highlight1Offset?: number;
    /** The length of the first highlight in characters. */
    highlight1Length?: number;
    /** The character offset from the beginning of the context line of the start of the second highlight. */
    highlight2Offset?: number;
    /** The length of the second highlight in characters. */
    highlight2Length?: number;
    /** The number of words in the context hit. */
    hitWidth?: number;
    /** The number of hits in the electronic document. */
    edocHitCount?: number;
    /** The number of hits in the template. */
    fieldHitCount?: number;
    /** The name of a template field containing the hit. */
    fieldName?: string | undefined;
    /** The hit number. */
    hitNumber?: number;
}

/** The type of context hit. */
export enum HitType {
    PageContent = "PageContent",
    Note = "Note",
    Callout = "Callout",
    TextBox = "TextBox",
    Edoc = "Edoc",
    Prop = "Prop",
    Name = "Name",
    Extension = "Extension",
    VersionGroupNote = "VersionGroupNote",
    VersionComment = "VersionComment",
    Field = "Field",
    SignatureComment = "SignatureComment",
    CertificateSubject = "CertificateSubject",
    TagComment = "TagComment",
    AnnotationComment = "AnnotationComment",
    Attachment = "Attachment",
}

/** Request body for searching entries. */
export class SearchEntryRequest implements ISearchEntryRequest {
    /** Search command for simple search */
    searchCommand!: string;

    
    
    constructor(data?: ISearchEntryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchCommand = _data["searchCommand"];
        }
    }

    static fromJS(data: any): SearchEntryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SearchEntryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchCommand"] = this.searchCommand;
        return data;
    }
}

/** Request body for searching entries. */
export interface ISearchEntryRequest {
    /** Search command for simple search */
    searchCommand: string;
}

/** Response containing a collection of TagDefinition. */
export class TagDefinitionCollectionResponse implements ITagDefinitionCollectionResponse {
    /** A URL to retrieve the next page of the requested collection. */
    odataNextLink?: string | undefined;
    /** The total count of items within a collection. */
    odataCount?: number | undefined;
    value?: TagDefinition[];

    
    
    constructor(data?: ITagDefinitionCollectionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.odataNextLink = _data["@odata.nextLink"];
            this.odataCount = _data["@odata.count"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(TagDefinition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TagDefinitionCollectionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TagDefinitionCollectionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["@odata.nextLink"] = this.odataNextLink;
        data["@odata.count"] = this.odataCount;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

/** Response containing a collection of TagDefinition. */
export interface ITagDefinitionCollectionResponse {
    /** A URL to retrieve the next page of the requested collection. */
    odataNextLink?: string | undefined;
    /** The total count of items within a collection. */
    odataCount?: number | undefined;
    value?: TagDefinition[];
}

/** Represents an entry tag definition. */
export class TagDefinition implements ITagDefinition {
    /** The ID of the tag definition. */
    id?: number;
    /** The name of the tag definition. */
    name?: string | undefined;
    /** The localized name of the tag definition. */
    displayName?: string | undefined;
    /** The description of the tag definition. */
    description?: string | undefined;
    /** A boolean indicating whether or not the tag definition is classified as a security tag (true) or an informational tag (false). */
    isSecure?: boolean;
    /** The watermark properties associated with the tag definition. */
    watermark?: TagDefinitionWatermark | undefined;

    
    
    constructor(data?: ITagDefinition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isSecure = _data["isSecure"];
            this.watermark = _data["watermark"] ? TagDefinitionWatermark.fromJS(_data["watermark"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TagDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new TagDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isSecure"] = this.isSecure;
        data["watermark"] = this.watermark ? this.watermark.toJSON() : <any>undefined;
        return data;
    }
}

/** Represents an entry tag definition. */
export interface ITagDefinition {
    /** The ID of the tag definition. */
    id?: number;
    /** The name of the tag definition. */
    name?: string | undefined;
    /** The localized name of the tag definition. */
    displayName?: string | undefined;
    /** The description of the tag definition. */
    description?: string | undefined;
    /** A boolean indicating whether or not the tag definition is classified as a security tag (true) or an informational tag (false). */
    isSecure?: boolean;
    /** The watermark properties associated with the tag definition. */
    watermark?: TagDefinitionWatermark | undefined;
}

/** Response containing a collection of TaskProgress. */
export class TaskCollectionResponse implements ITaskCollectionResponse {
    value?: TaskProgress[];

    
    
    constructor(data?: ITaskCollectionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(TaskProgress.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TaskCollectionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TaskCollectionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

/** Response containing a collection of TaskProgress. */
export interface ITaskCollectionResponse {
    value?: TaskProgress[];
}

/** Represents the progress of a long operation task. */
export class TaskProgress implements ITaskProgress {
    /** The task ID of the task associated with this TaskProgress. */
    id?: string | undefined;
    /** The type of the task associated with this TaskProgress. */
    taskType?: TaskType;
    /** Determines what percentage of the execution of the associated task is completed. */
    percentComplete?: number;
    /** The status of the task associated with this TaskProgress. */
    status?: TaskStatus;
    /** The list of errors occurred during the execution of the associated task. */
    errors?: ProblemDetails[] | undefined;
    /** The result of the execution of the associated task. */
    result?: TaskResult | undefined;
    /** The time representing when the associated task's execution started. */
    startTime?: Date;
    /** The time representing when the associated task's status last changed. */
    lastUpdateTime?: Date;

    
    
    constructor(data?: ITaskProgress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.taskType = _data["taskType"];
            this.percentComplete = _data["percentComplete"];
            this.status = _data["status"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ProblemDetails.fromJS(item));
            }
            this.result = _data["result"] ? TaskResult.fromJS(_data["result"]) : <any>undefined;
            this.startTime = _data["startTime"] ? new Date(_data["startTime"].toString()) : <any>undefined;
            this.lastUpdateTime = _data["lastUpdateTime"] ? new Date(_data["lastUpdateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TaskProgress {
        data = typeof data === 'object' ? data : {};
        let result = new TaskProgress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["taskType"] = this.taskType;
        data["percentComplete"] = this.percentComplete;
        data["status"] = this.status;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["lastUpdateTime"] = this.lastUpdateTime ? this.lastUpdateTime.toISOString() : <any>undefined;
        return data;
    }
}

/** Represents the progress of a long operation task. */
export interface ITaskProgress {
    /** The task ID of the task associated with this TaskProgress. */
    id?: string | undefined;
    /** The type of the task associated with this TaskProgress. */
    taskType?: TaskType;
    /** Determines what percentage of the execution of the associated task is completed. */
    percentComplete?: number;
    /** The status of the task associated with this TaskProgress. */
    status?: TaskStatus;
    /** The list of errors occurred during the execution of the associated task. */
    errors?: ProblemDetails[] | undefined;
    /** The result of the execution of the associated task. */
    result?: TaskResult | undefined;
    /** The time representing when the associated task's execution started. */
    startTime?: Date;
    /** The time representing when the associated task's status last changed. */
    lastUpdateTime?: Date;
}

/** An enumeration of possible types for a long operation task. */
export enum TaskType {
    CopyEntry = "CopyEntry",
    DeleteEntry = "DeleteEntry",
    ExportEntry = "ExportEntry",
    ImportUploadedParts = "ImportUploadedParts",
    SearchEntry = "SearchEntry",
}

/** An enumeration of possible statuses for a long operation task. */
export enum TaskStatus {
    NotStarted = "NotStarted",
    InProgress = "InProgress",
    Completed = "Completed",
    Failed = "Failed",
    Cancelled = "Cancelled",
}

/** Represents the result of a long operation task. */
export class TaskResult implements ITaskResult {
    /** The ID of the entry which is affected (e.g. created or modified) by the execution of the associated task. */
    entryId?: number;
    /** The URI which can be used (via api call) to access the result(s) of the associated task. */
    uri?: string | undefined;

    
    
    constructor(data?: ITaskResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entryId = _data["entryId"];
            this.uri = _data["uri"];
        }
    }

    static fromJS(data: any): TaskResult {
        data = typeof data === 'object' ? data : {};
        let result = new TaskResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entryId"] = this.entryId;
        data["uri"] = this.uri;
        return data;
    }
}

/** Represents the result of a long operation task. */
export interface ITaskResult {
    /** The ID of the entry which is affected (e.g. created or modified) by the execution of the associated task. */
    entryId?: number;
    /** The URI which can be used (via api call) to access the result(s) of the associated task. */
    uri?: string | undefined;
}

/** Response containing a collection of CancelOperationResponse. */
export class CancelTasksResponse implements ICancelTasksResponse {
    value?: CancelTaskResult[];

    
    
    constructor(data?: ICancelTasksResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(CancelTaskResult.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CancelTasksResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CancelTasksResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

/** Response containing a collection of CancelOperationResponse. */
export interface ICancelTasksResponse {
    value?: CancelTaskResult[];
}

/** Represents the result of cancelling a long operation task. */
export class CancelTaskResult implements ICancelTaskResult {
    /** The ID of the task which has been subject to cancellation. */
    id?: string | undefined;
    /** The type of the task which has been subject to cancellation. */
    taskType?: TaskType;
    /** True if and only if the associated task has been cancelled successfully or it has already been completed. */
    result?: boolean;

    
    
    constructor(data?: ICancelTaskResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.taskType = _data["taskType"];
            this.result = _data["result"];
        }
    }

    static fromJS(data: any): CancelTaskResult {
        data = typeof data === 'object' ? data : {};
        let result = new CancelTaskResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["taskType"] = this.taskType;
        data["result"] = this.result;
        return data;
    }
}

/** Represents the result of cancelling a long operation task. */
export interface ICancelTaskResult {
    /** The ID of the task which has been subject to cancellation. */
    id?: string | undefined;
    /** The type of the task which has been subject to cancellation. */
    taskType?: TaskType;
    /** True if and only if the associated task has been cancelled successfully or it has already been completed. */
    result?: boolean;
}

/** Response containing a collection of TemplateDefinition. */
export class TemplateDefinitionCollectionResponse implements ITemplateDefinitionCollectionResponse {
    /** A URL to retrieve the next page of the requested collection. */
    odataNextLink?: string | undefined;
    /** The total count of items within a collection. */
    odataCount?: number | undefined;
    value?: TemplateDefinition[];

    
    
    constructor(data?: ITemplateDefinitionCollectionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.odataNextLink = _data["@odata.nextLink"];
            this.odataCount = _data["@odata.count"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(TemplateDefinition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TemplateDefinitionCollectionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateDefinitionCollectionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["@odata.nextLink"] = this.odataNextLink;
        data["@odata.count"] = this.odataCount;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

/** Response containing a collection of TemplateDefinition. */
export interface ITemplateDefinitionCollectionResponse {
    /** A URL to retrieve the next page of the requested collection. */
    odataNextLink?: string | undefined;
    /** The total count of items within a collection. */
    odataCount?: number | undefined;
    value?: TemplateDefinition[];
}

/** Represents a template definition. */
export class TemplateDefinition implements ITemplateDefinition {
    /** The ID of the template definition. */
    id?: number;
    /** The name of the template definition. */
    name?: string | undefined;
    /** The localized name of the template definition. */
    displayName?: string | undefined;
    /** The description of the template definition. */
    description?: string | undefined;
    /** The color assigned to the template definition. */
    color?: LFColor | undefined;
    /** The number of field definitions assigned to the template definition. */
    fieldCount?: number;

    
    
    constructor(data?: ITemplateDefinition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.color = _data["color"] ? LFColor.fromJS(_data["color"]) : <any>undefined;
            this.fieldCount = _data["fieldCount"];
        }
    }

    static fromJS(data: any): TemplateDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["color"] = this.color ? this.color.toJSON() : <any>undefined;
        data["fieldCount"] = this.fieldCount;
        return data;
    }
}

/** Represents a template definition. */
export interface ITemplateDefinition {
    /** The ID of the template definition. */
    id?: number;
    /** The name of the template definition. */
    name?: string | undefined;
    /** The localized name of the template definition. */
    displayName?: string | undefined;
    /** The description of the template definition. */
    description?: string | undefined;
    /** The color assigned to the template definition. */
    color?: LFColor | undefined;
    /** The number of field definitions assigned to the template definition. */
    fieldCount?: number;
}

/** Represents an RGB color value with alpha channel. */
export class LFColor implements ILFColor {
    /** The alpha channel component, from 0-255. */
    a?: number;
    /** The red channel component, from 0-255. */
    r?: number;
    /** The green channel component, from 0-255. */
    g?: number;
    /** The blue channel component from 0-255. */
    b?: number;

    
    
    constructor(data?: ILFColor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.a = _data["a"];
            this.r = _data["r"];
            this.g = _data["g"];
            this.b = _data["b"];
        }
    }

    static fromJS(data: any): LFColor {
        data = typeof data === 'object' ? data : {};
        let result = new LFColor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["a"] = this.a;
        data["r"] = this.r;
        data["g"] = this.g;
        data["b"] = this.b;
        return data;
    }
}

/** Represents an RGB color value with alpha channel. */
export interface ILFColor {
    /** The alpha channel component, from 0-255. */
    a?: number;
    /** The red channel component, from 0-255. */
    r?: number;
    /** The green channel component, from 0-255. */
    g?: number;
    /** The blue channel component from 0-255. */
    b?: number;
}

/** Response containing a collection of TemplateFieldDefinition. */
export class TemplateFieldDefinitionCollectionResponse implements ITemplateFieldDefinitionCollectionResponse {
    /** A URL to retrieve the next page of the requested collection. */
    odataNextLink?: string | undefined;
    /** The total count of items within a collection. */
    odataCount?: number | undefined;
    value?: TemplateFieldDefinition[];

    
    
    constructor(data?: ITemplateFieldDefinitionCollectionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.odataNextLink = _data["@odata.nextLink"];
            this.odataCount = _data["@odata.count"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(TemplateFieldDefinition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TemplateFieldDefinitionCollectionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateFieldDefinitionCollectionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["@odata.nextLink"] = this.odataNextLink;
        data["@odata.count"] = this.odataCount;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

/** Response containing a collection of TemplateFieldDefinition. */
export interface ITemplateFieldDefinitionCollectionResponse {
    /** A URL to retrieve the next page of the requested collection. */
    odataNextLink?: string | undefined;
    /** The total count of items within a collection. */
    odataCount?: number | undefined;
    value?: TemplateFieldDefinition[];
}

/** Represents a template field definition. */
export class TemplateFieldDefinition extends FieldDefinition implements ITemplateFieldDefinition {
    /** A form logic rule associated with a Laserfiche template and field definition. */
    rule?: Rule | undefined;
    /** The group id of the field in the template. */
    groupId?: number;
    /** The name of field group. */
    groupName?: string | undefined;

    
    
    constructor(data?: ITemplateFieldDefinition) {
        super(data);
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.rule = _data["rule"] ? Rule.fromJS(_data["rule"]) : <any>undefined;
            this.groupId = _data["groupId"];
            this.groupName = _data["groupName"];
        }
    }

    static fromJS(data: any): TemplateFieldDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateFieldDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rule"] = this.rule ? this.rule.toJSON() : <any>undefined;
        data["groupId"] = this.groupId;
        data["groupName"] = this.groupName;
        super.toJSON(data);
        return data;
    }
}

/** Represents a template field definition. */
export interface ITemplateFieldDefinition extends IFieldDefinition {
    /** A form logic rule associated with a Laserfiche template and field definition. */
    rule?: Rule | undefined;
    /** The group id of the field in the template. */
    groupId?: number;
    /** The name of field group. */
    groupName?: string | undefined;
}

export class Rule implements IRule {
    /** The IDs of the parent fields in the template according to the form logic rule. */
    ancestors?: number[] | undefined;

    
    
    constructor(data?: IRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ancestors"])) {
                this.ancestors = [] as any;
                for (let item of _data["ancestors"])
                    this.ancestors!.push(item);
            }
        }
    }

    static fromJS(data: any): Rule {
        data = typeof data === 'object' ? data : {};
        let result = new Rule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ancestors)) {
            data["ancestors"] = [];
            for (let item of this.ancestors)
                data["ancestors"].push(item);
        }
        return data;
    }
}

export interface IRule {
    /** The IDs of the parent fields in the template according to the form logic rule. */
    ancestors?: number[] | undefined;
}

export class HttpResponseHead<TResult> {
    status: number;
    headers: { [key: string]: any; };
    result: TResult;

    constructor(status: number, headers: { [key: string]: any; }, result: TResult)
    {
        this.status = status;
        this.headers = headers;
        this.result = result;
    }
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiExceptionDummy extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiExceptionDummy = true;

    static isApiExceptionDummy(obj: any): obj is ApiExceptionDummy {
        return obj.isApiExceptionDummy === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    throw new ApiException(message, status, response, headers, result);
}

class ClientBase {}
export interface IRepositoryApiClient {
  attributesClient: IAttributesClient;
  auditReasonsClient: IAuditReasonsClient;
  entriesClient: IEntriesClient;
  fieldDefinitionsClient: IFieldDefinitionsClient;
  repositoriesClient: IRepositoriesClient;
  searchesClient: ISearchesClient;
  simpleSearchesClient: ISimpleSearchesClient;
  tagDefinitionsClient: ITagDefinitionsClient;
  tasksClient: ITasksClient;
  templateDefinitionsClient: ITemplateDefinitionsClient;
  linkDefinitionsClient: ILinkDefinitionsClient;
  defaultRequestHeaders: Record<string, string>;
}

// @ts-ignore
export class RepositoryApiClient implements IRepositoryApiClient {
  private baseUrl: string;

  public attributesClient: IAttributesClient;
  public auditReasonsClient: IAuditReasonsClient;
  public entriesClient: IEntriesClient;
  public fieldDefinitionsClient: IFieldDefinitionsClient;
  public repositoriesClient: IRepositoriesClient;
  public searchesClient: ISearchesClient;
  public simpleSearchesClient: ISimpleSearchesClient;
  public tagDefinitionsClient: ITagDefinitionsClient;
  public tasksClient: ITasksClient;
  public templateDefinitionsClient: ITemplateDefinitionsClient;
  public linkDefinitionsClient: ILinkDefinitionsClient;

  private repoClientHandler: RepositoryApiClientHttpHandler;

  /**
   * Get the headers which will be sent with each request.
   */
  public get defaultRequestHeaders(): Record<string, string> {
    return this.repoClientHandler.defaultRequestHeaders;
  }

  /**
   * Set the headers which will be sent with each request.
   */
  public set defaultRequestHeaders(headers: Record<string, string>) {
    this.repoClientHandler.defaultRequestHeaders = headers;
  }

  private constructor(httpRequestHandler: HttpRequestHandler, baseUrlDebug?: string) {
    this.repoClientHandler = new RepositoryApiClientHttpHandler(httpRequestHandler);
    if (this.repoClientHandler){
      this.defaultRequestHeaders['Accept-Encoding'] = 'gzip';
    }
    let fetch = this.repoClientHandler.httpHandler;
    fetch = fetch.bind(this.repoClientHandler);
    let http = {
      fetch,
    };
    this.baseUrl = baseUrlDebug ?? '';
    this.attributesClient = new AttributesClient(this.baseUrl, http);
    this.auditReasonsClient = new AuditReasonsClient(this.baseUrl, http);
    this.entriesClient = new EntriesClient(this.baseUrl, http);
    this.fieldDefinitionsClient = new FieldDefinitionsClient(this.baseUrl, http);
    this.repositoriesClient = new RepositoriesClient(this.baseUrl, http);
    this.searchesClient = new SearchesClient(this.baseUrl, http);
    this.simpleSearchesClient = new SimpleSearchesClient(this.baseUrl, http);
    this.tagDefinitionsClient = new TagDefinitionsClient(this.baseUrl, http);
    this.tasksClient = new TasksClient(this.baseUrl, http);
    this.templateDefinitionsClient = new TemplateDefinitionsClient(this.baseUrl, http);
    this.linkDefinitionsClient = new LinkDefinitionsClient(this.baseUrl, http);
  }

  /**
   * Create a Laserfiche repository client.
   * @param httpRequestHandler The http request handler for the Laserfiche repository client.
   * @param baseUrlDebug (optional) override for the Laserfiche repository API base url.
   */
  public static createFromHttpRequestHandler(
    httpRequestHandler: HttpRequestHandler,
    baseUrlDebug?: string
  ): RepositoryApiClient {
    if (!httpRequestHandler) throw new Error('Argument cannot be null: httpRequestHandler');
    const repoClient = new RepositoryApiClient(httpRequestHandler, baseUrlDebug);
    return repoClient;
  }

  /**
   * Create a Laserfiche repository client that will use Laserfiche Cloud OAuth client credentials to get access tokens.
   * @param servicePrincipalKey The service principal key created for the service principal from the Laserfiche Account Administration.
   * @param accessKey The access key exported from the Laserfiche Developer Console.
   * @param scope (optional) The requested space-delimited scopes for the access token.
   * @param baseUrlDebug (optional) override for the Laserfiche repository API base url.
   */
  public static createFromAccessKey(
    servicePrincipalKey: string,
    accessKey: AccessKey,
    scope?: string,
    baseUrlDebug?: string
  ): RepositoryApiClient {
    const handler = new OAuthClientCredentialsHandler(servicePrincipalKey, accessKey, scope);
    return RepositoryApiClient.createFromHttpRequestHandler(handler, baseUrlDebug);
  }

  /**
   * Create a Laserfiche repository client that will use username and password to get access tokens for Laserfiche API. Password credentials grant type is implemented by the Laserfiche Self-Hosted API server. Not available in cloud.
   * @param repositoryId The repository ID
   * @param username The username
   * @param password The password
   * @param baseUrl API server base URL e.g., https://{APIServerName}/LFRepositoryAPI
   */
  public static createFromUsernamePassword(
    repositoryId: string,
    username: string,
    password: string,
    baseUrl: string
  ): RepositoryApiClient {
    const baseUrlWithoutSlash: string = StringUtils.trimEnd(baseUrl, '/');
    const handler = new UsernamePasswordHandler(repositoryId, username, password, baseUrlWithoutSlash, undefined);
    return new RepositoryApiClient(handler, baseUrlWithoutSlash);
  }
}
/** @internal */
export class RepositoryApiClientHttpHandler {
  private _httpRequestHandler: HttpRequestHandler;
  public defaultRequestHeaders: Record<string, string>;

  constructor(httpRequestHandler: HttpRequestHandler) {
    this._httpRequestHandler = httpRequestHandler;
    this.defaultRequestHeaders = {};
  }

  public async httpHandler(url: string, init: RequestInit): Promise<Response> {
    const maxRetries = 1;
    let retryCount = 0;
    let shouldRetry = true;

    if (this.defaultRequestHeaders) {
      init.headers = Object.assign({}, this.defaultRequestHeaders, init.headers);
    }
    let response: Response | undefined;
    while (retryCount <= maxRetries && shouldRetry) {
      const beforeSendResult = await this._httpRequestHandler.beforeFetchRequestAsync(url, init);
      let absoluteUrl: string;
      if (url.startsWith('http')) {
        absoluteUrl = url;
      } else {
        const apiBasedAddress = DomainUtils.getRepositoryEndpoint(beforeSendResult.regionalDomain);
        absoluteUrl = UrlUtils.combineURLs(apiBasedAddress, url);
      }

      try {
        response = await fetch(absoluteUrl, init);
        shouldRetry =
          (await this._httpRequestHandler.afterFetchResponseAsync(absoluteUrl, response, init)) ||
          isRetryable(response, init);
        if (!shouldRetry) {
          return response;
        }
      } catch (err) {
        if (retryCount >= maxRetries) {
          throw err;
        }
        shouldRetry = true;
        console.warn(`Retrying fetch due to exception: ${err}`);
      } finally {
        retryCount++;
      }
    }
    if (!response) {
      throw new Error('Undefined response, there is a bug!');
    }
    return response;
  }
}

function isRetryable(response: Response, init: RequestInit): boolean {
  const isIdempotent = init.method != 'POST';
  return (response.status >= 500 || response.status == 408) && isIdempotent;
}

async function getNextLinkListing<T>(
  http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> },
  processListing: (response: Response) => Promise<T>,
  nextLink: string,
  maxPageSize?: number
): Promise<T> {
  if (!nextLink) {
    throw new Error('Next Link is undefined');
  }
  const prefer = createMaxPageSizePreferHeaderPayload(maxPageSize);
  const options_ = <RequestInit>{
    method: 'GET',
    headers: {
      Prefer: prefer !== undefined && prefer !== null ? prefer : '',
      Accept: 'application/json',
    },
  };
  const processListingTwo = processListing.bind(http);

  const resp = await http.fetch(nextLink, options_);
  return await processListingTwo(resp);
}

function createMaxPageSizePreferHeaderPayload(maxSize?: number): string | undefined {
  //puts the max size into the prefer header of the GET request
  if (!maxSize) {
    return undefined;
  } else {
    return `maxpagesize=${maxSize}`;
  }
}

export interface IAttributesClient {
  /**
   * It will continue to make the same call to get a list of attributes key value pairs of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repositoryId The requested repository ID.
   * @param args.everyone (optional) Boolean value that indicates whether to return attributes key value pairs associated with everyone or the currently authenticated user.
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of attributes key value pairs allowed per API response schema
   */
  listAttributesForEach(args: {
    callback: (response: AttributeCollectionResponse) => Promise<boolean>;
    repositoryId: string;
    everyone?: boolean;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;

  /**
   * Returns the attribute key value pairs using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of attribute keys allowed per API response schema
   * @return Get trustee attribute keys with the next link successfully
   */
  listAttributesNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<AttributeCollectionResponse>;
}

export interface IEntriesClient {
  /**
   * This is a helper for wrapping the CreateMultipartUploadURls and the ImportUploadedParts APIs. 
   * If successful, it returns a taskId which can be used to check the status of the operation or retrieve its result, otherwise, it returns an error.
   * Required OAuth scope: repository.Write
   * @param args.repositoryId The requested repository ID.
   * @param args.entryId The entry ID of the folder that the document will be created in.
   * @param args.file The file to be imported as a new document. 
   * @param args.mimeType The mime-type of the file to be imported as a new document. 
   * @param args.request The body of the request.
   * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used. The value should be a standard language tag. This may be used when setting field values with tokens.
   * @return A long operation task id.
  */
  startImportEntry(args: {
    repositoryId: string;
    entryId: number;
    file: FileParameter;
    mimeType: string;
    request: ImportEntryRequest;
    culture?: string | null | undefined;
  }): Promise<StartTaskResponse>;
  /**
   * It will continue to make the same call to get a list of entry listings of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repositoryId The requested repository ID.
   * @param args.entryId The requested entry ID.
   * @param args.groupByEntryType (optional) An optional query parameter used to indicate if the result should be grouped by entry type or not.
   * @param args.fields (optional) Optional array of field names. Field values corresponding to the given field names will be returned for each entry.
   * @param args.formatFieldValues (optional) Boolean for if field values should be formatted. Only applicable if Fields are specified.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
          The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise
          culture will not be used for formatting. 
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of entry listings allowed per API response schema.
   */
  listEntriesForEach(args: {
    callback: (response: EntryCollectionResponse) => Promise<boolean>;
    repositoryId: string;
    entryId: number;
    groupByEntryType?: boolean;
    fields?: string[];
    formatFieldValues?: boolean;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;
  /**
   * It will continue to make the same call to get a list of field values of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repositoryId The requested repository ID.
   * @param args.entryId The requested entry ID.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.formatValue (optional) An optional query parameter used to indicate if the field values should be formatted.
          The default value is false. 
   * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
          The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise
          culture will not be used for formatting. 
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of field values allowed per API response schema.
   */
  listFieldsForEach(args: {
    callback: (response: FieldCollectionResponse) => Promise<boolean>;
    repositoryId: string;
    entryId: number;
    prefer?: string;
    formatValue?: boolean;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;
  /**
   * It will continue to make the same call to get a list of link values from entry of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repositoryId The requested repository ID.
   * @param args.entryId The requested entry ID.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of link values from entry allowed per API response schema.
   */
  listLinksForEach(args: {
    callback: (response: LinkCollectionResponse) => Promise<boolean>;
    repositoryId: string;
    entryId: number;
    prefer?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;
  /**
   * It will continue to make the same call to get a list of tags assigned to entry of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repositoryId The requested repository ID.
   * @param args.entryId The requested entry ID.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of tags assigned to entry allowed per API response schema.
   */
  listTagsForEach(args: {
    callback: (response: TagDefinitionCollectionResponse) => Promise<boolean>;
    repositoryId: string;
    entryId: number;
    prefer?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;
  /**
   * Returns the children entries of a folder in the repository using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of entry listings allowed per API response schema
   * @return Get the children entries of a Folder with the next link successfully
   */
  listEntriesNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<EntryCollectionResponse>;
  /**
   * Returns the fields assigned to an entry using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of field values allowed per API response schema
   * @return Get field values with the next link successfully
   */
  listFieldsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<FieldCollectionResponse>;
  /**
   * Get the links assigned to an entry using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of link values from entry allowed per API response schema
   * @return Get links with the next link successfully
   */
  listLinksNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<LinkCollectionResponse>;
  /**
   * Get the tags assigned to an entry using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of tags assigned to entry allowed per API response schema
   * @return Get entry tags with the next link successfully
   */
  listTagsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<TagDefinitionCollectionResponse>;
}

export interface IFieldDefinitionsClient {
  /**
   * It will continue to make the same call to get a list of field definitions of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repositoryId The requested repository ID.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
          The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise
          culture will not be used for formatting.  
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of field definitions allowed per API response schema.
   */
  listFieldDefinitionsForEach(args: {
    callback: (response: FieldDefinitionCollectionResponse) => Promise<boolean>;
    repositoryId: string;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;
  /**
   * Returns a paged listing of field definitions available in the specified repository using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of field definitions allowed per API response schema
   * @return Get field definitions with the next link successfully
   */
  listFieldDefinitionsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<FieldDefinitionCollectionResponse>;
}

export interface ISearchesClient {
  /**
   * It will continue to make the same call to get a list of search results of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repositoryId The requested repository ID.
   * @param args.searchToken The requested searchToken.
   * @param args.groupByEntryType (optional) An optional query parameter used to indicate if the result should be grouped by entry type or not.
   * @param args.refresh (optional) If the search listing should be refreshed to show updated values.
   * @param args.fields (optional) Optional array of field names. Field values corresponding to the given field names will be returned for each entry.
   * @param args.formatFieldValues (optional) Boolean for if field values should be formatted. Only applicable if Fields are specified.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
          The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise
          culture will not be used for formatting.  
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of search results allowed per API response schema.
   */
  listSearchResultsForEach(args: {
    callback: (response: EntryCollectionResponse) => Promise<boolean>;
    repositoryId: string;
    searchToken: string;
    groupByEntryType?: boolean;
    refresh?: boolean;
    fields?: string[];
    formatFieldValues?: boolean;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;
  /**
   * It will continue to make the same call to get a list of search context hits of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repositoryId The requested repository ID.
   * @param args.searchToken The requested searchToken.
   * @param args.rowNumber The search result listing row number to get context hits for.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of search context hits allowed per API response schema.
   */
  listSearchContextHitsForEach(args: {
    callback: (response: SearchContextHitCollectionResponse) => Promise<boolean>;
    repositoryId: string;
    searchToken: string;
    rowNumber: number;
    prefer?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;
  /**
   * Returns a search result listing if the search is completed using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of search results allowed per API response schema
   * @return Get search result with the next link successfully
   */
  listSearchResultsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<EntryCollectionResponse>;
  /**
   * Returns the context hits associated with a search result entry using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of search context hits allowed per API response schema
   * @return Get search context hits with the next link successfully
   */
  listSearchContextHitsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<SearchContextHitCollectionResponse>;
}

export interface ITagDefinitionsClient {
  /**
   * It will continue to make the same call to get a list of tag definitions of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repositoryId The requested repository ID.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
          The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise
          culture will not be used for formatting.  
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of tag definitions allowed per API response schema.
   */
  listTagDefinitionsForEach(args: {
    callback: (response: TagDefinitionCollectionResponse) => Promise<boolean>;
    repositoryId: string;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;
  /**
   * Returns all tag definitions in the repository using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of tag definitions allowed per API response schema
   * @return Get tag definitions with the next link successfully
   */
  listTagDefinitionsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<TagDefinitionCollectionResponse>;
}

export interface ITemplateDefinitionsClient {
  /**
   * It will continue to make the same call to get a list of template definitions of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repositoryId The requested repository ID.
   * @param args.templateName (optional) An optional query parameter. Can be used to get a single template definition using the template name.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
          The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise
          culture will not be used for formatting.  
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of template definitions allowed per API response schema.
   */
  listTemplateDefinitionsForEach(args: {
    callback: (response: TemplateDefinitionCollectionResponse) => Promise<boolean>;
    repositoryId: string;
    templateName?: string;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;
  /**
   * It will continue to make the same call to get a list of template field definitions of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repositoryId The requested repository ID.
   * @param args.templateName (optional) An optional query parameter. Can be used to get a single template definition using the template name.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
          The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise
          culture will not be used for formatting.  
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of template field definitions allowed per API response schema.
   */
  listTemplateFieldDefinitionsByTemplateIdForEach(args: {
    callback: (response: TemplateFieldDefinitionCollectionResponse) => Promise<boolean>;
    repositoryId: string;
    templateId: number;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;
  /**
   * It will continue to make the same call to get a list of template field definitions by template name of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repositoryId The requested repository ID.
   * @param args.templateName (optional) An optional query parameter. Can be used to get a single template definition using the template name.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
          The value should be a standard language tag. The formatFieldValues query parameter must be set to true, otherwise
          culture will not be used for formatting.  
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of template field definitions by template name allowed per API response schema.
   */
  listTemplateFieldDefinitionsByTemplateNameForEach(args: {
    callback: (response: TemplateFieldDefinitionCollectionResponse) => Promise<boolean>;
    repositoryId: string;
    templateName: string;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;
  /**
   * Returns all template definitions (including field definitions) in the repository using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of template definitions allowed per API response schema
   * @return Get template definitions with the next link successfully
   */
  listTemplateDefinitionsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<TemplateDefinitionCollectionResponse>;
  /**
   * Returns the field definitions assigned to a template definition using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of template field definitions allowed per API response schema
   * @return Get field definitions with the next link successfully
   */
  listTemplateFieldDefinitionsByTemplateIdNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<TemplateFieldDefinitionCollectionResponse>;
  /**
   * Returns the field definitions assigned to a template definition by template name using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of template field definitions by template name allowed per API response schema
   * @return Get field definitions by template name with the next link successfully
   */
  listTemplateFieldDefinitionsByTemplateNameNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<TemplateFieldDefinitionCollectionResponse>;
}

export interface ILinkDefinitionsClient {
  /**
   * It will continue to make the same call to get a list of link definitions of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repositoryId The requested repository ID.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of link definitions allowed per API response schema.
   */
  listLinkDefinitionsForEach(args: {
    callback: (response: LinkDefinitionCollectionResponse) => Promise<boolean>;
    repositoryId: string;
    prefer?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;

  /**
   * Returns all link definitions in the repository using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of link definitions allowed per API response schema
   * @return Get link definitions with the next link successfully
   */
  listLinkDefinitionsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<LinkDefinitionCollectionResponse>;
}

export class ApiException extends ApiExceptionCore {
  constructor(message: string, status: number, response: string, headers: { [key: string]: any }, result: any) {
    super(message, status, headers, result);
  }
}