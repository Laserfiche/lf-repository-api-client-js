//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.0.0 (NJsonSchema v10.7.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { UrlUtils } from '@laserfiche/lf-js-utils';
import {
  OAuthClientCredentialsHandler,
  HttpRequestHandler,
  DomainUtils,
  AccessKey,
} from '@laserfiche/lf-api-client-core';

export interface IEntriesClient {

    /**
     * Creates a new document in the specified folder. Optionally sets metadata and electronic document component. Optional parameter: autoRename (default false). If an entry already exists with the given name, the entry will be automatically renamed. With this route, partial success is possible. The response returns multiple operation (entryCreate operation, setEdoc operation, setLinks operation, etc..) objects, which contain information about any errors that may have occurred during the creation. As long as the entryCreate operation succeeds, the entry will be created, even if all other operations fail.
     * @param repoId The requested repository ID.
     * @param parentEntryId The entry ID of the folder that the document will be created in.
     * @param fileName The created document's file name.
     * @param autoRename (optional) An optional query parameter used to indicate if the new document should be automatically
                renamed if an entry already exists with the given name in the folder. The default value is false.
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used.
                The value should be a standard language tag.
     * @param electronicDocument (optional) 
     * @param request (optional) 
     * @return Document creation is success.
     */
    importDocument(args: { repoId: string, parentEntryId: number, fileName: string, autoRename?: boolean | undefined, culture?: string | null | undefined, electronicDocument?: FileParameter | undefined, request?: PostEntryWithEdocMetadataRequest | undefined }): Promise<CreateEntryResult>;

    /**
     * Returns a single entry object. Provide an entry ID, and get the entry associated with that ID. Useful when detailed information about the entry is required, such as metadata, path information, etc. Allowed OData query options: Select. If the entry is a subtype (Folder, Document, or Shortcut), the entry will automatically be converted to include those model-specific properties.
     * @param repoId The requested repository ID.
     * @param entryId The requested entry ID.
     * @param select (optional) Limits the properties returned in the result.
     * @return Get entry successfully.
     */
    getEntry(args: { repoId: string, entryId: number, select?: string | null | undefined }): Promise<Entry>;

    /**
     * Begins a task to delete an entry, and returns an operationToken. Provide an entry ID, and queue a delete task to remove it from the repository (includes nested objects if the entry is a Folder type). The entry will not be deleted immediately. Optionally include an audit reason ID and comment in the JSON body. This route returns an operationToken, and will run as an asynchronous operation. Check the progress via the Tasks/{operationToken} route.
     * @param repoId The requested repository ID.
     * @param entryId The requested entry ID.
     * @param request (optional) The submitted audit reason.
     * @return Delete entry operation start successfully.
     */
    deleteEntryInfo(args: { repoId: string, entryId: number, request?: DeleteEntryWithAuditReason | undefined }): Promise<AcceptedOperation>;

    /**
     * Moves and/or renames an entry. Move and/or rename an entry by passing in the new parent folder ID or name in the JSON body. Optional parameter: autoRename (default false). If an entry already exists with the given name, the entry will be automatically renamed.
     * @param repoId The requested repository ID.
     * @param entryId The requested entry ID.
     * @param request (optional) The request containing the folder ID that the entry will be moved to and the new name
                the entry will be renamed to.
     * @param autoRename (optional) An optional query parameter used to indicate if the entry should be automatically
                renamed if another entry already exists with the same name in the folder. The default value is false.
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used.
                The value should be a standard language tag.
     * @return Moves and/or renames an entry successfully.
     */
    moveOrRenameDocument(args: { repoId: string, entryId: number, request?: PatchEntryRequest | undefined, autoRename?: boolean | undefined, culture?: string | null | undefined }): Promise<Entry>;

    /**
     * Returns the children entries of a folder in the repository. Provide an entry ID (must be a folder), and get a paged listing of entries in that folder. Used as a way of navigating through the repository. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer. OData $OrderBy syntax should follow: "PropertyName direction,PropertyName2 direction". Sort order can be either value "asc" or "desc". Optional query parameters: groupByOrderType (bool). This query parameter decides if results are returned in groups based on their entry type. Entries returned in the listing are not automatically converted to their subtype (Folder, Shortcut, Document), so clients who want model-specific information should request it via the GET entry by ID route. Optionally returns field values for the entries in the folder. Each field name needs to be specified in the request. Maximum limit of 10 field names. If field values are requested, only the first value is returned if it is a multi value field. Null or Empty field values should not be used to determine if a field is assigned to the entry.
     * @param repoId The requested repository ID.
     * @param entryId The folder ID.
     * @param groupByEntryType (optional) An optional query parameter used to indicate if the result should be grouped by entry type or not.
     * @param fields (optional) Optional array of field names. Field values corresponding to the given field names will be returned for each entry.
     * @param formatFields (optional) Boolean for if field values should be formatted. Only applicable if Fields are specified.
     * @param prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag. The formatFields query parameter must be set to true, otherwise
                culture will not be used for formatting.
     * @param select (optional) Limits the properties returned in the result.
     * @param orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param top (optional) Limits the number of items returned from a collection.
     * @param skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get the children entries of a Folder successfully.
     */
    getEntryListing(args: { repoId: string, entryId: number, groupByEntryType?: boolean | undefined, fields?: string[] | null | undefined, formatFields?: boolean | undefined, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfEntry>;

    /**
     * Create/copy a new child entry in the designated folder. Provide the parent folder ID, and based on the request body, copy or create a folder/shortcut as a child entry of the designated folder. Optional parameter: autoRename (default false). If an entry already exists with the given name, the entry will be automatically renamed.
     * @param repoId The requested repository ID.
     * @param entryId The folder ID that the entry will be created in.
     * @param request (optional) The entry to create.
     * @param autoRename (optional) An optional query parameter used to indicate if the new entry should be automatically
                renamed if an entry already exists with the given name in the folder. The default value is false.
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used.
                The value should be a standard language tag.
     * @return Created a new child entry successfully.
     */
    createOrCopyEntry(args: { repoId: string, entryId: number, request?: PostEntryChildrenRequest | undefined, autoRename?: boolean | undefined, culture?: string | null | undefined }): Promise<Entry>;

    /**
     * Returns the fields assigned to an entry. Provide an entry ID, and get a paged listing of all fields assigned to that entry. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param repoId The requested repository ID.
     * @param entryId The requested entry ID.
     * @param prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param formatValue (optional) An optional query parameter used to indicate if the field values should be formatted.
                The default value is false.
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag. The formatValue query parameter must be set to true, otherwise
                culture will not be used for formatting.
     * @param select (optional) Limits the properties returned in the result.
     * @param orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param top (optional) Limits the number of items returned from a collection.
     * @param skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get field values successfully.
     */
    getFieldValues(args: { repoId: string, entryId: number, prefer?: string | null | undefined, formatValue?: boolean | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfFieldValue>;

    /**
     * Update field values assigned to an entry. Provide the new field values to assign to the entry, and remove/reset all previously assigned field values.  This is an overwrite action. The request body must include all desired field values, including any existing field values that should remain assigned to the entry. Field values that are not included in the request will be deleted from the entry. If the field value that is not included is part of a template, it will still be assigned (as required by the template), but its value will be reset.
     * @param repoId The requested repository ID.
     * @param entryId The entry ID of the entry that will have its fields updated.
     * @param fieldsToUpdate (optional) 
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used.
                The value should be a standard language tag.
     * @return Update field values successfully.
     */
    assignFieldValues(args: { repoId: string, entryId: number, fieldsToUpdate?: { [key: string]: FieldToUpdate; } | undefined, culture?: string | null | undefined }): Promise<ODataValueOfIListOfFieldValue>;

    /**
     * Get the tags assigned to an entry. Provide an entry ID, and get a paged listing of tags assigned to that entry. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param repoId The requested repository ID.
     * @param entryId The requested entry ID.
     * @param prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param select (optional) Limits the properties returned in the result.
     * @param orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param top (optional) Limits the number of items returned from a collection.
     * @param skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get entry tags successfully.
     */
    getTagsAssignedToEntry(args: { repoId: string, entryId: number, prefer?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfWTagInfo>;

    /**
     * Assign tags to an entry. Provide an entry ID and a list of tags to assign to that entry. This is an overwrite action. The request must include all tags to assign to the entry, including existing tags that should remain assigned to the entry.
     * @param repoId The requested repository ID.
     * @param entryId The requested entry ID.
     * @param tagsToAdd (optional) The tags to add.
     * @return Assign tags to an entry successfully.
     */
    assignTags(args: { repoId: string, entryId: number, tagsToAdd?: PutTagRequest | undefined }): Promise<ODataValueOfIListOfWTagInfo>;

    /**
     * Assign links to an entry. Provide an entry ID and a list of links to assign to that entry. This is an overwrite action. The request must include all links to assign to the entry, including existing links that should remain assigned to the entry.
     * @param repoId The request repository ID.
     * @param entryId The requested entry ID.
     * @param linksToAdd (optional) 
     * @return Assign links to an entry successfully.
     */
    assignEntryLinks(args: { repoId: string, entryId: number, linksToAdd?: PutLinksRequest[] | undefined }): Promise<ODataValueOfIListOfWEntryLinkInfo>;

    /**
     * Get the links assigned to an entry. Provide an entry ID, and get a paged listing of links assigned to that entry. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param repoId The requested repository ID.
     * @param entryId The requested entry ID.
     * @param prefer (optional) An optional odata header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param select (optional) Limits the properties returned in the result.
     * @param orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param top (optional) Limits the number of items returned from a collection.
     * @param skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get links successfully.
     */
    getLinkValuesFromEntry(args: { repoId: string, entryId: number, prefer?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfWEntryLinkInfo>;

    /**
     * Copy a new child entry in the designated folder async, and potentially return an operationToken. Provide the parent folder ID, and copy an entry as a child of the designated folder. Optional parameter: autoRename (default false). If an entry already exists with the given name, the entry will be automatically renamed.  The status of the operation can be checked via the Tasks/{operationToken} route.
     * @param repoId The requested repository ID.
     * @param entryId The folder ID that the entry will be created in.
     * @param request (optional) Copy entry request.
     * @param autoRename (optional) An optional query parameter used to indicate if the new entry should be automatically
                renamed if an entry already exists with the given name in the folder. The default value is false.
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used.
                The value should be a standard language tag.
     * @return Copy entry operation is started successfully.
     */
    copyEntry(args: { repoId: string, entryId: number, request?: CopyAsyncRequest | undefined, autoRename?: boolean | undefined, culture?: string | null | undefined }): Promise<AcceptedOperation>;

    /**
     * Delete the edoc associated with the provided entry ID.
     * @param repoId The requested repository ID.
     * @param entryId The requested document ID.
     * @return Deleted edoc successfully.
     */
    deleteDocument(args: { repoId: string, entryId: number }): Promise<ODataValueOfBoolean>;

    /**
     * Get information about the edoc content of an entry, without downloading the edoc in its entirety. Provide an entry ID, and get back the Content-Type and Content-Length in the response headers. This route does not provide a way to download the actual edoc. Instead, it just gives metadata information about the edoc associated with the entry.
     * @param repoId The requested repository ID.
     * @param entryId The requested document ID.
     * @return Get edoc info successfully.
     */
    getDocumentContentType(args: { repoId: string, entryId: number }): Promise<void>;

    /**
     * Get an entry's edoc resource in a stream format. Provide an entry ID, and get the edoc resource as part of the response content. Optional header: Range. Use the Range header (single range with byte unit) to retrieve partial content of the edoc, rather than the entire edoc.
     * @param repoId The requested repository ID.
     * @param entryId The requested document ID.
     * @param range (optional) An optional header used to retrieve partial content of the edoc. Only supports single
                range with byte unit.
     * @return Get edoc successfully.
     */
    exportDocument(args: { repoId: string, entryId: number, range?: string | null | undefined }): Promise<FileResponse>;

    /**
     * Delete the pages associated with the provided entry ID. If no pageRange is specified, all pages will be deleted. Optional parameter: pageRange (default empty). The value should be a comma-seperated string which contains non-overlapping single values, or page ranges. Ex: "1,2,3", "1-3,5", "2-7,10-12."
     * @param repoId The requested repository ID.
     * @param entryId The requested document ID.
     * @param pageRange (optional) The pages to be deleted.
     * @return Deleted pages successfully.
     */
    deletePages(args: { repoId: string, entryId: number, pageRange?: string | null | undefined }): Promise<ODataValueOfBoolean>;

    /**
     * Get an entry's edoc resource in a stream format while including an audit reason. Provide an entry ID and audit reason/comment in the request body, and get the edoc resource as part of the response content. Optional header: Range. Use the Range header (single range with byte unit) to retrieve partial content of the edoc, rather than the entire edoc. This route is identical to the GET edoc route, but allows clients to include an audit reason when downloading the edoc.
     * @param repoId The requested repository ID.
     * @param entryId The requested document ID.
     * @param request (optional) 
     * @param range (optional) An optional header used to retrieve partial content of the edoc. Only supports single
                range with byte unit.
     * @return Get edoc successfully.
     */
    exportDocumentWithAuditReason(args: { repoId: string, entryId: number, request?: GetEdocWithAuditReasonRequest | undefined, range?: string | null | undefined }): Promise<FileResponse>;

    /**
     * Get dynamic field logic values with the current values of the fields in the template. Provide an entry ID and field values in the JSON body to get dynamic field logic values.  Independent and non-dynamic fields in the request body will be ignored, and only related dynamic field logic values for the assigned template will be returned.
     * @param repoId The requested repository ID.
     * @param entryId The requested entry ID.
     * @param request (optional) 
     * @return Get dynamic field logic values successfully.
     */
    getDynamicFieldValues(args: { repoId: string, entryId: number, request?: GetDynamicFieldLogicValueRequest | undefined }): Promise<{ [key: string]: string[]; }>;

    /**
     * Remove the currently assigned template from the specified entry. Provide an entry ID to clear template value on. If the entry does not have a template assigned, no change will be made.
     * @param repoId The requested repository ID.
     * @param entryId The ID of the entry that will have its template removed.
     * @return Remove the currently assigned template successfully.
     */
    deleteAssignedTemplate(args: { repoId: string, entryId: number }): Promise<Entry>;

    /**
     * Assign a template to an entry. Provide an entry ID, template name, and a list of template fields to assign to that entry. Only template values will be modified. Any existing independent fields on the entry will not be modified, nor will they be added if included in the request. The only modification to fields will only occur on templated fields. If the previously assigned template includes common template fields as the newly assigned template, the common field values will not be modified.
     * @param repoId The requested repository ID.
     * @param entryId The ID of entry that will have its template updated.
     * @param request (optional) The template and template fields that will be assigned to the entry.
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used.
                The value should be a standard language tag.
     * @return Assign a template successfully.
     */
    writeTemplateValueToEntry(args: { repoId: string, entryId: number, request?: PutTemplateRequest | undefined, culture?: string | null | undefined }): Promise<Entry>;
}

export class EntriesClient implements IEntriesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.laserfiche.com/repository";
    }

    
  async GetEntryListingForEach(args: {
    callback: (response: ODataValueContextOfIListOfEntry) => Promise<boolean>;
    repoId: string;
    entryId: number;
    groupByEntryType?: boolean;
    fields?: string[];
    formatFields?: boolean;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let {
      callback,
      repoId,
      entryId,
      groupByEntryType,
      fields,
      formatFields,
      prefer,
      culture,
      select,
      orderby,
      top,
      skip,
      count,
      maxPageSize,
    } = args;
    var response = await this.getEntryListing({
      repoId,
      entryId,
      groupByEntryType,
      fields,
      formatFields,
      prefer: CreateMaxPageSizePreferHeaderPayload(maxPageSize),
      culture,
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink != null) {
      response = await getNextLinkListing<ODataValueContextOfIListOfEntry>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processGetEntryListing,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }

  async GetFieldValuesForEach(args: {
    callback: (response: ODataValueContextOfIListOfFieldValue) => Promise<boolean>;
    repoId: string;
    entryId: number;
    prefer?: string;
    formatValue?: boolean;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let { callback, repoId, entryId, prefer, formatValue, culture, select, orderby, top, skip, count, maxPageSize } =
      args;
    var response = await this.getFieldValues({
      repoId,
      entryId,
      prefer: CreateMaxPageSizePreferHeaderPayload(maxPageSize),
      formatValue,
      culture,
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink != null) {
      response = await getNextLinkListing<ODataValueContextOfIListOfFieldValue>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processGetFieldValues,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }

  async GetLinkValuesFromEntryForEach(args: {
    callback: (response: ODataValueContextOfIListOfWEntryLinkInfo) => Promise<boolean>;
    repoId: string;
    entryId: number;
    prefer?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let { callback, repoId, entryId, prefer, select, orderby, top, skip, count, maxPageSize } = args;
    var response = await this.getLinkValuesFromEntry({
      repoId,
      entryId,
      prefer: CreateMaxPageSizePreferHeaderPayload(maxPageSize),
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink != null) {
      response = await getNextLinkListing<ODataValueContextOfIListOfWEntryLinkInfo>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processGetLinkValuesFromEntry,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }

  async GetTagsAssignedToEntryForEach(args: {
    callback: (response: ODataValueContextOfIListOfWTagInfo) => Promise<boolean>;
    repoId: string;
    entryId: number;
    prefer?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let { callback, repoId, entryId, prefer, select, orderby, top, skip, count, maxPageSize } = args;
    var response = await this.getTagsAssignedToEntry({
      repoId,
      entryId,
      prefer: CreateMaxPageSizePreferHeaderPayload(maxPageSize),
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink != null) {
      response = await getNextLinkListing<ODataValueContextOfIListOfWTagInfo>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processGetTagsAssignedToEntry,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }

  async getEntryListingNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfEntry> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<ODataValueContextOfIListOfEntry>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processGetEntryListing,
      nextLink,
      maxPageSize
    );
  }

  async getFieldValuesNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfFieldValue> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<ODataValueContextOfIListOfFieldValue>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processGetFieldValues,
      nextLink,
      maxPageSize
    );
  }

  async getLinkValuesFromEntryNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfWEntryLinkInfo> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<ODataValueContextOfIListOfWEntryLinkInfo>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processGetLinkValuesFromEntry,
      nextLink,
      maxPageSize
    );
  }

  async getTagsAssignedToEntryNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfWTagInfo> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<ODataValueContextOfIListOfWEntryLinkInfo>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processGetTagsAssignedToEntry,
      nextLink,
      maxPageSize
    );
  }

    /**
     * Creates a new document in the specified folder. Optionally sets metadata and electronic document component. Optional parameter: autoRename (default false). If an entry already exists with the given name, the entry will be automatically renamed. With this route, partial success is possible. The response returns multiple operation (entryCreate operation, setEdoc operation, setLinks operation, etc..) objects, which contain information about any errors that may have occurred during the creation. As long as the entryCreate operation succeeds, the entry will be created, even if all other operations fail.
     * @param repoId The requested repository ID.
     * @param parentEntryId The entry ID of the folder that the document will be created in.
     * @param fileName The created document's file name.
     * @param autoRename (optional) An optional query parameter used to indicate if the new document should be automatically
                renamed if an entry already exists with the given name in the folder. The default value is false.
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used.
                The value should be a standard language tag.
     * @param electronicDocument (optional) 
     * @param request (optional) 
     * @return Document creation is success.
     */
    importDocument(args: { repoId: string, parentEntryId: number, fileName: string, autoRename?: boolean | undefined, culture?: string | null | undefined, electronicDocument?: FileParameter | undefined, request?: PostEntryWithEdocMetadataRequest | undefined }): Promise<CreateEntryResult> {
        let { repoId, parentEntryId, fileName, autoRename, culture, electronicDocument, request } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{parentEntryId}/{fileName}?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (parentEntryId === undefined || parentEntryId === null)
            throw new Error("The parameter 'parentEntryId' must be defined.");
        url_ = url_.replace("{parentEntryId}", encodeURIComponent("" + parentEntryId));
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        if (autoRename === null)
            throw new Error("The parameter 'autoRename' cannot be null.");
        else if (autoRename !== undefined)
            url_ += "autoRename=" + encodeURIComponent("" + autoRename) + "&";
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (electronicDocument === null || electronicDocument === undefined)
            throw new Error("The parameter 'electronicDocument' cannot be null.");
        else
            content_.append("electronicDocument", electronicDocument.data, electronicDocument.fileName ? electronicDocument.fileName : "electronicDocument");
        if (request === null || request === undefined)
            throw new Error("The parameter 'request' cannot be null.");
        else
            content_.append("request", JSON.stringify(request));

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processImportDocument(_response);
        });
    }

    protected processImportDocument(response: Response): Promise<CreateEntryResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CreateEntryResult.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = CreateEntryResult.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = CreateEntryResult.fromJS(resultData404);
            return throwException("Parent entry is not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = CreateEntryResult.fromJS(resultData409);
            return throwException("Document creation is partial success.", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = CreateEntryResult.fromJS(resultData500);
            return throwException("Document creation is complete failure.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreateEntryResult>(null as any);
    }

    /**
     * Returns a single entry object. Provide an entry ID, and get the entry associated with that ID. Useful when detailed information about the entry is required, such as metadata, path information, etc. Allowed OData query options: Select. If the entry is a subtype (Folder, Document, or Shortcut), the entry will automatically be converted to include those model-specific properties.
     * @param repoId The requested repository ID.
     * @param entryId The requested entry ID.
     * @param select (optional) Limits the properties returned in the result.
     * @return Get entry successfully.
     */
    getEntry(args: { repoId: string, entryId: number, select?: string | null | undefined }): Promise<Entry> {
        let { repoId, entryId, select } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntry(_response);
        });
    }

    protected processGetEntry(response: Response): Promise<Entry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Entry.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Requested entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry>(null as any);
    }

    /**
     * Begins a task to delete an entry, and returns an operationToken. Provide an entry ID, and queue a delete task to remove it from the repository (includes nested objects if the entry is a Folder type). The entry will not be deleted immediately. Optionally include an audit reason ID and comment in the JSON body. This route returns an operationToken, and will run as an asynchronous operation. Check the progress via the Tasks/{operationToken} route.
     * @param repoId The requested repository ID.
     * @param entryId The requested entry ID.
     * @param request (optional) The submitted audit reason.
     * @return Delete entry operation start successfully.
     */
    deleteEntryInfo(args: { repoId: string, entryId: number, request?: DeleteEntryWithAuditReason | undefined }): Promise<AcceptedOperation> {
        let { repoId, entryId, request } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEntryInfo(_response);
        });
    }

    protected processDeleteEntryInfo(response: Response): Promise<AcceptedOperation> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = AcceptedOperation.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Operation limit or request limit reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AcceptedOperation>(null as any);
    }

    /**
     * Moves and/or renames an entry. Move and/or rename an entry by passing in the new parent folder ID or name in the JSON body. Optional parameter: autoRename (default false). If an entry already exists with the given name, the entry will be automatically renamed.
     * @param repoId The requested repository ID.
     * @param entryId The requested entry ID.
     * @param request (optional) The request containing the folder ID that the entry will be moved to and the new name
                the entry will be renamed to.
     * @param autoRename (optional) An optional query parameter used to indicate if the entry should be automatically
                renamed if another entry already exists with the same name in the folder. The default value is false.
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used.
                The value should be a standard language tag.
     * @return Moves and/or renames an entry successfully.
     */
    moveOrRenameDocument(args: { repoId: string, entryId: number, request?: PatchEntryRequest | undefined, autoRename?: boolean | undefined, culture?: string | null | undefined }): Promise<Entry> {
        let { repoId, entryId, request, autoRename, culture } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (autoRename === null)
            throw new Error("The parameter 'autoRename' cannot be null.");
        else if (autoRename !== undefined)
            url_ += "autoRename=" + encodeURIComponent("" + autoRename) + "&";
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMoveOrRenameDocument(_response);
        });
    }

    protected processMoveOrRenameDocument(response: Response): Promise<Entry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Entry.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Entry name conflicts.", status, _responseText, _headers, result409);
            });
        } else if (status === 423) {
            return response.text().then((_responseText) => {
            let result423: any = null;
            let resultData423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result423 = ProblemDetails.fromJS(resultData423);
            return throwException("Entry is locked.", status, _responseText, _headers, result423);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry>(null as any);
    }

    /**
     * Returns the children entries of a folder in the repository. Provide an entry ID (must be a folder), and get a paged listing of entries in that folder. Used as a way of navigating through the repository. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer. OData $OrderBy syntax should follow: "PropertyName direction,PropertyName2 direction". Sort order can be either value "asc" or "desc". Optional query parameters: groupByOrderType (bool). This query parameter decides if results are returned in groups based on their entry type. Entries returned in the listing are not automatically converted to their subtype (Folder, Shortcut, Document), so clients who want model-specific information should request it via the GET entry by ID route. Optionally returns field values for the entries in the folder. Each field name needs to be specified in the request. Maximum limit of 10 field names. If field values are requested, only the first value is returned if it is a multi value field. Null or Empty field values should not be used to determine if a field is assigned to the entry.
     * @param repoId The requested repository ID.
     * @param entryId The folder ID.
     * @param groupByEntryType (optional) An optional query parameter used to indicate if the result should be grouped by entry type or not.
     * @param fields (optional) Optional array of field names. Field values corresponding to the given field names will be returned for each entry.
     * @param formatFields (optional) Boolean for if field values should be formatted. Only applicable if Fields are specified.
     * @param prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag. The formatFields query parameter must be set to true, otherwise
                culture will not be used for formatting.
     * @param select (optional) Limits the properties returned in the result.
     * @param orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param top (optional) Limits the number of items returned from a collection.
     * @param skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get the children entries of a Folder successfully.
     */
    getEntryListing(args: { repoId: string, entryId: number, groupByEntryType?: boolean | undefined, fields?: string[] | null | undefined, formatFields?: boolean | undefined, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfEntry> {
        let { repoId, entryId, groupByEntryType, fields, formatFields, prefer, culture, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}/Laserfiche.Repository.Folder/children?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (groupByEntryType === null)
            throw new Error("The parameter 'groupByEntryType' cannot be null.");
        else if (groupByEntryType !== undefined)
            url_ += "groupByEntryType=" + encodeURIComponent("" + groupByEntryType) + "&";
        if (fields !== undefined && fields !== null)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (formatFields === null)
            throw new Error("The parameter 'formatFields' cannot be null.");
        else if (formatFields !== undefined)
            url_ += "formatFields=" + encodeURIComponent("" + formatFields) + "&";
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Prefer": prefer !== undefined && prefer !== null ? "" + prefer : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntryListing(_response);
        });
    }

    protected processGetEntryListing(response: Response): Promise<ODataValueContextOfIListOfEntry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueContextOfIListOfEntry.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueContextOfIListOfEntry>(null as any);
    }

    /**
     * Create/copy a new child entry in the designated folder. Provide the parent folder ID, and based on the request body, copy or create a folder/shortcut as a child entry of the designated folder. Optional parameter: autoRename (default false). If an entry already exists with the given name, the entry will be automatically renamed.
     * @param repoId The requested repository ID.
     * @param entryId The folder ID that the entry will be created in.
     * @param request (optional) The entry to create.
     * @param autoRename (optional) An optional query parameter used to indicate if the new entry should be automatically
                renamed if an entry already exists with the given name in the folder. The default value is false.
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used.
                The value should be a standard language tag.
     * @return Created a new child entry successfully.
     */
    createOrCopyEntry(args: { repoId: string, entryId: number, request?: PostEntryChildrenRequest | undefined, autoRename?: boolean | undefined, culture?: string | null | undefined }): Promise<Entry> {
        let { repoId, entryId, request, autoRename, culture } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}/Laserfiche.Repository.Folder/children?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (autoRename === null)
            throw new Error("The parameter 'autoRename' cannot be null.");
        else if (autoRename !== undefined)
            url_ += "autoRename=" + encodeURIComponent("" + autoRename) + "&";
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateOrCopyEntry(_response);
        });
    }

    protected processCreateOrCopyEntry(response: Response): Promise<Entry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Entry.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Entry name conflicts.", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry>(null as any);
    }

    /**
     * Returns the fields assigned to an entry. Provide an entry ID, and get a paged listing of all fields assigned to that entry. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param repoId The requested repository ID.
     * @param entryId The requested entry ID.
     * @param prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param formatValue (optional) An optional query parameter used to indicate if the field values should be formatted.
                The default value is false.
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag. The formatValue query parameter must be set to true, otherwise
                culture will not be used for formatting.
     * @param select (optional) Limits the properties returned in the result.
     * @param orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param top (optional) Limits the number of items returned from a collection.
     * @param skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get field values successfully.
     */
    getFieldValues(args: { repoId: string, entryId: number, prefer?: string | null | undefined, formatValue?: boolean | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfFieldValue> {
        let { repoId, entryId, prefer, formatValue, culture, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}/fields?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (formatValue === null)
            throw new Error("The parameter 'formatValue' cannot be null.");
        else if (formatValue !== undefined)
            url_ += "formatValue=" + encodeURIComponent("" + formatValue) + "&";
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Prefer": prefer !== undefined && prefer !== null ? "" + prefer : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFieldValues(_response);
        });
    }

    protected processGetFieldValues(response: Response): Promise<ODataValueContextOfIListOfFieldValue> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueContextOfIListOfFieldValue.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueContextOfIListOfFieldValue>(null as any);
    }

    /**
     * Update field values assigned to an entry. Provide the new field values to assign to the entry, and remove/reset all previously assigned field values.  This is an overwrite action. The request body must include all desired field values, including any existing field values that should remain assigned to the entry. Field values that are not included in the request will be deleted from the entry. If the field value that is not included is part of a template, it will still be assigned (as required by the template), but its value will be reset.
     * @param repoId The requested repository ID.
     * @param entryId The entry ID of the entry that will have its fields updated.
     * @param fieldsToUpdate (optional) 
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used.
                The value should be a standard language tag.
     * @return Update field values successfully.
     */
    assignFieldValues(args: { repoId: string, entryId: number, fieldsToUpdate?: { [key: string]: FieldToUpdate; } | undefined, culture?: string | null | undefined }): Promise<ODataValueOfIListOfFieldValue> {
        let { repoId, entryId, fieldsToUpdate, culture } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}/fields?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(fieldsToUpdate);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAssignFieldValues(_response);
        });
    }

    protected processAssignFieldValues(response: Response): Promise<ODataValueOfIListOfFieldValue> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueOfIListOfFieldValue.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Requested entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 423) {
            return response.text().then((_responseText) => {
            let result423: any = null;
            let resultData423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result423 = ProblemDetails.fromJS(resultData423);
            return throwException("Entry is locked.", status, _responseText, _headers, result423);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueOfIListOfFieldValue>(null as any);
    }

    /**
     * Get the tags assigned to an entry. Provide an entry ID, and get a paged listing of tags assigned to that entry. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param repoId The requested repository ID.
     * @param entryId The requested entry ID.
     * @param prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param select (optional) Limits the properties returned in the result.
     * @param orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param top (optional) Limits the number of items returned from a collection.
     * @param skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get entry tags successfully.
     */
    getTagsAssignedToEntry(args: { repoId: string, entryId: number, prefer?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfWTagInfo> {
        let { repoId, entryId, prefer, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}/tags?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Prefer": prefer !== undefined && prefer !== null ? "" + prefer : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTagsAssignedToEntry(_response);
        });
    }

    protected processGetTagsAssignedToEntry(response: Response): Promise<ODataValueContextOfIListOfWTagInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueContextOfIListOfWTagInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueContextOfIListOfWTagInfo>(null as any);
    }

    /**
     * Assign tags to an entry. Provide an entry ID and a list of tags to assign to that entry. This is an overwrite action. The request must include all tags to assign to the entry, including existing tags that should remain assigned to the entry.
     * @param repoId The requested repository ID.
     * @param entryId The requested entry ID.
     * @param tagsToAdd (optional) The tags to add.
     * @return Assign tags to an entry successfully.
     */
    assignTags(args: { repoId: string, entryId: number, tagsToAdd?: PutTagRequest | undefined }): Promise<ODataValueOfIListOfWTagInfo> {
        let { repoId, entryId, tagsToAdd } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}/tags";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tagsToAdd);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAssignTags(_response);
        });
    }

    protected processAssignTags(response: Response): Promise<ODataValueOfIListOfWTagInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueOfIListOfWTagInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 423) {
            return response.text().then((_responseText) => {
            let result423: any = null;
            let resultData423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result423 = ProblemDetails.fromJS(resultData423);
            return throwException("Entry is locked.", status, _responseText, _headers, result423);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueOfIListOfWTagInfo>(null as any);
    }

    /**
     * Assign links to an entry. Provide an entry ID and a list of links to assign to that entry. This is an overwrite action. The request must include all links to assign to the entry, including existing links that should remain assigned to the entry.
     * @param repoId The request repository ID.
     * @param entryId The requested entry ID.
     * @param linksToAdd (optional) 
     * @return Assign links to an entry successfully.
     */
    assignEntryLinks(args: { repoId: string, entryId: number, linksToAdd?: PutLinksRequest[] | undefined }): Promise<ODataValueOfIListOfWEntryLinkInfo> {
        let { repoId, entryId, linksToAdd } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}/links";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(linksToAdd);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAssignEntryLinks(_response);
        });
    }

    protected processAssignEntryLinks(response: Response): Promise<ODataValueOfIListOfWEntryLinkInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueOfIListOfWEntryLinkInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 423) {
            return response.text().then((_responseText) => {
            let result423: any = null;
            let resultData423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result423 = ProblemDetails.fromJS(resultData423);
            return throwException("Entry is locked.", status, _responseText, _headers, result423);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueOfIListOfWEntryLinkInfo>(null as any);
    }

    /**
     * Get the links assigned to an entry. Provide an entry ID, and get a paged listing of links assigned to that entry. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param repoId The requested repository ID.
     * @param entryId The requested entry ID.
     * @param prefer (optional) An optional odata header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param select (optional) Limits the properties returned in the result.
     * @param orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param top (optional) Limits the number of items returned from a collection.
     * @param skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get links successfully.
     */
    getLinkValuesFromEntry(args: { repoId: string, entryId: number, prefer?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfWEntryLinkInfo> {
        let { repoId, entryId, prefer, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}/links?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Prefer": prefer !== undefined && prefer !== null ? "" + prefer : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLinkValuesFromEntry(_response);
        });
    }

    protected processGetLinkValuesFromEntry(response: Response): Promise<ODataValueContextOfIListOfWEntryLinkInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueContextOfIListOfWEntryLinkInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueContextOfIListOfWEntryLinkInfo>(null as any);
    }

    /**
     * Copy a new child entry in the designated folder async, and potentially return an operationToken. Provide the parent folder ID, and copy an entry as a child of the designated folder. Optional parameter: autoRename (default false). If an entry already exists with the given name, the entry will be automatically renamed.  The status of the operation can be checked via the Tasks/{operationToken} route.
     * @param repoId The requested repository ID.
     * @param entryId The folder ID that the entry will be created in.
     * @param request (optional) Copy entry request.
     * @param autoRename (optional) An optional query parameter used to indicate if the new entry should be automatically
                renamed if an entry already exists with the given name in the folder. The default value is false.
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used.
                The value should be a standard language tag.
     * @return Copy entry operation is started successfully.
     */
    copyEntry(args: { repoId: string, entryId: number, request?: CopyAsyncRequest | undefined, autoRename?: boolean | undefined, culture?: string | null | undefined }): Promise<AcceptedOperation> {
        let { repoId, entryId, request, autoRename, culture } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}/Laserfiche.Repository.Folder/CopyAsync?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (autoRename === null)
            throw new Error("The parameter 'autoRename' cannot be null.");
        else if (autoRename !== undefined)
            url_ += "autoRename=" + encodeURIComponent("" + autoRename) + "&";
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCopyEntry(_response);
        });
    }

    protected processCopyEntry(response: Response): Promise<AcceptedOperation> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = AcceptedOperation.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Operation limit or request limit reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AcceptedOperation>(null as any);
    }

    /**
     * Delete the edoc associated with the provided entry ID.
     * @param repoId The requested repository ID.
     * @param entryId The requested document ID.
     * @return Deleted edoc successfully.
     */
    deleteDocument(args: { repoId: string, entryId: number }): Promise<ODataValueOfBoolean> {
        let { repoId, entryId } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}/Laserfiche.Repository.Document/edoc";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDocument(_response);
        });
    }

    protected processDeleteDocument(response: Response): Promise<ODataValueOfBoolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueOfBoolean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 423) {
            return response.text().then((_responseText) => {
            let result423: any = null;
            let resultData423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result423 = ProblemDetails.fromJS(resultData423);
            return throwException("Entry is locked.", status, _responseText, _headers, result423);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueOfBoolean>(null as any);
    }

    /**
     * Get information about the edoc content of an entry, without downloading the edoc in its entirety. Provide an entry ID, and get back the Content-Type and Content-Length in the response headers. This route does not provide a way to download the actual edoc. Instead, it just gives metadata information about the edoc associated with the entry.
     * @param repoId The requested repository ID.
     * @param entryId The requested document ID.
     * @return Get edoc info successfully.
     */
    getDocumentContentType(args: { repoId: string, entryId: number }): Promise<void> {
        let { repoId, entryId } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}/Laserfiche.Repository.Document/edoc";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "HEAD",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDocumentContentType(_response);
        });
    }

    protected processGetDocumentContentType(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 423) {
            return response.text().then((_responseText) => {
            let result423: any = null;
            let resultData423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result423 = ProblemDetails.fromJS(resultData423);
            return throwException("Entry is locked.", status, _responseText, _headers, result423);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get an entry's edoc resource in a stream format. Provide an entry ID, and get the edoc resource as part of the response content. Optional header: Range. Use the Range header (single range with byte unit) to retrieve partial content of the edoc, rather than the entire edoc.
     * @param repoId The requested repository ID.
     * @param entryId The requested document ID.
     * @param range (optional) An optional header used to retrieve partial content of the edoc. Only supports single
                range with byte unit.
     * @return Get edoc successfully.
     */
    exportDocument(args: { repoId: string, entryId: number, range?: string | null | undefined }): Promise<FileResponse> {
        let { repoId, entryId, range } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}/Laserfiche.Repository.Document/edoc";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Range": range !== undefined && range !== null ? "" + range : "",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExportDocument(_response);
        });
    }

    protected processExportDocument(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 423) {
            return response.text().then((_responseText) => {
            let result423: any = null;
            let resultData423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result423 = ProblemDetails.fromJS(resultData423);
            return throwException("Entry is locked.", status, _responseText, _headers, result423);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Delete the pages associated with the provided entry ID. If no pageRange is specified, all pages will be deleted. Optional parameter: pageRange (default empty). The value should be a comma-seperated string which contains non-overlapping single values, or page ranges. Ex: "1,2,3", "1-3,5", "2-7,10-12."
     * @param repoId The requested repository ID.
     * @param entryId The requested document ID.
     * @param pageRange (optional) The pages to be deleted.
     * @return Deleted pages successfully.
     */
    deletePages(args: { repoId: string, entryId: number, pageRange?: string | null | undefined }): Promise<ODataValueOfBoolean> {
        let { repoId, entryId, pageRange } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}/Laserfiche.Repository.Document/pages?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (pageRange !== undefined && pageRange !== null)
            url_ += "pageRange=" + encodeURIComponent("" + pageRange) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeletePages(_response);
        });
    }

    protected processDeletePages(response: Response): Promise<ODataValueOfBoolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueOfBoolean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 423) {
            return response.text().then((_responseText) => {
            let result423: any = null;
            let resultData423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result423 = ProblemDetails.fromJS(resultData423);
            return throwException("Entry is locked.", status, _responseText, _headers, result423);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueOfBoolean>(null as any);
    }

    /**
     * Get an entry's edoc resource in a stream format while including an audit reason. Provide an entry ID and audit reason/comment in the request body, and get the edoc resource as part of the response content. Optional header: Range. Use the Range header (single range with byte unit) to retrieve partial content of the edoc, rather than the entire edoc. This route is identical to the GET edoc route, but allows clients to include an audit reason when downloading the edoc.
     * @param repoId The requested repository ID.
     * @param entryId The requested document ID.
     * @param request (optional) 
     * @param range (optional) An optional header used to retrieve partial content of the edoc. Only supports single
                range with byte unit.
     * @return Get edoc successfully.
     */
    exportDocumentWithAuditReason(args: { repoId: string, entryId: number, request?: GetEdocWithAuditReasonRequest | undefined, range?: string | null | undefined }): Promise<FileResponse> {
        let { repoId, entryId, request, range } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}/Laserfiche.Repository.Document/GetEdocWithAuditReason";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Range": range !== undefined && range !== null ? "" + range : "",
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExportDocumentWithAuditReason(_response);
        });
    }

    protected processExportDocumentWithAuditReason(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 423) {
            return response.text().then((_responseText) => {
            let result423: any = null;
            let resultData423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result423 = ProblemDetails.fromJS(resultData423);
            return throwException("Entry is locked.", status, _responseText, _headers, result423);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get dynamic field logic values with the current values of the fields in the template. Provide an entry ID and field values in the JSON body to get dynamic field logic values.  Independent and non-dynamic fields in the request body will be ignored, and only related dynamic field logic values for the assigned template will be returned.
     * @param repoId The requested repository ID.
     * @param entryId The requested entry ID.
     * @param request (optional) 
     * @return Get dynamic field logic values successfully.
     */
    getDynamicFieldValues(args: { repoId: string, entryId: number, request?: GetDynamicFieldLogicValueRequest | undefined }): Promise<{ [key: string]: string[]; }> {
        let { repoId, entryId, request } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}/fields/GetDynamicFieldLogicValue";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDynamicFieldValues(_response);
        });
    }

    protected processGetDynamicFieldValues(response: Response): Promise<{ [key: string]: string[]; }> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : [];
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: string[]; }>(null as any);
    }

    /**
     * Remove the currently assigned template from the specified entry. Provide an entry ID to clear template value on. If the entry does not have a template assigned, no change will be made.
     * @param repoId The requested repository ID.
     * @param entryId The ID of the entry that will have its template removed.
     * @return Remove the currently assigned template successfully.
     */
    deleteAssignedTemplate(args: { repoId: string, entryId: number }): Promise<Entry> {
        let { repoId, entryId } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}/template";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteAssignedTemplate(_response);
        });
    }

    protected processDeleteAssignedTemplate(response: Response): Promise<Entry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Entry.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 423) {
            return response.text().then((_responseText) => {
            let result423: any = null;
            let resultData423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result423 = ProblemDetails.fromJS(resultData423);
            return throwException("Entry is locked.", status, _responseText, _headers, result423);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry>(null as any);
    }

    /**
     * Assign a template to an entry. Provide an entry ID, template name, and a list of template fields to assign to that entry. Only template values will be modified. Any existing independent fields on the entry will not be modified, nor will they be added if included in the request. The only modification to fields will only occur on templated fields. If the previously assigned template includes common template fields as the newly assigned template, the common field values will not be modified.
     * @param repoId The requested repository ID.
     * @param entryId The ID of entry that will have its template updated.
     * @param request (optional) The template and template fields that will be assigned to the entry.
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used.
                The value should be a standard language tag.
     * @return Assign a template successfully.
     */
    writeTemplateValueToEntry(args: { repoId: string, entryId: number, request?: PutTemplateRequest | undefined, culture?: string | null | undefined }): Promise<Entry> {
        let { repoId, entryId, request, culture } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}/template?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWriteTemplateValueToEntry(_response);
        });
    }

    protected processWriteTemplateValueToEntry(response: Response): Promise<Entry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Entry.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 423) {
            return response.text().then((_responseText) => {
            let result423: any = null;
            let resultData423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result423 = ProblemDetails.fromJS(resultData423);
            return throwException("Entry is locked.", status, _responseText, _headers, result423);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry>(null as any);
    }
}

export interface IAttributesClient {

    /**
     * Returns the attribute key value pairs associated with the authenticated user. Alternatively, return only the attribute key value pairs that are associated with the "Everyone" group. Attribute keys can be used with subsequent calls to get specific attribute values. Default page size: 100. Allowed OData query options: Select, Count, OrderBy, Skip, Top, SkipToken, Prefer. Optional query parameters: everyone (bool, default false). When true, this route does not return the attributes that are tied to the currently authenticated user, but rather the attributes assigned to the "Everyone" group. Note when this is true, the response does not include both the "Everyone" groups attribute and the currently authenticated user, but only the "Everyone" groups.
     * @param repoId The requested repository ID.
     * @param everyone (optional) Boolean value that indicates whether to return attributes key value pairs associated with everyone or the currently authenticated user.
     * @param prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param select (optional) Limits the properties returned in the result.
     * @param orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param top (optional) Limits the number of items returned from a collection.
     * @param skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get trustee attribute keys successfully.
     */
    getTrusteeAttributeKeyValuePairs(args: { repoId: string, everyone?: boolean | undefined, prefer?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfListOfAttribute>;

    /**
     * Returns the attribute associated with the key. Alternatively, return the attribute associated with the key within "Everyone" group. Optional query parameters: everyone (bool, default false). When true, the server only searches for the attribute value with the given key upon the authenticated users attributes. If false, only the authenticated users attributes will be queried.
     * @param repoId The requested repository ID.
     * @param attributeKey The requested attribute key.
     * @param everyone (optional) Boolean value that indicates whether to return attributes associated with everyone or the currently authenticated user.
     * @return Get trustee attribute value successfully.
     */
    getTrusteeAttributeValueByKey(args: { repoId: string, attributeKey: string, everyone?: boolean | undefined }): Promise<Attribute>;
}

export class AttributesClient implements IAttributesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.laserfiche.com/repository";
    }

    
  async GetTrusteeAttributeKeyValuePairsForEach(args: {
    callback: (response: ODataValueContextOfListOfAttribute) => Promise<boolean>;
    repoId: string;
    everyone?: boolean;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let { callback, repoId, everyone, select, orderby, top, skip, count, maxPageSize } = args;
    var response = await this.getTrusteeAttributeKeyValuePairs({
      repoId,
      everyone,
      prefer: CreateMaxPageSizePreferHeaderPayload(maxPageSize),
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink != null) {
      response = await getNextLinkListing<ODataValueContextOfListOfAttribute>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processGetTrusteeAttributeKeyValuePairs,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }
  async getTrusteeAttributeKeyValuePairsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfListOfAttribute> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<ODataValueContextOfListOfAttribute>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processGetTrusteeAttributeKeyValuePairs,
      nextLink,
      maxPageSize
    );
  }

    /**
     * Returns the attribute key value pairs associated with the authenticated user. Alternatively, return only the attribute key value pairs that are associated with the "Everyone" group. Attribute keys can be used with subsequent calls to get specific attribute values. Default page size: 100. Allowed OData query options: Select, Count, OrderBy, Skip, Top, SkipToken, Prefer. Optional query parameters: everyone (bool, default false). When true, this route does not return the attributes that are tied to the currently authenticated user, but rather the attributes assigned to the "Everyone" group. Note when this is true, the response does not include both the "Everyone" groups attribute and the currently authenticated user, but only the "Everyone" groups.
     * @param repoId The requested repository ID.
     * @param everyone (optional) Boolean value that indicates whether to return attributes key value pairs associated with everyone or the currently authenticated user.
     * @param prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param select (optional) Limits the properties returned in the result.
     * @param orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param top (optional) Limits the number of items returned from a collection.
     * @param skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get trustee attribute keys successfully.
     */
    getTrusteeAttributeKeyValuePairs(args: { repoId: string, everyone?: boolean | undefined, prefer?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfListOfAttribute> {
        let { repoId, everyone, prefer, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Attributes?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (everyone === null)
            throw new Error("The parameter 'everyone' cannot be null.");
        else if (everyone !== undefined)
            url_ += "everyone=" + encodeURIComponent("" + everyone) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Prefer": prefer !== undefined && prefer !== null ? "" + prefer : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTrusteeAttributeKeyValuePairs(_response);
        });
    }

    protected processGetTrusteeAttributeKeyValuePairs(response: Response): Promise<ODataValueContextOfListOfAttribute> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueContextOfListOfAttribute.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueContextOfListOfAttribute>(null as any);
    }

    /**
     * Returns the attribute associated with the key. Alternatively, return the attribute associated with the key within "Everyone" group. Optional query parameters: everyone (bool, default false). When true, the server only searches for the attribute value with the given key upon the authenticated users attributes. If false, only the authenticated users attributes will be queried.
     * @param repoId The requested repository ID.
     * @param attributeKey The requested attribute key.
     * @param everyone (optional) Boolean value that indicates whether to return attributes associated with everyone or the currently authenticated user.
     * @return Get trustee attribute value successfully.
     */
    getTrusteeAttributeValueByKey(args: { repoId: string, attributeKey: string, everyone?: boolean | undefined }): Promise<Attribute> {
        let { repoId, attributeKey, everyone } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Attributes/{attributeKey}?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (attributeKey === undefined || attributeKey === null)
            throw new Error("The parameter 'attributeKey' must be defined.");
        url_ = url_.replace("{attributeKey}", encodeURIComponent("" + attributeKey));
        if (everyone === null)
            throw new Error("The parameter 'everyone' cannot be null.");
        else if (everyone !== undefined)
            url_ += "everyone=" + encodeURIComponent("" + everyone) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTrusteeAttributeValueByKey(_response);
        });
    }

    protected processGetTrusteeAttributeValueByKey(response: Response): Promise<Attribute> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Attribute.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Requested attribute key not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Attribute>(null as any);
    }
}

export interface IFieldDefinitionsClient {

    /**
     * Returns a single field definition associated with the specified ID.  Useful when a route provides a minimal amount of details and more information about the specific field definition is needed. Allowed OData query options: Select
     * @param repoId The requested repository ID.
     * @param fieldDefinitionId The requested field definition ID.
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag.
     * @param select (optional) Limits the properties returned in the result.
     * @return Get field definition successfully.
     */
    getFieldDefinitionById(args: { repoId: string, fieldDefinitionId: number, culture?: string | null | undefined, select?: string | null | undefined }): Promise<WFieldInfo>;

    /**
     * Returns a paged listing of field definitions available in the specified repository. Useful when trying to find a list of all field definitions available, rather than only those assigned to a specific entry/template. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param repoId The requested repository ID.
     * @param prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag.
     * @param select (optional) Limits the properties returned in the result.
     * @param orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param top (optional) Limits the number of items returned from a collection.
     * @param skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get field definitions successfully.
     */
    getFieldDefinitions(args: { repoId: string, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfWFieldInfo>;
}

export class FieldDefinitionsClient implements IFieldDefinitionsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.laserfiche.com/repository";
    }

    
  async GetFieldDefinitionsForEach(args: {
    callback: (response: ODataValueContextOfIListOfWFieldInfo) => Promise<boolean>;
    repoId: string;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let { callback, repoId, prefer, culture, select, orderby, top, skip, count, maxPageSize } = args;
    var response = await this.getFieldDefinitions({
      repoId,
      prefer: CreateMaxPageSizePreferHeaderPayload(maxPageSize),
      culture,
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink != null) {
      response = await getNextLinkListing<ODataValueContextOfIListOfWFieldInfo>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processGetFieldDefinitions,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }
  async getFieldDefinitionsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfWFieldInfo> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<ODataValueContextOfIListOfWFieldInfo>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processGetFieldDefinitions,
      nextLink,
      maxPageSize
    );
  }

    /**
     * Returns a single field definition associated with the specified ID.  Useful when a route provides a minimal amount of details and more information about the specific field definition is needed. Allowed OData query options: Select
     * @param repoId The requested repository ID.
     * @param fieldDefinitionId The requested field definition ID.
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag.
     * @param select (optional) Limits the properties returned in the result.
     * @return Get field definition successfully.
     */
    getFieldDefinitionById(args: { repoId: string, fieldDefinitionId: number, culture?: string | null | undefined, select?: string | null | undefined }): Promise<WFieldInfo> {
        let { repoId, fieldDefinitionId, culture, select } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/FieldDefinitions/{fieldDefinitionId}?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (fieldDefinitionId === undefined || fieldDefinitionId === null)
            throw new Error("The parameter 'fieldDefinitionId' must be defined.");
        url_ = url_.replace("{fieldDefinitionId}", encodeURIComponent("" + fieldDefinitionId));
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFieldDefinitionById(_response);
        });
    }

    protected processGetFieldDefinitionById(response: Response): Promise<WFieldInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WFieldInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Requested field definition id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WFieldInfo>(null as any);
    }

    /**
     * Returns a paged listing of field definitions available in the specified repository. Useful when trying to find a list of all field definitions available, rather than only those assigned to a specific entry/template. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param repoId The requested repository ID.
     * @param prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag.
     * @param select (optional) Limits the properties returned in the result.
     * @param orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param top (optional) Limits the number of items returned from a collection.
     * @param skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get field definitions successfully.
     */
    getFieldDefinitions(args: { repoId: string, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfWFieldInfo> {
        let { repoId, prefer, culture, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/FieldDefinitions?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Prefer": prefer !== undefined && prefer !== null ? "" + prefer : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFieldDefinitions(_response);
        });
    }

    protected processGetFieldDefinitions(response: Response): Promise<ODataValueContextOfIListOfWFieldInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueContextOfIListOfWFieldInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueContextOfIListOfWFieldInfo>(null as any);
    }
}

export interface IRepositoriesClient {

    /**
     * Get the repository resource list that current user has access to.
     * @return Get the respository resource list successfully.
     */
    getRepositoryList(args: {  }): Promise<RepositoryInfo[]>;
}

export class RepositoriesClient implements IRepositoriesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.laserfiche.com/repository";
    }

    /**
     * Get the repository resource list that current user has access to.
     * @return Get the respository resource list successfully.
     */
    getRepositoryList(args: {  }): Promise<RepositoryInfo[]> {
        let {  } = args;
        let url_ = this.baseUrl + "/v1/Repositories";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRepositoryList(_response);
        });
    }

    protected processGetRepositoryList(response: Response): Promise<RepositoryInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RepositoryInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return throwException("Account does not have access to any repository", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RepositoryInfo[]>(null as any);
    }
}

export interface IServerSessionClient {

    /**
     * Invalidates the server session. Acts as a "logout" operation, and invalidates the session associated with the provided access token. This method should be used when the client wants to clean up the current session.
     * @param repoId The requested repository ID.
     * @return Invalidate the server session successfully.
     */
    invalidateServerSession(args: { repoId: string }): Promise<ODataValueOfBoolean>;

    /**
     * Refreshes the session associated with the access token. This is only necessary if you want to keep the same session alive, otherwise a new session will be automatically created when the session expires. When a client application wants to keep a session alive that has been idle for an hour, this route can be used to refresh the expiration timer associated with the access token.
     * @param repoId The requested repository ID.
     * @return Refresh the session successfully.
     */
    refreshServerSession(args: { repoId: string }): Promise<ODataValueOfDateTime>;

    /**
     * Deprecated. This function is a no-op, always returns 200.
     * @param repoId The requested repository ID.
     * @return Create the session successfully.
     */
    createServerSession(args: { repoId: string }): Promise<ODataValueOfBoolean>;
}

export class ServerSessionClient implements IServerSessionClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.laserfiche.com/repository";
    }

    /**
     * Invalidates the server session. Acts as a "logout" operation, and invalidates the session associated with the provided access token. This method should be used when the client wants to clean up the current session.
     * @param repoId The requested repository ID.
     * @return Invalidate the server session successfully.
     */
    invalidateServerSession(args: { repoId: string }): Promise<ODataValueOfBoolean> {
        let { repoId } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/ServerSession/Invalidate";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInvalidateServerSession(_response);
        });
    }

    protected processInvalidateServerSession(response: Response): Promise<ODataValueOfBoolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueOfBoolean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueOfBoolean>(null as any);
    }

    /**
     * Refreshes the session associated with the access token. This is only necessary if you want to keep the same session alive, otherwise a new session will be automatically created when the session expires. When a client application wants to keep a session alive that has been idle for an hour, this route can be used to refresh the expiration timer associated with the access token.
     * @param repoId The requested repository ID.
     * @return Refresh the session successfully.
     */
    refreshServerSession(args: { repoId: string }): Promise<ODataValueOfDateTime> {
        let { repoId } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/ServerSession/Refresh";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefreshServerSession(_response);
        });
    }

    protected processRefreshServerSession(response: Response): Promise<ODataValueOfDateTime> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueOfDateTime.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueOfDateTime>(null as any);
    }

    /**
     * Deprecated. This function is a no-op, always returns 200.
     * @param repoId The requested repository ID.
     * @return Create the session successfully.
     */
    createServerSession(args: { repoId: string }): Promise<ODataValueOfBoolean> {
        let { repoId } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/ServerSession/Create";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateServerSession(_response);
        });
    }

    protected processCreateServerSession(response: Response): Promise<ODataValueOfBoolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueOfBoolean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueOfBoolean>(null as any);
    }
}

export interface ITasksClient {

    /**
     * Returns the status of an operation. Provide an operationToken (returned in other asynchronous routes) to get the operation status, progress, and any errors that may have occurred. When the operation is completed, the Location header can be inspected as a link to the modified resources (if relevant). OperationStatus can be one of the following values: NotStarted, InProgress, Completed, or Failed.
     * @param repoId The requested repository ID.
     * @param operationToken The operation token.
     * @return Get completed operation status with no result successfully.
     */
    getOperationStatusAndProgress(args: { repoId: string, operationToken: string }): Promise<OperationProgress>;

    /**
     * Cancels an operation. Provide an operationToken to cancel the operation, if possible. Should be used if an operation was created in error, or is no longer necessary. Rollbacks must be done manually. For example, if a copy operation is started and is halfway complete when canceled, the client application is responsible for cleaning up the files that were successfully copied before the operation was canceled.
     * @param repoId The requested repository ID.
     * @param operationToken The operation token
     * @return Cancel operation successfully.
     */
    cancelOperation(args: { repoId: string, operationToken: string }): Promise<void>;
}

export class TasksClient implements ITasksClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.laserfiche.com/repository";
    }

    /**
     * Returns the status of an operation. Provide an operationToken (returned in other asynchronous routes) to get the operation status, progress, and any errors that may have occurred. When the operation is completed, the Location header can be inspected as a link to the modified resources (if relevant). OperationStatus can be one of the following values: NotStarted, InProgress, Completed, or Failed.
     * @param repoId The requested repository ID.
     * @param operationToken The operation token.
     * @return Get completed operation status with no result successfully.
     */
    getOperationStatusAndProgress(args: { repoId: string, operationToken: string }): Promise<OperationProgress> {
        let { repoId, operationToken } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Tasks/{operationToken}";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (operationToken === undefined || operationToken === null)
            throw new Error("The parameter 'operationToken' must be defined.");
        url_ = url_.replace("{operationToken}", encodeURIComponent("" + operationToken));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOperationStatusAndProgress(_response);
        });
    }

    protected processGetOperationStatusAndProgress(response: Response): Promise<OperationProgress> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OperationProgress.fromJS(resultData200);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = OperationProgress.fromJS(resultData201);
            return result201;
            });
        } else if (status === 202) {
            return response.text().then((_responseText) => {
            let result202: any = null;
            let resultData202 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result202 = OperationProgress.fromJS(resultData202);
            return result202;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request operation token not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OperationProgress>(null as any);
    }

    /**
     * Cancels an operation. Provide an operationToken to cancel the operation, if possible. Should be used if an operation was created in error, or is no longer necessary. Rollbacks must be done manually. For example, if a copy operation is started and is halfway complete when canceled, the client application is responsible for cleaning up the files that were successfully copied before the operation was canceled.
     * @param repoId The requested repository ID.
     * @param operationToken The operation token
     * @return Cancel operation successfully.
     */
    cancelOperation(args: { repoId: string, operationToken: string }): Promise<void> {
        let { repoId, operationToken } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Tasks/{operationToken}";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (operationToken === undefined || operationToken === null)
            throw new Error("The parameter 'operationToken' must be defined.");
        url_ = url_.replace("{operationToken}", encodeURIComponent("" + operationToken));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCancelOperation(_response);
        });
    }

    protected processCancelOperation(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request operation token not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IAuditReasonsClient {

    /**
     * Returns the audit reasons associated with the authenticated user. Inherited audit reasons are included. Only includes audit reasons associated with available API functionalities, like delete entry and export document. If the authenticated user does not have the appropriate Laserfiche feature right, the audit reasons associated with that feature right will not be included.
     * @param repoId The requested repository ID.
     * @return Get audit reasons successfully.
     */
    getAuditReasons(args: { repoId: string }): Promise<AuditReasons>;
}

export class AuditReasonsClient implements IAuditReasonsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.laserfiche.com/repository";
    }

    /**
     * Returns the audit reasons associated with the authenticated user. Inherited audit reasons are included. Only includes audit reasons associated with available API functionalities, like delete entry and export document. If the authenticated user does not have the appropriate Laserfiche feature right, the audit reasons associated with that feature right will not be included.
     * @param repoId The requested repository ID.
     * @return Get audit reasons successfully.
     */
    getAuditReasons(args: { repoId: string }): Promise<AuditReasons> {
        let { repoId } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/AuditReasons";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAuditReasons(_response);
        });
    }

    protected processGetAuditReasons(response: Response): Promise<AuditReasons> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuditReasons.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuditReasons>(null as any);
    }
}

export interface ISearchesClient {

    /**
     * Runs a search operation on the repository. Optional body parameters: FuzzyType: (default none), which can be used to determine what is considered a match by number of letters or percentage. FuzzyFactor: integer value that determines the degree to which a search will be considered a match (integer value for NumberOfLetters, or int value representing a percentage). The status for search operations must be checked via the Search specific status checking route.
     * @param repoId The requested repository ID.
     * @param request (optional) The Laserfiche search command to run, optionally include fuzzy search settings.
     * @return Search operation start successfully.
     */
    createSearchOperation(args: { repoId: string, request?: AdvancedSearchRequest | undefined }): Promise<AcceptedOperation>;

    /**
     * Returns search status. Provide a token (returned in the create search asynchronous route), and get the search status, progress, and any errors that may have occurred. When the search is completed, the Location header can be inspected as a link to the search results. OperationStatus can be one of the following : NotStarted, InProgress, Completed, Failed, or Canceled.
     * @param repoId The requested repository ID.
     * @param searchToken The requested searchToken.
     * @return Search has failed. Check the errors property to find out why.
     */
    getSearchStatus(args: { repoId: string, searchToken: string }): Promise<OperationProgress>;

    /**
     * Cancels a currently running search. Closes a completed search.
     * @param repoId The requested repository ID.
     * @param searchToken The requested searchToken.
     * @return Cancel or closed search successfully.
     */
    cancelOrCloseSearch(args: { repoId: string, searchToken: string }): Promise<ODataValueOfBoolean>;

    /**
     * Returns a search result listing if the search is completed. Optional query parameter: groupByOrderType (default false). This query parameter decides whether or not results are returned in groups based on their entry type. Optional query parameter: refresh (default false). If the search listing should be refreshed to show updated values. Default page size: 150. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer. OData $OrderBy syntax should follow: "PropertyName direction,PropertyName2 direction". sort order can be either "asc" or "desc". Search results expire after 5 minutes, but can be refreshed by retrieving the results again. Optionally returns field values for the entries in the search result listing. Each field name needs to be specified in the request. Maximum limit of 10 field names. If field values are requested, only the first value is returned if it is a multi value field. Null or Empty field values should not be used to determine if a field is assigned to the entry.
     * @param repoId The requested repository ID.
     * @param searchToken The requested searchToken.
     * @param groupByEntryType (optional) An optional query parameter used to indicate if the result should be grouped by entry type or not.
     * @param refresh (optional) If the search listing should be refreshed to show updated values.
     * @param fields (optional) Optional array of field names. Field values corresponding to the given field names will be returned for each search result.
     * @param formatFields (optional) Boolean for if field values should be formatted. Only applicable if Fields are specified.
     * @param prefer (optional) An optional odata header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag. The formatFields query parameter must be set to true, otherwise
                culture will not be used for formatting.
     * @param select (optional) Limits the properties returned in the result.
     * @param orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param top (optional) Limits the number of items returned from a collection.
     * @param skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get search result successfully.
     */
    getSearchResults(args: { repoId: string, searchToken: string, groupByEntryType?: boolean | undefined, refresh?: boolean | undefined, fields?: string[] | null | undefined, formatFields?: boolean | undefined, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfEntry>;

    /**
     * Returns the context hits associated with a search result entry. Given a searchToken, and rowNumber associated with a search entry in the listing, return the context hits for that entry. Default page size: 150. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param repoId The requested repository ID.
     * @param searchToken The requested searchToken.
     * @param rowNumber The search result listing row number to get context hits for.
     * @param prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param select (optional) Limits the properties returned in the result.
     * @param orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param top (optional) Limits the number of items returned from a collection.
     * @param skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get search context hits successfully.
     */
    getSearchContextHits(args: { repoId: string, searchToken: string, rowNumber: number, prefer?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfContextHit>;
}

export class SearchesClient implements ISearchesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.laserfiche.com/repository";
    }

    
  async GetSearchResultsForEach(args: {
    callback: (response: ODataValueContextOfIListOfEntry) => Promise<boolean>;
    repoId: string;
    searchToken: string;
    groupByEntryType?: boolean;
    refresh?: boolean;
    fields?: string[];
    formatFields?: boolean;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let {
      callback,
      repoId,
      searchToken,
      groupByEntryType,
      refresh,
      fields,
      formatFields,
      prefer,
      culture,
      select,
      orderby,
      top,
      skip,
      count,
      maxPageSize,
    } = args;
    var response = await this.getSearchResults({
      repoId,
      searchToken,
      groupByEntryType,
      refresh,
      fields,
      formatFields,
      prefer: CreateMaxPageSizePreferHeaderPayload(maxPageSize),
      culture,
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink != null) {
      response = await getNextLinkListing<ODataValueContextOfIListOfEntry>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processGetSearchResults,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }
  async GetSearchContextHitsForEach(args: {
    callback: (response: ODataValueContextOfIListOfContextHit) => Promise<boolean>;
    repoId: string;
    searchToken: string;
    rowNumber: number;
    prefer?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let { callback, repoId, searchToken, rowNumber, prefer, select, orderby, top, skip, count, maxPageSize } = args;
    var response = await this.getSearchContextHits({
      repoId,
      searchToken,
      rowNumber,
      prefer: CreateMaxPageSizePreferHeaderPayload(maxPageSize),
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink != null) {
      response = await getNextLinkListing<ODataValueContextOfIListOfContextHit>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processGetSearchContextHits,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }
  async GetSearchResultsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfEntry> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<ODataValueContextOfIListOfEntry>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processGetSearchResults,
      nextLink,
      maxPageSize
    );
  }
  async GetSearchContextHitsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfContextHit> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<ODataValueContextOfIListOfContextHit>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processGetSearchContextHits,
      nextLink,
      maxPageSize
    );
  }

    /**
     * Runs a search operation on the repository. Optional body parameters: FuzzyType: (default none), which can be used to determine what is considered a match by number of letters or percentage. FuzzyFactor: integer value that determines the degree to which a search will be considered a match (integer value for NumberOfLetters, or int value representing a percentage). The status for search operations must be checked via the Search specific status checking route.
     * @param repoId The requested repository ID.
     * @param request (optional) The Laserfiche search command to run, optionally include fuzzy search settings.
     * @return Search operation start successfully.
     */
    createSearchOperation(args: { repoId: string, request?: AdvancedSearchRequest | undefined }): Promise<AcceptedOperation> {
        let { repoId, request } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Searches";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSearchOperation(_response);
        });
    }

    protected processCreateSearchOperation(response: Response): Promise<AcceptedOperation> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = AcceptedOperation.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Operation limit or request limit reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AcceptedOperation>(null as any);
    }

    /**
     * Returns search status. Provide a token (returned in the create search asynchronous route), and get the search status, progress, and any errors that may have occurred. When the search is completed, the Location header can be inspected as a link to the search results. OperationStatus can be one of the following : NotStarted, InProgress, Completed, Failed, or Canceled.
     * @param repoId The requested repository ID.
     * @param searchToken The requested searchToken.
     * @return Search has failed. Check the errors property to find out why.
     */
    getSearchStatus(args: { repoId: string, searchToken: string }): Promise<OperationProgress> {
        let { repoId, searchToken } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Searches/{searchToken}";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (searchToken === undefined || searchToken === null)
            throw new Error("The parameter 'searchToken' must be defined.");
        url_ = url_.replace("{searchToken}", encodeURIComponent("" + searchToken));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSearchStatus(_response);
        });
    }

    protected processGetSearchStatus(response: Response): Promise<OperationProgress> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OperationProgress.fromJS(resultData200);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = OperationProgress.fromJS(resultData201);
            return result201;
            });
        } else if (status === 202) {
            return response.text().then((_responseText) => {
            let result202: any = null;
            let resultData202 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result202 = OperationProgress.fromJS(resultData202);
            return result202;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request search token not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OperationProgress>(null as any);
    }

    /**
     * Cancels a currently running search. Closes a completed search.
     * @param repoId The requested repository ID.
     * @param searchToken The requested searchToken.
     * @return Cancel or closed search successfully.
     */
    cancelOrCloseSearch(args: { repoId: string, searchToken: string }): Promise<ODataValueOfBoolean> {
        let { repoId, searchToken } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Searches/{searchToken}";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (searchToken === undefined || searchToken === null)
            throw new Error("The parameter 'searchToken' must be defined.");
        url_ = url_.replace("{searchToken}", encodeURIComponent("" + searchToken));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCancelOrCloseSearch(_response);
        });
    }

    protected processCancelOrCloseSearch(response: Response): Promise<ODataValueOfBoolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueOfBoolean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request search token not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueOfBoolean>(null as any);
    }

    /**
     * Returns a search result listing if the search is completed. Optional query parameter: groupByOrderType (default false). This query parameter decides whether or not results are returned in groups based on their entry type. Optional query parameter: refresh (default false). If the search listing should be refreshed to show updated values. Default page size: 150. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer. OData $OrderBy syntax should follow: "PropertyName direction,PropertyName2 direction". sort order can be either "asc" or "desc". Search results expire after 5 minutes, but can be refreshed by retrieving the results again. Optionally returns field values for the entries in the search result listing. Each field name needs to be specified in the request. Maximum limit of 10 field names. If field values are requested, only the first value is returned if it is a multi value field. Null or Empty field values should not be used to determine if a field is assigned to the entry.
     * @param repoId The requested repository ID.
     * @param searchToken The requested searchToken.
     * @param groupByEntryType (optional) An optional query parameter used to indicate if the result should be grouped by entry type or not.
     * @param refresh (optional) If the search listing should be refreshed to show updated values.
     * @param fields (optional) Optional array of field names. Field values corresponding to the given field names will be returned for each search result.
     * @param formatFields (optional) Boolean for if field values should be formatted. Only applicable if Fields are specified.
     * @param prefer (optional) An optional odata header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag. The formatFields query parameter must be set to true, otherwise
                culture will not be used for formatting.
     * @param select (optional) Limits the properties returned in the result.
     * @param orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param top (optional) Limits the number of items returned from a collection.
     * @param skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get search result successfully.
     */
    getSearchResults(args: { repoId: string, searchToken: string, groupByEntryType?: boolean | undefined, refresh?: boolean | undefined, fields?: string[] | null | undefined, formatFields?: boolean | undefined, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfEntry> {
        let { repoId, searchToken, groupByEntryType, refresh, fields, formatFields, prefer, culture, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Searches/{searchToken}/Results?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (searchToken === undefined || searchToken === null)
            throw new Error("The parameter 'searchToken' must be defined.");
        url_ = url_.replace("{searchToken}", encodeURIComponent("" + searchToken));
        if (groupByEntryType === null)
            throw new Error("The parameter 'groupByEntryType' cannot be null.");
        else if (groupByEntryType !== undefined)
            url_ += "groupByEntryType=" + encodeURIComponent("" + groupByEntryType) + "&";
        if (refresh === null)
            throw new Error("The parameter 'refresh' cannot be null.");
        else if (refresh !== undefined)
            url_ += "refresh=" + encodeURIComponent("" + refresh) + "&";
        if (fields !== undefined && fields !== null)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (formatFields === null)
            throw new Error("The parameter 'formatFields' cannot be null.");
        else if (formatFields !== undefined)
            url_ += "formatFields=" + encodeURIComponent("" + formatFields) + "&";
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Prefer": prefer !== undefined && prefer !== null ? "" + prefer : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSearchResults(_response);
        });
    }

    protected processGetSearchResults(response: Response): Promise<ODataValueContextOfIListOfEntry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueContextOfIListOfEntry.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request search token not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueContextOfIListOfEntry>(null as any);
    }

    /**
     * Returns the context hits associated with a search result entry. Given a searchToken, and rowNumber associated with a search entry in the listing, return the context hits for that entry. Default page size: 150. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param repoId The requested repository ID.
     * @param searchToken The requested searchToken.
     * @param rowNumber The search result listing row number to get context hits for.
     * @param prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param select (optional) Limits the properties returned in the result.
     * @param orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param top (optional) Limits the number of items returned from a collection.
     * @param skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get search context hits successfully.
     */
    getSearchContextHits(args: { repoId: string, searchToken: string, rowNumber: number, prefer?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfContextHit> {
        let { repoId, searchToken, rowNumber, prefer, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Searches/{searchToken}/Results/{rowNumber}/ContextHits?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (searchToken === undefined || searchToken === null)
            throw new Error("The parameter 'searchToken' must be defined.");
        url_ = url_.replace("{searchToken}", encodeURIComponent("" + searchToken));
        if (rowNumber === undefined || rowNumber === null)
            throw new Error("The parameter 'rowNumber' must be defined.");
        url_ = url_.replace("{rowNumber}", encodeURIComponent("" + rowNumber));
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Prefer": prefer !== undefined && prefer !== null ? "" + prefer : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSearchContextHits(_response);
        });
    }

    protected processGetSearchContextHits(response: Response): Promise<ODataValueContextOfIListOfContextHit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueContextOfIListOfContextHit.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request search token not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueContextOfIListOfContextHit>(null as any);
    }
}

export interface ISimpleSearchesClient {

    /**
     * Runs a "simple" search operation on the repository. Returns a truncated search result listing. Search result listing may be truncated, depending on number of results. Additionally, searches may time out if they take too long. Use the other search route to run full searches. Optionally returns field values for the entries in the search result listing. Each field name needs to be specified in the request. Maximum limit of 10 field names. If field values are requested, only the first value is returned if it is a multi value field. Null or Empty field values should not be used to determine if a field is assigned to the entry.
     * @param repoId The requested repository ID.
     * @param select (optional) Limits the properties returned in the result.
     * @param orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @param fields (optional) Optional array of field names. Field values corresponding to the given field names will be returned for each search result.
     * @param formatFields (optional) Boolean for if field values should be formatted. Only applicable if Fields are specified.
     * @param request (optional) The Laserfiche search command to run.
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag. The formatFields query parameter must be set to true, otherwise
                culture will not be used for formatting.
     * @return Simple search run successfully.
     */
    createSimpleSearchOperation(args: { repoId: string, select?: string | undefined, orderby?: string | undefined, count?: boolean | undefined, fields?: string[] | null | undefined, formatFields?: boolean | undefined, request?: SimpleSearchRequest | undefined, culture?: string | null | undefined }): Promise<ODataValueOfIListOfEntry>;
}

export class SimpleSearchesClient implements ISimpleSearchesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.laserfiche.com/repository";
    }

    /**
     * Runs a "simple" search operation on the repository. Returns a truncated search result listing. Search result listing may be truncated, depending on number of results. Additionally, searches may time out if they take too long. Use the other search route to run full searches. Optionally returns field values for the entries in the search result listing. Each field name needs to be specified in the request. Maximum limit of 10 field names. If field values are requested, only the first value is returned if it is a multi value field. Null or Empty field values should not be used to determine if a field is assigned to the entry.
     * @param repoId The requested repository ID.
     * @param select (optional) Limits the properties returned in the result.
     * @param orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @param fields (optional) Optional array of field names. Field values corresponding to the given field names will be returned for each search result.
     * @param formatFields (optional) Boolean for if field values should be formatted. Only applicable if Fields are specified.
     * @param request (optional) The Laserfiche search command to run.
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag. The formatFields query parameter must be set to true, otherwise
                culture will not be used for formatting.
     * @return Simple search run successfully.
     */
    createSimpleSearchOperation(args: { repoId: string, select?: string | undefined, orderby?: string | undefined, count?: boolean | undefined, fields?: string[] | null | undefined, formatFields?: boolean | undefined, request?: SimpleSearchRequest | undefined, culture?: string | null | undefined }): Promise<ODataValueOfIListOfEntry> {
        let { repoId, select, orderby, count, fields, formatFields, request, culture } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/SimpleSearches?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (select === null)
            throw new Error("The parameter 'select' cannot be null.");
        else if (select !== undefined)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby === null)
            throw new Error("The parameter 'orderby' cannot be null.");
        else if (orderby !== undefined)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        if (fields !== undefined && fields !== null)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (formatFields === null)
            throw new Error("The parameter 'formatFields' cannot be null.");
        else if (formatFields !== undefined)
            url_ += "formatFields=" + encodeURIComponent("" + formatFields) + "&";
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSimpleSearchOperation(_response);
        });
    }

    protected processCreateSimpleSearchOperation(response: Response): Promise<ODataValueOfIListOfEntry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueOfIListOfEntry.fromJS(resultData200);
            return result200;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return throwException("No search results found.", status, _responseText, _headers);
            });
        } else if (status === 206) {
            return response.text().then((_responseText) => {
            let result206: any = null;
            let resultData206 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result206 = ODataValueOfIListOfEntry.fromJS(resultData206);
            return result206;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Operation limit or request limit reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueOfIListOfEntry>(null as any);
    }
}

export interface ITagDefinitionsClient {

    /**
     * Returns all tag definitions in the repository. Provide a repository ID and get a paged listing of tag definitions available in the repository. Useful when trying to display all tag definitions available, not only tags assigned to a specific entry. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param repoId The requested repository ID.
     * @param prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag.
     * @param select (optional) Limits the properties returned in the result.
     * @param orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param top (optional) Limits the number of items returned from a collection.
     * @param skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get tag definitions successfully.
     */
    getTagDefinitions(args: { repoId: string, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfWTagInfo>;

    /**
     * Returns a single tag definition. Provide a tag definition ID, and get the single tag definition associated with that ID. Useful when another route provides a minimal amount of details, and more information about the specific tag is needed. Allowed OData query options: Select
     * @param repoId The requested repository ID.
     * @param tagId The requested tag definition ID.
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag.
     * @param select (optional) Limits the properties returned in the result.
     * @return Get tag definition successfully.
     */
    getTagDefinitionById(args: { repoId: string, tagId: number, culture?: string | null | undefined, select?: string | null | undefined }): Promise<WTagInfo>;
}

export class TagDefinitionsClient implements ITagDefinitionsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.laserfiche.com/repository";
    }

    
  async GetTagDefinitionsForEach(args: {
    callback: (response: ODataValueContextOfIListOfWTagInfo) => Promise<boolean>;
    repoId: string;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let { callback, repoId, prefer, culture, select, orderby, top, skip, count, maxPageSize } = args;
    var response = await this.getTagDefinitions({
      repoId,
      prefer: CreateMaxPageSizePreferHeaderPayload(maxPageSize),
      culture,
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink != null) {
      response = await getNextLinkListing<ODataValueContextOfIListOfWTagInfo>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processGetTagDefinitions,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }
  async getTagDefinitionsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfWTagInfo> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<ODataValueContextOfIListOfWTagInfo>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processGetTagDefinitions,
      nextLink,
      maxPageSize
    );
  }

    /**
     * Returns all tag definitions in the repository. Provide a repository ID and get a paged listing of tag definitions available in the repository. Useful when trying to display all tag definitions available, not only tags assigned to a specific entry. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param repoId The requested repository ID.
     * @param prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag.
     * @param select (optional) Limits the properties returned in the result.
     * @param orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param top (optional) Limits the number of items returned from a collection.
     * @param skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get tag definitions successfully.
     */
    getTagDefinitions(args: { repoId: string, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfWTagInfo> {
        let { repoId, prefer, culture, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/TagDefinitions?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Prefer": prefer !== undefined && prefer !== null ? "" + prefer : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTagDefinitions(_response);
        });
    }

    protected processGetTagDefinitions(response: Response): Promise<ODataValueContextOfIListOfWTagInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueContextOfIListOfWTagInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueContextOfIListOfWTagInfo>(null as any);
    }

    /**
     * Returns a single tag definition. Provide a tag definition ID, and get the single tag definition associated with that ID. Useful when another route provides a minimal amount of details, and more information about the specific tag is needed. Allowed OData query options: Select
     * @param repoId The requested repository ID.
     * @param tagId The requested tag definition ID.
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag.
     * @param select (optional) Limits the properties returned in the result.
     * @return Get tag definition successfully.
     */
    getTagDefinitionById(args: { repoId: string, tagId: number, culture?: string | null | undefined, select?: string | null | undefined }): Promise<WTagInfo> {
        let { repoId, tagId, culture, select } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/TagDefinitions/{tagId}?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (tagId === undefined || tagId === null)
            throw new Error("The parameter 'tagId' must be defined.");
        url_ = url_.replace("{tagId}", encodeURIComponent("" + tagId));
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTagDefinitionById(_response);
        });
    }

    protected processGetTagDefinitionById(response: Response): Promise<WTagInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WTagInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request tag definition id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WTagInfo>(null as any);
    }
}

export interface ITemplateDefinitionsClient {

    /**
     * Returns all template definitions (including field definitions) in the repository. If a template name query parameter is given, then a single template definition is returned. Provide a repository ID, and get a paged listing of template definitions available in the repository. Useful when trying to find a list of all template definitions available, rather than a specific one. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param repoId The requested repository ID.
     * @param templateName (optional) An optional query parameter. Can be used to get a single template definition using the template name.
     * @param prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag.
     * @param select (optional) Limits the properties returned in the result.
     * @param orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param top (optional) Limits the number of items returned from a collection.
     * @param skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get template definitions successfully.
     */
    getTemplateDefinitions(args: { repoId: string, templateName?: string | null | undefined, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfWTemplateInfo>;

    /**
     * Returns a single template definition (including field definitions, if relevant). Provide a template definition ID, and get the single template definition associated with that ID. Useful when a route provides a minimal amount of details, and more information about the specific template is needed. Allowed OData query options: Select
     * @param repoId The requested repository ID.
     * @param templateId The requested template definition ID.
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag.
     * @param select (optional) Limits the properties returned in the result.
     * @return Get template definition successfully.
     */
    getTemplateDefinitionById(args: { repoId: string, templateId: number, culture?: string | null | undefined, select?: string | null | undefined }): Promise<WTemplateInfo>;

    /**
     * Returns the field definitions assigned to a template definition. Provide a template definition ID, and get a paged listing of the field definitions assigned to that template.  Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param repoId The requested repository ID.
     * @param templateId The requested template definition ID.
     * @param prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag.
     * @param select (optional) Limits the properties returned in the result.
     * @param orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param top (optional) Limits the number of items returned from a collection.
     * @param skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get field definitions successfully.
     */
    getTemplateFieldDefinitions(args: { repoId: string, templateId: number, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfTemplateFieldInfo>;

    /**
     * Returns the field definitions assigned to a template definition. Provide a template definition name, and get a paged listing of the field definitions assigned to that template.  Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param repoId The requested repository ID.
     * @param templateName A required query parameter for the requested template name.
     * @param prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag.
     * @param select (optional) Limits the properties returned in the result.
     * @param orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param top (optional) Limits the number of items returned from a collection.
     * @param skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get field definitions successfully.
     */
    getTemplateFieldDefinitionsByTemplateName(args: { repoId: string, templateName: string | null, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfTemplateFieldInfo>;
}

export class TemplateDefinitionsClient implements ITemplateDefinitionsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.laserfiche.com/repository";
    }

    
  async GetTemplateDefinitionsForEach(args: {
    callback: (response: ODataValueContextOfIListOfWTemplateInfo) => Promise<boolean>;
    repoId: string;
    templateName?: string;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let { callback, repoId, templateName, prefer, culture, select, orderby, top, skip, count, maxPageSize } = args;
    var response = await this.getTemplateDefinitions({
      repoId,
      templateName,
      prefer: CreateMaxPageSizePreferHeaderPayload(maxPageSize),
      culture,
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink != null) {
      response = await getNextLinkListing<ODataValueContextOfIListOfWTemplateInfo>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processGetTemplateDefinitions,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }

  async GetTemplateFieldDefinitionsForEach(args: {
    callback: (response: ODataValueContextOfIListOfTemplateFieldInfo) => Promise<boolean>;
    repoId: string;
    templateId: number;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let { callback, repoId, templateId, prefer, culture, select, orderby, top, skip, count, maxPageSize } = args;
    var response = await this.getTemplateFieldDefinitions({
      repoId,
      templateId,
      prefer: CreateMaxPageSizePreferHeaderPayload(maxPageSize),
      culture,
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink != null) {
      response = await getNextLinkListing<ODataValueContextOfIListOfTemplateFieldInfo>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processGetTemplateFieldDefinitions,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }

  async GetTemplateFieldDefinitionsByTemplateNameForEach(args: {
    callback: (response: ODataValueContextOfIListOfTemplateFieldInfo) => Promise<boolean>;
    repoId: string;
    templateName: string;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let { callback, repoId, templateName, prefer, culture, select, orderby, top, skip, count, maxPageSize } = args;
    var response = await this.getTemplateFieldDefinitionsByTemplateName({
      repoId,
      templateName,
      prefer: CreateMaxPageSizePreferHeaderPayload(maxPageSize),
      culture,
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink != null) {
      response = await getNextLinkListing<ODataValueContextOfIListOfTemplateFieldInfo>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processGetTemplateFieldDefinitionsByTemplateName,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }
  async getTemplateDefinitionsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfWTemplateInfo> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<ODataValueContextOfIListOfWTemplateInfo>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processGetTemplateDefinitions,
      nextLink,
      maxPageSize
    );
  }
  async getTemplateFieldDefinitionsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfTemplateFieldInfo> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<ODataValueContextOfIListOfTemplateFieldInfo>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processGetTemplateFieldDefinitions,
      nextLink,
      maxPageSize
    );
  }
  async getTemplateFieldDefinitionsByTemplateNameNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfTemplateFieldInfo> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<ODataValueContextOfIListOfTemplateFieldInfo>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processGetTemplateFieldDefinitionsByTemplateName,
      nextLink,
      maxPageSize
    );
  }

    /**
     * Returns all template definitions (including field definitions) in the repository. If a template name query parameter is given, then a single template definition is returned. Provide a repository ID, and get a paged listing of template definitions available in the repository. Useful when trying to find a list of all template definitions available, rather than a specific one. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param repoId The requested repository ID.
     * @param templateName (optional) An optional query parameter. Can be used to get a single template definition using the template name.
     * @param prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag.
     * @param select (optional) Limits the properties returned in the result.
     * @param orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param top (optional) Limits the number of items returned from a collection.
     * @param skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get template definitions successfully.
     */
    getTemplateDefinitions(args: { repoId: string, templateName?: string | null | undefined, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfWTemplateInfo> {
        let { repoId, templateName, prefer, culture, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/TemplateDefinitions?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (templateName !== undefined && templateName !== null)
            url_ += "templateName=" + encodeURIComponent("" + templateName) + "&";
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Prefer": prefer !== undefined && prefer !== null ? "" + prefer : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTemplateDefinitions(_response);
        });
    }

    protected processGetTemplateDefinitions(response: Response): Promise<ODataValueContextOfIListOfWTemplateInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueContextOfIListOfWTemplateInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request template name not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueContextOfIListOfWTemplateInfo>(null as any);
    }

    /**
     * Returns a single template definition (including field definitions, if relevant). Provide a template definition ID, and get the single template definition associated with that ID. Useful when a route provides a minimal amount of details, and more information about the specific template is needed. Allowed OData query options: Select
     * @param repoId The requested repository ID.
     * @param templateId The requested template definition ID.
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag.
     * @param select (optional) Limits the properties returned in the result.
     * @return Get template definition successfully.
     */
    getTemplateDefinitionById(args: { repoId: string, templateId: number, culture?: string | null | undefined, select?: string | null | undefined }): Promise<WTemplateInfo> {
        let { repoId, templateId, culture, select } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/TemplateDefinitions/{templateId}?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (templateId === undefined || templateId === null)
            throw new Error("The parameter 'templateId' must be defined.");
        url_ = url_.replace("{templateId}", encodeURIComponent("" + templateId));
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTemplateDefinitionById(_response);
        });
    }

    protected processGetTemplateDefinitionById(response: Response): Promise<WTemplateInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WTemplateInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request template id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WTemplateInfo>(null as any);
    }

    /**
     * Returns the field definitions assigned to a template definition. Provide a template definition ID, and get a paged listing of the field definitions assigned to that template.  Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param repoId The requested repository ID.
     * @param templateId The requested template definition ID.
     * @param prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag.
     * @param select (optional) Limits the properties returned in the result.
     * @param orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param top (optional) Limits the number of items returned from a collection.
     * @param skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get field definitions successfully.
     */
    getTemplateFieldDefinitions(args: { repoId: string, templateId: number, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfTemplateFieldInfo> {
        let { repoId, templateId, prefer, culture, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/TemplateDefinitions/{templateId}/fields?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (templateId === undefined || templateId === null)
            throw new Error("The parameter 'templateId' must be defined.");
        url_ = url_.replace("{templateId}", encodeURIComponent("" + templateId));
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Prefer": prefer !== undefined && prefer !== null ? "" + prefer : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTemplateFieldDefinitions(_response);
        });
    }

    protected processGetTemplateFieldDefinitions(response: Response): Promise<ODataValueContextOfIListOfTemplateFieldInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueContextOfIListOfTemplateFieldInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request template id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueContextOfIListOfTemplateFieldInfo>(null as any);
    }

    /**
     * Returns the field definitions assigned to a template definition. Provide a template definition name, and get a paged listing of the field definitions assigned to that template.  Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param repoId The requested repository ID.
     * @param templateName A required query parameter for the requested template name.
     * @param prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag.
     * @param select (optional) Limits the properties returned in the result.
     * @param orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param top (optional) Limits the number of items returned from a collection.
     * @param skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get field definitions successfully.
     */
    getTemplateFieldDefinitionsByTemplateName(args: { repoId: string, templateName: string | null, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfTemplateFieldInfo> {
        let { repoId, templateName, prefer, culture, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/TemplateDefinitions/Fields?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (templateName === undefined)
            throw new Error("The parameter 'templateName' must be defined.");
        else if(templateName !== null)
            url_ += "templateName=" + encodeURIComponent("" + templateName) + "&";
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Prefer": prefer !== undefined && prefer !== null ? "" + prefer : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTemplateFieldDefinitionsByTemplateName(_response);
        });
    }

    protected processGetTemplateFieldDefinitionsByTemplateName(response: Response): Promise<ODataValueContextOfIListOfTemplateFieldInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueContextOfIListOfTemplateFieldInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request template name not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueContextOfIListOfTemplateFieldInfo>(null as any);
    }
}

export class CreateEntryResult implements ICreateEntryResult {
    operations?: CreateEntryOperations;
    /** A link to get the created entry. */
    documentLink?: string | undefined;

    constructor(data?: ICreateEntryResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.operations = _data["operations"] ? CreateEntryOperations.fromJS(_data["operations"]) : <any>undefined;
            this.documentLink = _data["documentLink"];
        }
    }

    static fromJS(data: any): CreateEntryResult {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEntryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["operations"] = this.operations ? this.operations.toJSON() : <any>undefined;
        data["documentLink"] = this.documentLink;
        return data;
    }
}

export interface ICreateEntryResult {
    operations?: CreateEntryOperations;
    /** A link to get the created entry. */
    documentLink?: string | undefined;
}

/** The results of each operation needed in order to create the electronic document with optional template and fields. */
export class CreateEntryOperations implements ICreateEntryOperations {
    entryCreate?: EntryCreate;
    setEdoc?: SetEdoc;
    setTemplate?: SetTemplate;
    setFields?: SetFields;
    setTags?: SetTags;
    setLinks?: SetLinks;

    constructor(data?: ICreateEntryOperations) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entryCreate = _data["entryCreate"] ? EntryCreate.fromJS(_data["entryCreate"]) : <any>undefined;
            this.setEdoc = _data["setEdoc"] ? SetEdoc.fromJS(_data["setEdoc"]) : <any>undefined;
            this.setTemplate = _data["setTemplate"] ? SetTemplate.fromJS(_data["setTemplate"]) : <any>undefined;
            this.setFields = _data["setFields"] ? SetFields.fromJS(_data["setFields"]) : <any>undefined;
            this.setTags = _data["setTags"] ? SetTags.fromJS(_data["setTags"]) : <any>undefined;
            this.setLinks = _data["setLinks"] ? SetLinks.fromJS(_data["setLinks"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateEntryOperations {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEntryOperations();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entryCreate"] = this.entryCreate ? this.entryCreate.toJSON() : <any>undefined;
        data["setEdoc"] = this.setEdoc ? this.setEdoc.toJSON() : <any>undefined;
        data["setTemplate"] = this.setTemplate ? this.setTemplate.toJSON() : <any>undefined;
        data["setFields"] = this.setFields ? this.setFields.toJSON() : <any>undefined;
        data["setTags"] = this.setTags ? this.setTags.toJSON() : <any>undefined;
        data["setLinks"] = this.setLinks ? this.setLinks.toJSON() : <any>undefined;
        return data;
    }
}

/** The results of each operation needed in order to create the electronic document with optional template and fields. */
export interface ICreateEntryOperations {
    entryCreate?: EntryCreate;
    setEdoc?: SetEdoc;
    setTemplate?: SetTemplate;
    setFields?: SetFields;
    setTags?: SetTags;
    setLinks?: SetLinks;
}

/** The result of trying to create the entry. */
export class EntryCreate implements IEntryCreate {
    /** The list of exceptions that occured when trying to perform the operation. */
    exceptions?: APIServerException[] | undefined;
    /** The id of the created entry. If the id is 0, then the entry was not created. */
    entryId?: number;

    constructor(data?: IEntryCreate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["exceptions"])) {
                this.exceptions = [] as any;
                for (let item of _data["exceptions"])
                    this.exceptions!.push(APIServerException.fromJS(item));
            }
            this.entryId = _data["entryId"];
        }
    }

    static fromJS(data: any): EntryCreate {
        data = typeof data === 'object' ? data : {};
        let result = new EntryCreate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.exceptions)) {
            data["exceptions"] = [];
            for (let item of this.exceptions)
                data["exceptions"].push(item.toJSON());
        }
        data["entryId"] = this.entryId;
        return data;
    }
}

/** The result of trying to create the entry. */
export interface IEntryCreate {
    /** The list of exceptions that occured when trying to perform the operation. */
    exceptions?: APIServerException[] | undefined;
    /** The id of the created entry. If the id is 0, then the entry was not created. */
    entryId?: number;
}

export class APIServerException implements IAPIServerException {
    /** The id of the operation that threw the exception. */
    operationId?: string | undefined;
    /** The explaination of the exception that occurred. */
    message?: string | undefined;
    /** The code associated with the exception. */
    errorCode?: number | undefined;
    /** The class of exceptions this belongs to. */
    errorClass?: string | undefined;
    /** The HTTP status code returned. */
    statusCode?: number | undefined;
    /** The source of where the exception occurred. */
    errorSource?: string | undefined;

    constructor(data?: IAPIServerException) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.operationId = _data["operationId"];
            this.message = _data["message"];
            this.errorCode = _data["errorCode"];
            this.errorClass = _data["errorClass"];
            this.statusCode = _data["statusCode"];
            this.errorSource = _data["errorSource"];
        }
    }

    static fromJS(data: any): APIServerException {
        data = typeof data === 'object' ? data : {};
        let result = new APIServerException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["operationId"] = this.operationId;
        data["message"] = this.message;
        data["errorCode"] = this.errorCode;
        data["errorClass"] = this.errorClass;
        data["statusCode"] = this.statusCode;
        data["errorSource"] = this.errorSource;
        return data;
    }
}

export interface IAPIServerException {
    /** The id of the operation that threw the exception. */
    operationId?: string | undefined;
    /** The explaination of the exception that occurred. */
    message?: string | undefined;
    /** The code associated with the exception. */
    errorCode?: number | undefined;
    /** The class of exceptions this belongs to. */
    errorClass?: string | undefined;
    /** The HTTP status code returned. */
    statusCode?: number | undefined;
    /** The source of where the exception occurred. */
    errorSource?: string | undefined;
}

/** The result of trying to create the electronic document. */
export class SetEdoc implements ISetEdoc {
    /** The list of exceptions that occured when trying to perform the operation. */
    exceptions?: APIServerException[] | undefined;

    constructor(data?: ISetEdoc) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["exceptions"])) {
                this.exceptions = [] as any;
                for (let item of _data["exceptions"])
                    this.exceptions!.push(APIServerException.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SetEdoc {
        data = typeof data === 'object' ? data : {};
        let result = new SetEdoc();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.exceptions)) {
            data["exceptions"] = [];
            for (let item of this.exceptions)
                data["exceptions"].push(item.toJSON());
        }
        return data;
    }
}

/** The result of trying to create the electronic document. */
export interface ISetEdoc {
    /** The list of exceptions that occured when trying to perform the operation. */
    exceptions?: APIServerException[] | undefined;
}

/** The result of trying to assign a template to the entry. */
export class SetTemplate implements ISetTemplate {
    /** The list of exceptions that occured when trying to perform the operation. */
    exceptions?: APIServerException[] | undefined;
    /** The name of the template assigned to the entry. If this is null, then no template was assigned. */
    template?: string | undefined;

    constructor(data?: ISetTemplate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["exceptions"])) {
                this.exceptions = [] as any;
                for (let item of _data["exceptions"])
                    this.exceptions!.push(APIServerException.fromJS(item));
            }
            this.template = _data["template"];
        }
    }

    static fromJS(data: any): SetTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new SetTemplate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.exceptions)) {
            data["exceptions"] = [];
            for (let item of this.exceptions)
                data["exceptions"].push(item.toJSON());
        }
        data["template"] = this.template;
        return data;
    }
}

/** The result of trying to assign a template to the entry. */
export interface ISetTemplate {
    /** The list of exceptions that occured when trying to perform the operation. */
    exceptions?: APIServerException[] | undefined;
    /** The name of the template assigned to the entry. If this is null, then no template was assigned. */
    template?: string | undefined;
}

/** The result of trying to assign fields to the entry. */
export class SetFields implements ISetFields {
    /** The list of exceptions that occured when trying to perform the operation. */
    exceptions?: APIServerException[] | undefined;
    /** The number of fields assigned to the entry. */
    fieldCount?: number;

    constructor(data?: ISetFields) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["exceptions"])) {
                this.exceptions = [] as any;
                for (let item of _data["exceptions"])
                    this.exceptions!.push(APIServerException.fromJS(item));
            }
            this.fieldCount = _data["fieldCount"];
        }
    }

    static fromJS(data: any): SetFields {
        data = typeof data === 'object' ? data : {};
        let result = new SetFields();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.exceptions)) {
            data["exceptions"] = [];
            for (let item of this.exceptions)
                data["exceptions"].push(item.toJSON());
        }
        data["fieldCount"] = this.fieldCount;
        return data;
    }
}

/** The result of trying to assign fields to the entry. */
export interface ISetFields {
    /** The list of exceptions that occured when trying to perform the operation. */
    exceptions?: APIServerException[] | undefined;
    /** The number of fields assigned to the entry. */
    fieldCount?: number;
}

/** The result of trying to assign fields to the entry. */
export class SetTags implements ISetTags {
    /** The list of exceptions that occured when trying to perform the operation. */
    exceptions?: APIServerException[] | undefined;
    /** The tags that were assigned to the entry */
    assignedTags?: string[] | undefined;

    constructor(data?: ISetTags) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["exceptions"])) {
                this.exceptions = [] as any;
                for (let item of _data["exceptions"])
                    this.exceptions!.push(APIServerException.fromJS(item));
            }
            if (Array.isArray(_data["assignedTags"])) {
                this.assignedTags = [] as any;
                for (let item of _data["assignedTags"])
                    this.assignedTags!.push(item);
            }
        }
    }

    static fromJS(data: any): SetTags {
        data = typeof data === 'object' ? data : {};
        let result = new SetTags();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.exceptions)) {
            data["exceptions"] = [];
            for (let item of this.exceptions)
                data["exceptions"].push(item.toJSON());
        }
        if (Array.isArray(this.assignedTags)) {
            data["assignedTags"] = [];
            for (let item of this.assignedTags)
                data["assignedTags"].push(item);
        }
        return data;
    }
}

/** The result of trying to assign fields to the entry. */
export interface ISetTags {
    /** The list of exceptions that occured when trying to perform the operation. */
    exceptions?: APIServerException[] | undefined;
    /** The tags that were assigned to the entry */
    assignedTags?: string[] | undefined;
}

/** The result of trying to assign a entry link to the entry. */
export class SetLinks implements ISetLinks {
    /** The list of exceptions that occured when trying to perform the operation. */
    exceptions?: APIServerException[] | undefined;
    /** The ids of the other entries linked to the entry */
    otherEntryIds?: number[] | undefined;

    constructor(data?: ISetLinks) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["exceptions"])) {
                this.exceptions = [] as any;
                for (let item of _data["exceptions"])
                    this.exceptions!.push(APIServerException.fromJS(item));
            }
            if (Array.isArray(_data["otherEntryIds"])) {
                this.otherEntryIds = [] as any;
                for (let item of _data["otherEntryIds"])
                    this.otherEntryIds!.push(item);
            }
        }
    }

    static fromJS(data: any): SetLinks {
        data = typeof data === 'object' ? data : {};
        let result = new SetLinks();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.exceptions)) {
            data["exceptions"] = [];
            for (let item of this.exceptions)
                data["exceptions"].push(item.toJSON());
        }
        if (Array.isArray(this.otherEntryIds)) {
            data["otherEntryIds"] = [];
            for (let item of this.otherEntryIds)
                data["otherEntryIds"].push(item);
        }
        return data;
    }
}

/** The result of trying to assign a entry link to the entry. */
export interface ISetLinks {
    /** The list of exceptions that occured when trying to perform the operation. */
    exceptions?: APIServerException[] | undefined;
    /** The ids of the other entries linked to the entry */
    otherEntryIds?: number[] | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any; } | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            if (_data["extensions"]) {
                this.extensions = {} as any;
                for (let key in _data["extensions"]) {
                    if (_data["extensions"].hasOwnProperty(key))
                        (<any>this.extensions)![key] = _data["extensions"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        if (this.extensions) {
            data["extensions"] = {};
            for (let key in this.extensions) {
                if (this.extensions.hasOwnProperty(key))
                    (<any>data["extensions"])[key] = this.extensions[key];
            }
        }
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any; } | undefined;
}

export abstract class IHeaderDictionary implements IIHeaderDictionary {
    item?: any[];
    contentLength?: number | undefined;

    constructor(data?: IIHeaderDictionary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Item"])) {
                this.item = [] as any;
                for (let item of _data["Item"])
                    this.item!.push(item);
            }
            this.contentLength = _data["ContentLength"];
        }
    }

    static fromJS(data: any): IHeaderDictionary {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IHeaderDictionary' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.item)) {
            data["Item"] = [];
            for (let item of this.item)
                data["Item"].push(item);
        }
        data["ContentLength"] = this.contentLength;
        return data;
    }
}

export interface IIHeaderDictionary {
    item?: any[];
    contentLength?: number | undefined;
}

export class LinkToUpdate implements ILinkToUpdate {
    /** The id of the link assigned to the entry. */
    linkTypeId?: number;
    /** The id of the other source linked to the entry. */
    otherSourceId?: number;
    /** Whether the entry is the source for the link. */
    isSource?: boolean;

    constructor(data?: ILinkToUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.linkTypeId = _data["linkTypeId"];
            this.otherSourceId = _data["otherSourceId"];
            this.isSource = _data["isSource"];
        }
    }

    static fromJS(data: any): LinkToUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new LinkToUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["linkTypeId"] = this.linkTypeId;
        data["otherSourceId"] = this.otherSourceId;
        data["isSource"] = this.isSource;
        return data;
    }
}

export interface ILinkToUpdate {
    /** The id of the link assigned to the entry. */
    linkTypeId?: number;
    /** The id of the other source linked to the entry. */
    otherSourceId?: number;
    /** Whether the entry is the source for the link. */
    isSource?: boolean;
}

export class FieldToUpdate implements IFieldToUpdate {
    /** The field values that will be assigned to the field. */
    values?: ValueToUpdate[] | undefined;

    constructor(data?: IFieldToUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(ValueToUpdate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FieldToUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new FieldToUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

export interface IFieldToUpdate {
    /** The field values that will be assigned to the field. */
    values?: ValueToUpdate[] | undefined;
}

export class ValueToUpdate implements IValueToUpdate {
    /** The value assigned to the field at the position specified. */
    value?: string | undefined;
    /** The position of the value in the field. This is 1-indexed for multi value field. It will be ignored for single value field. */
    position?: number;

    constructor(data?: IValueToUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.position = _data["position"];
        }
    }

    static fromJS(data: any): ValueToUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new ValueToUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["position"] = this.position;
        return data;
    }
}

export interface IValueToUpdate {
    /** The value assigned to the field at the position specified. */
    value?: string | undefined;
    /** The position of the value in the field. This is 1-indexed for multi value field. It will be ignored for single value field. */
    position?: number;
}

export class PostEntryWithEdocMetadataRequest implements IPostEntryWithEdocMetadataRequest {
    /** The name of the template assigned to the entry. */
    template?: string | undefined;
    metadata?: PutFieldValsRequest;

    constructor(data?: IPostEntryWithEdocMetadataRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.template = _data["template"];
            this.metadata = _data["metadata"] ? PutFieldValsRequest.fromJS(_data["metadata"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PostEntryWithEdocMetadataRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PostEntryWithEdocMetadataRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["template"] = this.template;
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPostEntryWithEdocMetadataRequest {
    /** The name of the template assigned to the entry. */
    template?: string | undefined;
    metadata?: PutFieldValsRequest;
}

export class SimpleImportMetadata implements ISimpleImportMetadata {
    /** The fields that will be assigned to the entry. */
    fields?: { [key: string]: FieldToUpdate; } | undefined;
    /** The tags that will be assigned to the entry. */
    tags?: string[] | undefined;

    constructor(data?: ISimpleImportMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["fields"]) {
                this.fields = {} as any;
                for (let key in _data["fields"]) {
                    if (_data["fields"].hasOwnProperty(key))
                        (<any>this.fields)![key] = _data["fields"][key] ? FieldToUpdate.fromJS(_data["fields"][key]) : new FieldToUpdate();
                }
            }
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): SimpleImportMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleImportMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.fields) {
            data["fields"] = {};
            for (let key in this.fields) {
                if (this.fields.hasOwnProperty(key))
                    (<any>data["fields"])[key] = this.fields[key] ? this.fields[key].toJSON() : <any>undefined;
            }
        }
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }
}

export interface ISimpleImportMetadata {
    /** The fields that will be assigned to the entry. */
    fields?: { [key: string]: FieldToUpdate; } | undefined;
    /** The tags that will be assigned to the entry. */
    tags?: string[] | undefined;
}

/** The request body containing fields that will be assigned to the entry. */
export class PutFieldValsRequest extends SimpleImportMetadata implements IPutFieldValsRequest {
    /** The links that will be assigned to the entry. */
    links?: LinkToUpdate[] | undefined;

    constructor(data?: IPutFieldValsRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(LinkToUpdate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PutFieldValsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PutFieldValsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** The request body containing fields that will be assigned to the entry. */
export interface IPutFieldValsRequest extends ISimpleImportMetadata {
    /** The links that will be assigned to the entry. */
    links?: LinkToUpdate[] | undefined;
}

export class ODataValueOfListOfAttribute implements IODataValueOfListOfAttribute {
    value?: Attribute[];

    constructor(data?: IODataValueOfListOfAttribute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(Attribute.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ODataValueOfListOfAttribute {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueOfListOfAttribute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

export interface IODataValueOfListOfAttribute {
    value?: Attribute[];
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export class ODataValueContextOfListOfAttribute extends ODataValueOfListOfAttribute implements IODataValueContextOfListOfAttribute {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;

    constructor(data?: IODataValueContextOfListOfAttribute) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.odataNextLink = _data["@odata.nextLink"];
            this.odataCount = _data["@odata.count"];
        }
    }

    static fromJS(data: any): ODataValueContextOfListOfAttribute {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueContextOfListOfAttribute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["@odata.nextLink"] = this.odataNextLink;
        data["@odata.count"] = this.odataCount;
        super.toJSON(data);
        return data;
    }
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export interface IODataValueContextOfListOfAttribute extends IODataValueOfListOfAttribute {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;
}

export class Attribute implements IAttribute {
    key?: string | undefined;
    value?: string | undefined;

    constructor(data?: IAttribute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Attribute {
        data = typeof data === 'object' ? data : {};
        let result = new Attribute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IAttribute {
    key?: string | undefined;
    value?: string | undefined;
}

export class WFieldInfo implements IWFieldInfo {
    /** The name of the field. */
    name?: string | undefined;
    /** The localized name of the field. */
    displayName?: string | undefined;
    /** The ID of the field. */
    id?: number;
    /** The description of the field. */
    description?: string | undefined;
    /** The type of the field. */
    fieldType?: WFieldType;
    /** The length of the field for variable length data types. */
    length?: number;
    /** The default value of the field for new entries that are assigned
to a template the represented field is a member of. */
    defaultValue?: string | undefined;
    /** A boolean indicating if the represented template field supports multiple values. */
    isMultiValue?: boolean;
    /** A boolean indicating if the represented field must have a value set
on entries assigned to a template that the field is a member of. */
    isRequired?: boolean;
    /** The constraint for values stored in the represented field. */
    constraint?: string | undefined;
    /** The error string that will be returned when the field constraint
is violated when setting a value for this field. */
    constraintError?: string | undefined;
    /** The list of items assigned to the represented field. */
    listValues?: string[] | undefined;
    /** The display format of the represented field. */
    format?: WFieldFormat;
    /** The name of the currency that will be using when formatting
the represented field when the Format property is set to the
Currency member of the WFieldFormat enumeration. */
    currency?: string | undefined;
    /** The custom format pattern for fields that are configured to
use a custom format. */
    formatPattern?: string | undefined;

    constructor(data?: IWFieldInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.id = _data["id"];
            this.description = _data["description"];
            this.fieldType = _data["fieldType"];
            this.length = _data["length"];
            this.defaultValue = _data["defaultValue"];
            this.isMultiValue = _data["isMultiValue"];
            this.isRequired = _data["isRequired"];
            this.constraint = _data["constraint"];
            this.constraintError = _data["constraintError"];
            if (Array.isArray(_data["listValues"])) {
                this.listValues = [] as any;
                for (let item of _data["listValues"])
                    this.listValues!.push(item);
            }
            this.format = _data["format"];
            this.currency = _data["currency"];
            this.formatPattern = _data["formatPattern"];
        }
    }

    static fromJS(data: any): WFieldInfo {
        data = typeof data === 'object' ? data : {};
        let result = new WFieldInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["id"] = this.id;
        data["description"] = this.description;
        data["fieldType"] = this.fieldType;
        data["length"] = this.length;
        data["defaultValue"] = this.defaultValue;
        data["isMultiValue"] = this.isMultiValue;
        data["isRequired"] = this.isRequired;
        data["constraint"] = this.constraint;
        data["constraintError"] = this.constraintError;
        if (Array.isArray(this.listValues)) {
            data["listValues"] = [];
            for (let item of this.listValues)
                data["listValues"].push(item);
        }
        data["format"] = this.format;
        data["currency"] = this.currency;
        data["formatPattern"] = this.formatPattern;
        return data;
    }
}

export interface IWFieldInfo {
    /** The name of the field. */
    name?: string | undefined;
    /** The localized name of the field. */
    displayName?: string | undefined;
    /** The ID of the field. */
    id?: number;
    /** The description of the field. */
    description?: string | undefined;
    /** The type of the field. */
    fieldType?: WFieldType;
    /** The length of the field for variable length data types. */
    length?: number;
    /** The default value of the field for new entries that are assigned
to a template the represented field is a member of. */
    defaultValue?: string | undefined;
    /** A boolean indicating if the represented template field supports multiple values. */
    isMultiValue?: boolean;
    /** A boolean indicating if the represented field must have a value set
on entries assigned to a template that the field is a member of. */
    isRequired?: boolean;
    /** The constraint for values stored in the represented field. */
    constraint?: string | undefined;
    /** The error string that will be returned when the field constraint
is violated when setting a value for this field. */
    constraintError?: string | undefined;
    /** The list of items assigned to the represented field. */
    listValues?: string[] | undefined;
    /** The display format of the represented field. */
    format?: WFieldFormat;
    /** The name of the currency that will be using when formatting
the represented field when the Format property is set to the
Currency member of the WFieldFormat enumeration. */
    currency?: string | undefined;
    /** The custom format pattern for fields that are configured to
use a custom format. */
    formatPattern?: string | undefined;
}

export enum WFieldType {
    DateTime = "DateTime",
    Blob = "Blob",
    Date = "Date",
    ShortInteger = "ShortInteger",
    LongInteger = "LongInteger",
    List = "List",
    Number = "Number",
    String = "String",
    Time = "Time",
}

/** Enumeration of Laserfiche template field formats. */
export enum WFieldFormat {
    None = "None",
    ShortDate = "ShortDate",
    LongDate = "LongDate",
    ShortDateTime = "ShortDateTime",
    LongDateTime = "LongDateTime",
    ShortTime = "ShortTime",
    LongTime = "LongTime",
    GeneralNumber = "GeneralNumber",
    Currency = "Currency",
    Percent = "Percent",
    Scientific = "Scientific",
    Custom = "Custom",
}

export class ODataValueOfIListOfWFieldInfo implements IODataValueOfIListOfWFieldInfo {
    value?: WFieldInfo[];

    constructor(data?: IODataValueOfIListOfWFieldInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(WFieldInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ODataValueOfIListOfWFieldInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueOfIListOfWFieldInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

export interface IODataValueOfIListOfWFieldInfo {
    value?: WFieldInfo[];
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export class ODataValueContextOfIListOfWFieldInfo extends ODataValueOfIListOfWFieldInfo implements IODataValueContextOfIListOfWFieldInfo {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;

    constructor(data?: IODataValueContextOfIListOfWFieldInfo) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.odataNextLink = _data["@odata.nextLink"];
            this.odataCount = _data["@odata.count"];
        }
    }

    static fromJS(data: any): ODataValueContextOfIListOfWFieldInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueContextOfIListOfWFieldInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["@odata.nextLink"] = this.odataNextLink;
        data["@odata.count"] = this.odataCount;
        super.toJSON(data);
        return data;
    }
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export interface IODataValueContextOfIListOfWFieldInfo extends IODataValueOfIListOfWFieldInfo {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;
}

export class Entry implements IEntry {
    /** The ID of the entry. */
    id?: number;
    /** The name of the entry. */
    name?: string | undefined;
    /** The ID of the parent entry. */
    parentId?: number | undefined;
    /** The full path in the Laserfiche repository to the entry. */
    fullPath?: string | undefined;
    /** The path in the Laserfiche repository to the parent folder. */
    folderPath?: string | undefined;
    /** The name of the user that created this entry. */
    creator?: string | undefined;
    /** The creation time of the entry. */
    creationTime?: Date;
    /** The last modification time of the entry. */
    lastModifiedTime?: Date;
    /** The type of the entry. */
    entryType?: EntryType;
    /** A boolean indicating if this entry is a container object; it can have other entries as children. */
    readonly isContainer?: boolean;
    /** A boolean indicating if this entry is a leaf object; it cannot have other entries as children. */
    readonly isLeaf?: boolean;
    /** The name of the template assigned to this entry. */
    templateName?: string | undefined;
    /** The id of the template assigned to this entry. */
    templateId?: number;
    /** The names of the fields assigned to the template assigned to this entry. */
    templateFieldNames?: string[] | undefined;
    /** The name of the volume that this entry is associated with. */
    volumeName?: string | undefined;
    /** Row number assigned to this entry in the listing. */
    rowNumber?: number;
    /** The fields assigned to this entry. */
    fields?: EntryFieldValue[] | undefined;

    constructor(data?: IEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.parentId = _data["parentId"];
            this.fullPath = _data["fullPath"];
            this.folderPath = _data["folderPath"];
            this.creator = _data["creator"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifiedTime = _data["lastModifiedTime"] ? new Date(_data["lastModifiedTime"].toString()) : <any>undefined;
            this.entryType = _data["entryType"];
            (<any>this).isContainer = _data["isContainer"];
            (<any>this).isLeaf = _data["isLeaf"];
            this.templateName = _data["templateName"];
            this.templateId = _data["templateId"];
            if (Array.isArray(_data["templateFieldNames"])) {
                this.templateFieldNames = [] as any;
                for (let item of _data["templateFieldNames"])
                    this.templateFieldNames!.push(item);
            }
            this.volumeName = _data["volumeName"];
            this.rowNumber = _data["rowNumber"];
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(EntryFieldValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Entry {
        data = typeof data === 'object' ? data : {};
        let result = new Entry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        data["fullPath"] = this.fullPath;
        data["folderPath"] = this.folderPath;
        data["creator"] = this.creator;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifiedTime"] = this.lastModifiedTime ? this.lastModifiedTime.toISOString() : <any>undefined;
        data["entryType"] = this.entryType;
        data["isContainer"] = this.isContainer;
        data["isLeaf"] = this.isLeaf;
        data["templateName"] = this.templateName;
        data["templateId"] = this.templateId;
        if (Array.isArray(this.templateFieldNames)) {
            data["templateFieldNames"] = [];
            for (let item of this.templateFieldNames)
                data["templateFieldNames"].push(item);
        }
        data["volumeName"] = this.volumeName;
        data["rowNumber"] = this.rowNumber;
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEntry {
    /** The ID of the entry. */
    id?: number;
    /** The name of the entry. */
    name?: string | undefined;
    /** The ID of the parent entry. */
    parentId?: number | undefined;
    /** The full path in the Laserfiche repository to the entry. */
    fullPath?: string | undefined;
    /** The path in the Laserfiche repository to the parent folder. */
    folderPath?: string | undefined;
    /** The name of the user that created this entry. */
    creator?: string | undefined;
    /** The creation time of the entry. */
    creationTime?: Date;
    /** The last modification time of the entry. */
    lastModifiedTime?: Date;
    /** The type of the entry. */
    entryType?: EntryType;
    /** A boolean indicating if this entry is a container object; it can have other entries as children. */
    isContainer?: boolean;
    /** A boolean indicating if this entry is a leaf object; it cannot have other entries as children. */
    isLeaf?: boolean;
    /** The name of the template assigned to this entry. */
    templateName?: string | undefined;
    /** The id of the template assigned to this entry. */
    templateId?: number;
    /** The names of the fields assigned to the template assigned to this entry. */
    templateFieldNames?: string[] | undefined;
    /** The name of the volume that this entry is associated with. */
    volumeName?: string | undefined;
    /** Row number assigned to this entry in the listing. */
    rowNumber?: number;
    /** The fields assigned to this entry. */
    fields?: EntryFieldValue[] | undefined;
}

export enum EntryType {
    Folder = "Folder",
    RecordSeries = "RecordSeries",
    Document = "Document",
    Shortcut = "Shortcut",
}

export class EntryFieldValue implements IEntryFieldValue {
    /** The name of the field. */
    fieldName?: string | undefined;
    /** The values assigned to the field. */
    values?: { [key: string]: any; }[] | undefined;
    /** The type of the field. The possible field types are listed below. */
    fieldType?: WFieldType;
    /** The ID of the field. */
    fieldId?: number;
    /** A boolean indicating if the represented field supports multiple values. */
    isMultiValue?: boolean;
    /** A boolean indicating if the represented field must have a value set on entries assigned to a template that the field is a member of. */
    isRequired?: boolean;
    /** A boolean indicating if there are more field values. */
    hasMoreValues?: boolean;

    constructor(data?: IEntryFieldValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldName = _data["fieldName"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(item);
            }
            this.fieldType = _data["fieldType"];
            this.fieldId = _data["fieldId"];
            this.isMultiValue = _data["isMultiValue"];
            this.isRequired = _data["isRequired"];
            this.hasMoreValues = _data["hasMoreValues"];
        }
    }

    static fromJS(data: any): EntryFieldValue {
        data = typeof data === 'object' ? data : {};
        let result = new EntryFieldValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        data["fieldType"] = this.fieldType;
        data["fieldId"] = this.fieldId;
        data["isMultiValue"] = this.isMultiValue;
        data["isRequired"] = this.isRequired;
        data["hasMoreValues"] = this.hasMoreValues;
        return data;
    }
}

export interface IEntryFieldValue {
    /** The name of the field. */
    fieldName?: string | undefined;
    /** The values assigned to the field. */
    values?: { [key: string]: any; }[] | undefined;
    /** The type of the field. The possible field types are listed below. */
    fieldType?: WFieldType;
    /** The ID of the field. */
    fieldId?: number;
    /** A boolean indicating if the represented field supports multiple values. */
    isMultiValue?: boolean;
    /** A boolean indicating if the represented field must have a value set on entries assigned to a template that the field is a member of. */
    isRequired?: boolean;
    /** A boolean indicating if there are more field values. */
    hasMoreValues?: boolean;
}

export class Document extends Entry implements IDocument {
    /** The size of the electronic document attached to the represented document,
if there is one, in bytes. */
    elecDocumentSize?: number;
    /** The extension for the document. */
    extension?: string | undefined;
    /** A boolean indicating if there is an electronic document attached to the represented document. */
    isElectronicDocument?: boolean;
    /** A boolean indicating if the represented document is a record. */
    isRecord?: boolean;
    /** The MIME type of the electronic document. */
    mimeType?: string | undefined;
    /** The page count of the represented document. */
    pageCount?: number;
    /** A boolean indicating if the represented document is checked out. */
    isCheckedOut?: boolean;
    /** A boolean indicating if the represented document is under version control. */
    isUnderVersionControl?: boolean;
    /** The electronic document attached to the represented document. */
    edoc?: Edoc | undefined;

    constructor(data?: IDocument) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.elecDocumentSize = _data["elecDocumentSize"];
            this.extension = _data["extension"];
            this.isElectronicDocument = _data["isElectronicDocument"];
            this.isRecord = _data["isRecord"];
            this.mimeType = _data["mimeType"];
            this.pageCount = _data["pageCount"];
            this.isCheckedOut = _data["isCheckedOut"];
            this.isUnderVersionControl = _data["isUnderVersionControl"];
            this.edoc = _data["edoc"] ? Edoc.fromJS(_data["edoc"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Document {
        data = typeof data === 'object' ? data : {};
        let result = new Document();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elecDocumentSize"] = this.elecDocumentSize;
        data["extension"] = this.extension;
        data["isElectronicDocument"] = this.isElectronicDocument;
        data["isRecord"] = this.isRecord;
        data["mimeType"] = this.mimeType;
        data["pageCount"] = this.pageCount;
        data["isCheckedOut"] = this.isCheckedOut;
        data["isUnderVersionControl"] = this.isUnderVersionControl;
        data["edoc"] = this.edoc ? this.edoc.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IDocument extends IEntry {
    /** The size of the electronic document attached to the represented document,
if there is one, in bytes. */
    elecDocumentSize?: number;
    /** The extension for the document. */
    extension?: string | undefined;
    /** A boolean indicating if there is an electronic document attached to the represented document. */
    isElectronicDocument?: boolean;
    /** A boolean indicating if the represented document is a record. */
    isRecord?: boolean;
    /** The MIME type of the electronic document. */
    mimeType?: string | undefined;
    /** The page count of the represented document. */
    pageCount?: number;
    /** A boolean indicating if the represented document is checked out. */
    isCheckedOut?: boolean;
    /** A boolean indicating if the represented document is under version control. */
    isUnderVersionControl?: boolean;
    /** The electronic document attached to the represented document. */
    edoc?: Edoc | undefined;
}

export class Edoc implements IEdoc {

    constructor(data?: IEdoc) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): Edoc {
        data = typeof data === 'object' ? data : {};
        let result = new Edoc();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IEdoc {
}

export class Shortcut extends Entry implements IShortcut {
    /** The entry ID of the shortcut target. */
    targetId?: number;
    /** The extension of the shortcut target. */
    extension?: string | undefined;
    /** The entry type of the shortcut target. */
    targetType?: EntryType;

    constructor(data?: IShortcut) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.targetId = _data["targetId"];
            this.extension = _data["extension"];
            this.targetType = _data["targetType"];
        }
    }

    static fromJS(data: any): Shortcut {
        data = typeof data === 'object' ? data : {};
        let result = new Shortcut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetId"] = this.targetId;
        data["extension"] = this.extension;
        data["targetType"] = this.targetType;
        super.toJSON(data);
        return data;
    }
}

export interface IShortcut extends IEntry {
    /** The entry ID of the shortcut target. */
    targetId?: number;
    /** The extension of the shortcut target. */
    extension?: string | undefined;
    /** The entry type of the shortcut target. */
    targetType?: EntryType;
}

export class Folder extends Entry implements IFolder {
    /** A boolean indicating if the folder that this instance represents is known
to be a record folder. */
    isRecordFolder?: boolean;
    /** A boolean indicating if the folder that this instance represents is known
to directly or indirectly under a record series in the repository. */
    isUnderRecordSeries?: boolean;
    /** The entries in this folder. */
    children?: Entry[] | undefined;

    constructor(data?: IFolder) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.isRecordFolder = _data["isRecordFolder"];
            this.isUnderRecordSeries = _data["isUnderRecordSeries"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(Entry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Folder {
        data = typeof data === 'object' ? data : {};
        let result = new Folder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isRecordFolder"] = this.isRecordFolder;
        data["isUnderRecordSeries"] = this.isUnderRecordSeries;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IFolder extends IEntry {
    /** A boolean indicating if the folder that this instance represents is known
to be a record folder. */
    isRecordFolder?: boolean;
    /** A boolean indicating if the folder that this instance represents is known
to directly or indirectly under a record series in the repository. */
    isUnderRecordSeries?: boolean;
    /** The entries in this folder. */
    children?: Entry[] | undefined;
}

export class AcceptedOperation implements IAcceptedOperation {
    /** A token that can be used to check on the status of the operation. */
    token?: string | undefined;

    constructor(data?: IAcceptedOperation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): AcceptedOperation {
        data = typeof data === 'object' ? data : {};
        let result = new AcceptedOperation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data;
    }
}

export interface IAcceptedOperation {
    /** A token that can be used to check on the status of the operation. */
    token?: string | undefined;
}

export class DeleteEntryWithAuditReason implements IDeleteEntryWithAuditReason {
    /** The reason id for this audit event. */
    auditReasonId?: number | undefined;
    /** The comment for this audit event. */
    comment?: string | undefined;

    constructor(data?: IDeleteEntryWithAuditReason) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.auditReasonId = _data["auditReasonId"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): DeleteEntryWithAuditReason {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteEntryWithAuditReason();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["auditReasonId"] = this.auditReasonId;
        data["comment"] = this.comment;
        return data;
    }
}

export interface IDeleteEntryWithAuditReason {
    /** The reason id for this audit event. */
    auditReasonId?: number | undefined;
    /** The comment for this audit event. */
    comment?: string | undefined;
}

export class PatchEntryRequest implements IPatchEntryRequest {
    /** The ID of the parent entry that the entry will be moved to. */
    parentId?: number | undefined;
    /** The name that will be assigned to the entry. */
    name?: string | undefined;

    constructor(data?: IPatchEntryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PatchEntryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PatchEntryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["name"] = this.name;
        return data;
    }
}

export interface IPatchEntryRequest {
    /** The ID of the parent entry that the entry will be moved to. */
    parentId?: number | undefined;
    /** The name that will be assigned to the entry. */
    name?: string | undefined;
}

export class ODataValueOfIListOfEntry implements IODataValueOfIListOfEntry {
    value?: Entry[];

    constructor(data?: IODataValueOfIListOfEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(Entry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ODataValueOfIListOfEntry {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueOfIListOfEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

export interface IODataValueOfIListOfEntry {
    value?: Entry[];
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export class ODataValueContextOfIListOfEntry extends ODataValueOfIListOfEntry implements IODataValueContextOfIListOfEntry {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;

    constructor(data?: IODataValueContextOfIListOfEntry) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.odataNextLink = _data["@odata.nextLink"];
            this.odataCount = _data["@odata.count"];
        }
    }

    static fromJS(data: any): ODataValueContextOfIListOfEntry {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueContextOfIListOfEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["@odata.nextLink"] = this.odataNextLink;
        data["@odata.count"] = this.odataCount;
        super.toJSON(data);
        return data;
    }
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export interface IODataValueContextOfIListOfEntry extends IODataValueOfIListOfEntry {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;
}

export class ODataValueOfIListOfFieldValue implements IODataValueOfIListOfFieldValue {
    value?: FieldValue[];

    constructor(data?: IODataValueOfIListOfFieldValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(FieldValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ODataValueOfIListOfFieldValue {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueOfIListOfFieldValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

export interface IODataValueOfIListOfFieldValue {
    value?: FieldValue[];
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export class ODataValueContextOfIListOfFieldValue extends ODataValueOfIListOfFieldValue implements IODataValueContextOfIListOfFieldValue {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;

    constructor(data?: IODataValueContextOfIListOfFieldValue) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.odataNextLink = _data["@odata.nextLink"];
            this.odataCount = _data["@odata.count"];
        }
    }

    static fromJS(data: any): ODataValueContextOfIListOfFieldValue {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueContextOfIListOfFieldValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["@odata.nextLink"] = this.odataNextLink;
        data["@odata.count"] = this.odataCount;
        super.toJSON(data);
        return data;
    }
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export interface IODataValueContextOfIListOfFieldValue extends IODataValueOfIListOfFieldValue {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;
}

export class FieldValue extends EntryFieldValue implements IFieldValue {
    /** The group id of the multi value field group. If the field is not a part of a multi value field group, then there is no group id. */
    groupId?: number | undefined;

    constructor(data?: IFieldValue) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.groupId = _data["groupId"];
        }
    }

    static fromJS(data: any): FieldValue {
        data = typeof data === 'object' ? data : {};
        let result = new FieldValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        super.toJSON(data);
        return data;
    }
}

export interface IFieldValue extends IEntryFieldValue {
    /** The group id of the multi value field group. If the field is not a part of a multi value field group, then there is no group id. */
    groupId?: number | undefined;
}

export class ODataValueOfIListOfWTagInfo implements IODataValueOfIListOfWTagInfo {
    value?: WTagInfo[];

    constructor(data?: IODataValueOfIListOfWTagInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(WTagInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ODataValueOfIListOfWTagInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueOfIListOfWTagInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

export interface IODataValueOfIListOfWTagInfo {
    value?: WTagInfo[];
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export class ODataValueContextOfIListOfWTagInfo extends ODataValueOfIListOfWTagInfo implements IODataValueContextOfIListOfWTagInfo {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;

    constructor(data?: IODataValueContextOfIListOfWTagInfo) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.odataNextLink = _data["@odata.nextLink"];
            this.odataCount = _data["@odata.count"];
        }
    }

    static fromJS(data: any): ODataValueContextOfIListOfWTagInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueContextOfIListOfWTagInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["@odata.nextLink"] = this.odataNextLink;
        data["@odata.count"] = this.odataCount;
        super.toJSON(data);
        return data;
    }
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export interface IODataValueContextOfIListOfWTagInfo extends IODataValueOfIListOfWTagInfo {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;
}

export class WTagInfo implements IWTagInfo {
    /** The ID of the tag definition. */
    id?: number;
    /** The name of the tag definition. */
    name?: string | undefined;
    /** The localized name of the tag definition. */
    displayName?: string | undefined;
    /** The description of the tag definition. */
    description?: string | undefined;
    /** A boolean indicating whether or not the tag definition is classified
as a security tag (true) or an informational tag (false). */
    isSecure?: boolean;
    /** The watermark properties associated with the tag definition. */
    watermark?: Watermark | undefined;

    constructor(data?: IWTagInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isSecure = _data["isSecure"];
            this.watermark = _data["watermark"] ? Watermark.fromJS(_data["watermark"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WTagInfo {
        data = typeof data === 'object' ? data : {};
        let result = new WTagInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isSecure"] = this.isSecure;
        data["watermark"] = this.watermark ? this.watermark.toJSON() : <any>undefined;
        return data;
    }
}

export interface IWTagInfo {
    /** The ID of the tag definition. */
    id?: number;
    /** The name of the tag definition. */
    name?: string | undefined;
    /** The localized name of the tag definition. */
    displayName?: string | undefined;
    /** The description of the tag definition. */
    description?: string | undefined;
    /** A boolean indicating whether or not the tag definition is classified
as a security tag (true) or an informational tag (false). */
    isSecure?: boolean;
    /** The watermark properties associated with the tag definition. */
    watermark?: Watermark | undefined;
}

export class Watermark implements IWatermark {
    /** The watermark text associated with the tag defintion. */
    watermarkText?: string | undefined;
    /** The size of the watermark text, in points, associated with the tag definition. */
    watermarkTextSize?: number;
    /** The position of the watermark on the page. */
    watermarkPosition?: WatermarkPosition;
    /** The rotation angle, in degrees, of the watermark associated with the tag definition. */
    watermarkRotationAngle?: number;
    /** A boolean indicating whether or not the watermark associated with the tag is mandatory. */
    isWatermarkMandatory?: boolean;
    /** The intensity of the watermark associated with the tag definition. Valid value 
ranges from 0 to 100, with -1 as the default values. */
    watermarkIntensity?: number;

    constructor(data?: IWatermark) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.watermarkText = _data["watermarkText"];
            this.watermarkTextSize = _data["watermarkTextSize"];
            this.watermarkPosition = _data["watermarkPosition"];
            this.watermarkRotationAngle = _data["watermarkRotationAngle"];
            this.isWatermarkMandatory = _data["isWatermarkMandatory"];
            this.watermarkIntensity = _data["watermarkIntensity"];
        }
    }

    static fromJS(data: any): Watermark {
        data = typeof data === 'object' ? data : {};
        let result = new Watermark();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["watermarkText"] = this.watermarkText;
        data["watermarkTextSize"] = this.watermarkTextSize;
        data["watermarkPosition"] = this.watermarkPosition;
        data["watermarkRotationAngle"] = this.watermarkRotationAngle;
        data["isWatermarkMandatory"] = this.isWatermarkMandatory;
        data["watermarkIntensity"] = this.watermarkIntensity;
        return data;
    }
}

export interface IWatermark {
    /** The watermark text associated with the tag defintion. */
    watermarkText?: string | undefined;
    /** The size of the watermark text, in points, associated with the tag definition. */
    watermarkTextSize?: number;
    /** The position of the watermark on the page. */
    watermarkPosition?: WatermarkPosition;
    /** The rotation angle, in degrees, of the watermark associated with the tag definition. */
    watermarkRotationAngle?: number;
    /** A boolean indicating whether or not the watermark associated with the tag is mandatory. */
    isWatermarkMandatory?: boolean;
    /** The intensity of the watermark associated with the tag definition. Valid value 
ranges from 0 to 100, with -1 as the default values. */
    watermarkIntensity?: number;
}

export enum WatermarkPosition {
    TopLeft = "TopLeft",
    TopCenter = "TopCenter",
    TopRight = "TopRight",
    MiddleLeft = "MiddleLeft",
    DeadCenter = "DeadCenter",
    MiddleRight = "MiddleRight",
    BottomLeft = "BottomLeft",
    BottomCenter = "BottomCenter",
    BottomRight = "BottomRight",
}

export class PutTagRequest implements IPutTagRequest {
    /** The tag names to assign to the entry. */
    tags?: string[] | undefined;

    constructor(data?: IPutTagRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): PutTagRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PutTagRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }
}

export interface IPutTagRequest {
    /** The tag names to assign to the entry. */
    tags?: string[] | undefined;
}

export class ODataValueOfIListOfWEntryLinkInfo implements IODataValueOfIListOfWEntryLinkInfo {
    value?: WEntryLinkInfo[];

    constructor(data?: IODataValueOfIListOfWEntryLinkInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(WEntryLinkInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ODataValueOfIListOfWEntryLinkInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueOfIListOfWEntryLinkInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

export interface IODataValueOfIListOfWEntryLinkInfo {
    value?: WEntryLinkInfo[];
}

export class WEntryLinkInfo implements IWEntryLinkInfo {
    /** The ID of the entry link. */
    linkId?: number;
    /** The ID of the source entry of the represented link. */
    sourceId?: number;
    /** The full path to the source entry of the represented link. */
    sourceFullPath?: string | undefined;
    /** The label for the source entry in the link type. */
    sourceLabel?: string | undefined;
    /** The ID of the target entry of the represented link. */
    targetId?: number;
    /** The full path to the target entry of the represented link. */
    targetFullPath?: string | undefined;
    /** The label for the target entry in the link type. */
    targetLabel?: string | undefined;
    /** The descriptive text for the represented entry link. */
    description?: string | undefined;
    /** The description of the link type. */
    linkTypeDescription?: string | undefined;
    /** The properties for the entry link. */
    linkProperties?: { [key: string]: string; } | undefined;
    /** The navigation link to the source entry. */
    sourceLink?: string | undefined;
    /** The navigation link to the target entry. */
    targetLink?: string | undefined;

    constructor(data?: IWEntryLinkInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.linkId = _data["linkId"];
            this.sourceId = _data["sourceId"];
            this.sourceFullPath = _data["sourceFullPath"];
            this.sourceLabel = _data["sourceLabel"];
            this.targetId = _data["targetId"];
            this.targetFullPath = _data["targetFullPath"];
            this.targetLabel = _data["targetLabel"];
            this.description = _data["description"];
            this.linkTypeDescription = _data["linkTypeDescription"];
            if (_data["linkProperties"]) {
                this.linkProperties = {} as any;
                for (let key in _data["linkProperties"]) {
                    if (_data["linkProperties"].hasOwnProperty(key))
                        (<any>this.linkProperties)![key] = _data["linkProperties"][key];
                }
            }
            this.sourceLink = _data["sourceLink"];
            this.targetLink = _data["targetLink"];
        }
    }

    static fromJS(data: any): WEntryLinkInfo {
        data = typeof data === 'object' ? data : {};
        let result = new WEntryLinkInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["linkId"] = this.linkId;
        data["sourceId"] = this.sourceId;
        data["sourceFullPath"] = this.sourceFullPath;
        data["sourceLabel"] = this.sourceLabel;
        data["targetId"] = this.targetId;
        data["targetFullPath"] = this.targetFullPath;
        data["targetLabel"] = this.targetLabel;
        data["description"] = this.description;
        data["linkTypeDescription"] = this.linkTypeDescription;
        if (this.linkProperties) {
            data["linkProperties"] = {};
            for (let key in this.linkProperties) {
                if (this.linkProperties.hasOwnProperty(key))
                    (<any>data["linkProperties"])[key] = this.linkProperties[key];
            }
        }
        data["sourceLink"] = this.sourceLink;
        data["targetLink"] = this.targetLink;
        return data;
    }
}

export interface IWEntryLinkInfo {
    /** The ID of the entry link. */
    linkId?: number;
    /** The ID of the source entry of the represented link. */
    sourceId?: number;
    /** The full path to the source entry of the represented link. */
    sourceFullPath?: string | undefined;
    /** The label for the source entry in the link type. */
    sourceLabel?: string | undefined;
    /** The ID of the target entry of the represented link. */
    targetId?: number;
    /** The full path to the target entry of the represented link. */
    targetFullPath?: string | undefined;
    /** The label for the target entry in the link type. */
    targetLabel?: string | undefined;
    /** The descriptive text for the represented entry link. */
    description?: string | undefined;
    /** The description of the link type. */
    linkTypeDescription?: string | undefined;
    /** The properties for the entry link. */
    linkProperties?: { [key: string]: string; } | undefined;
    /** The navigation link to the source entry. */
    sourceLink?: string | undefined;
    /** The navigation link to the target entry. */
    targetLink?: string | undefined;
}

export class PutLinksRequest implements IPutLinksRequest {
    /** The target entry ID to create a link to. */
    targetId?: number;
    /** The link type ID to create the link with. */
    linkTypeId?: number;
    /** Custom properties (key, value pairs) to be added to the link */
    customProperties?: { [key: string]: string; } | undefined;

    constructor(data?: IPutLinksRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.targetId = _data["targetId"];
            this.linkTypeId = _data["linkTypeId"];
            if (_data["customProperties"]) {
                this.customProperties = {} as any;
                for (let key in _data["customProperties"]) {
                    if (_data["customProperties"].hasOwnProperty(key))
                        (<any>this.customProperties)![key] = _data["customProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): PutLinksRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PutLinksRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetId"] = this.targetId;
        data["linkTypeId"] = this.linkTypeId;
        if (this.customProperties) {
            data["customProperties"] = {};
            for (let key in this.customProperties) {
                if (this.customProperties.hasOwnProperty(key))
                    (<any>data["customProperties"])[key] = this.customProperties[key];
            }
        }
        return data;
    }
}

export interface IPutLinksRequest {
    /** The target entry ID to create a link to. */
    targetId?: number;
    /** The link type ID to create the link with. */
    linkTypeId?: number;
    /** Custom properties (key, value pairs) to be added to the link */
    customProperties?: { [key: string]: string; } | undefined;
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export class ODataValueContextOfIListOfWEntryLinkInfo extends ODataValueOfIListOfWEntryLinkInfo implements IODataValueContextOfIListOfWEntryLinkInfo {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;

    constructor(data?: IODataValueContextOfIListOfWEntryLinkInfo) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.odataNextLink = _data["@odata.nextLink"];
            this.odataCount = _data["@odata.count"];
        }
    }

    static fromJS(data: any): ODataValueContextOfIListOfWEntryLinkInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueContextOfIListOfWEntryLinkInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["@odata.nextLink"] = this.odataNextLink;
        data["@odata.count"] = this.odataCount;
        super.toJSON(data);
        return data;
    }
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export interface IODataValueContextOfIListOfWEntryLinkInfo extends IODataValueOfIListOfWEntryLinkInfo {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;
}

export class PostEntryChildrenRequest implements IPostEntryChildrenRequest {
    /** The name of the entry. */
    name?: string | undefined;
    /** The type of the entry. */
    entryType?: PostEntryChildrenEntryType | undefined;
    /** The TargetId is only needed for creating a shortcut. This will be the entry ID of the shortcut target. */
    targetId?: number;
    /** The SourceId is needed for some operations that require a source/destination. One example is the Copy operation. */
    sourceId?: number;

    constructor(data?: IPostEntryChildrenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.entryType = _data["entryType"];
            this.targetId = _data["targetId"];
            this.sourceId = _data["sourceId"];
        }
    }

    static fromJS(data: any): PostEntryChildrenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PostEntryChildrenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["entryType"] = this.entryType;
        data["targetId"] = this.targetId;
        data["sourceId"] = this.sourceId;
        return data;
    }
}

export interface IPostEntryChildrenRequest {
    /** The name of the entry. */
    name?: string | undefined;
    /** The type of the entry. */
    entryType?: PostEntryChildrenEntryType | undefined;
    /** The TargetId is only needed for creating a shortcut. This will be the entry ID of the shortcut target. */
    targetId?: number;
    /** The SourceId is needed for some operations that require a source/destination. One example is the Copy operation. */
    sourceId?: number;
}

export enum PostEntryChildrenEntryType {
    Folder = "Folder",
    Shortcut = "Shortcut",
}

export class CopyAsyncRequest implements ICopyAsyncRequest {
    /** The name of the entry. */
    name?: string;
    /** The source entry Id to copy. */
    sourceId?: number;

    constructor(data?: ICopyAsyncRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.sourceId = _data["sourceId"];
        }
    }

    static fromJS(data: any): CopyAsyncRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CopyAsyncRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["sourceId"] = this.sourceId;
        return data;
    }
}

export interface ICopyAsyncRequest {
    /** The name of the entry. */
    name?: string;
    /** The source entry Id to copy. */
    sourceId?: number;
}

export class ODataValueOfBoolean implements IODataValueOfBoolean {
    value?: boolean;

    constructor(data?: IODataValueOfBoolean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ODataValueOfBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueOfBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data;
    }
}

export interface IODataValueOfBoolean {
    value?: boolean;
}

export class GetEdocWithAuditReasonRequest implements IGetEdocWithAuditReasonRequest {
    /** The reason id for this audit event. */
    auditReasonId?: number | undefined;
    /** The comment for this audit event. */
    comment?: string | undefined;

    constructor(data?: IGetEdocWithAuditReasonRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.auditReasonId = _data["auditReasonId"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): GetEdocWithAuditReasonRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetEdocWithAuditReasonRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["auditReasonId"] = this.auditReasonId;
        data["comment"] = this.comment;
        return data;
    }
}

export interface IGetEdocWithAuditReasonRequest {
    /** The reason id for this audit event. */
    auditReasonId?: number | undefined;
    /** The comment for this audit event. */
    comment?: string | undefined;
}

export class GetDynamicFieldLogicValueRequest implements IGetDynamicFieldLogicValueRequest {
    /** The template id. */
    templateId?: number;
    /** The dynamic fields. */
    fieldValues?: { [key: string]: string; } | undefined;

    constructor(data?: IGetDynamicFieldLogicValueRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.templateId = _data["templateId"];
            if (_data["fieldValues"]) {
                this.fieldValues = {} as any;
                for (let key in _data["fieldValues"]) {
                    if (_data["fieldValues"].hasOwnProperty(key))
                        (<any>this.fieldValues)![key] = _data["fieldValues"][key];
                }
            }
        }
    }

    static fromJS(data: any): GetDynamicFieldLogicValueRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetDynamicFieldLogicValueRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateId"] = this.templateId;
        if (this.fieldValues) {
            data["fieldValues"] = {};
            for (let key in this.fieldValues) {
                if (this.fieldValues.hasOwnProperty(key))
                    (<any>data["fieldValues"])[key] = this.fieldValues[key];
            }
        }
        return data;
    }
}

export interface IGetDynamicFieldLogicValueRequest {
    /** The template id. */
    templateId?: number;
    /** The dynamic fields. */
    fieldValues?: { [key: string]: string; } | undefined;
}

export class PutTemplateRequest implements IPutTemplateRequest {
    /** The template that will be assigned to the entry. */
    templateName?: string | undefined;
    /** The template fields that will be assigned to the entry. */
    fields?: { [key: string]: FieldToUpdate; } | undefined;

    constructor(data?: IPutTemplateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.templateName = _data["templateName"];
            if (_data["fields"]) {
                this.fields = {} as any;
                for (let key in _data["fields"]) {
                    if (_data["fields"].hasOwnProperty(key))
                        (<any>this.fields)![key] = _data["fields"][key] ? FieldToUpdate.fromJS(_data["fields"][key]) : new FieldToUpdate();
                }
            }
        }
    }

    static fromJS(data: any): PutTemplateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PutTemplateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateName"] = this.templateName;
        if (this.fields) {
            data["fields"] = {};
            for (let key in this.fields) {
                if (this.fields.hasOwnProperty(key))
                    (<any>data["fields"])[key] = this.fields[key] ? this.fields[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IPutTemplateRequest {
    /** The template that will be assigned to the entry. */
    templateName?: string | undefined;
    /** The template fields that will be assigned to the entry. */
    fields?: { [key: string]: FieldToUpdate; } | undefined;
}

export class RepositoryInfo implements IRepositoryInfo {
    /** The repository id. */
    repoId?: string | undefined;
    /** The repository name. */
    repoName?: string | undefined;
    /** The corresponding repository WebClient url. */
    webclientUrl?: string | undefined;

    constructor(data?: IRepositoryInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.repoId = _data["repoId"];
            this.repoName = _data["repoName"];
            this.webclientUrl = _data["webclientUrl"];
        }
    }

    static fromJS(data: any): RepositoryInfo {
        data = typeof data === 'object' ? data : {};
        let result = new RepositoryInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["repoId"] = this.repoId;
        data["repoName"] = this.repoName;
        data["webclientUrl"] = this.webclientUrl;
        return data;
    }
}

export interface IRepositoryInfo {
    /** The repository id. */
    repoId?: string | undefined;
    /** The repository name. */
    repoName?: string | undefined;
    /** The corresponding repository WebClient url. */
    webclientUrl?: string | undefined;
}

export class ODataValueOfDateTime implements IODataValueOfDateTime {
    value?: Date;

    constructor(data?: IODataValueOfDateTime) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] ? new Date(_data["value"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ODataValueOfDateTime {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueOfDateTime();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toISOString() : <any>undefined;
        return data;
    }
}

export interface IODataValueOfDateTime {
    value?: Date;
}

export class OperationProgress implements IOperationProgress {
    operationToken?: string | undefined;
    operationType?: string | undefined;
    percentComplete?: number;
    status?: OperationStatus;
    errors?: OperationErrorItem[] | undefined;

    constructor(data?: IOperationProgress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.operationToken = _data["operationToken"];
            this.operationType = _data["operationType"];
            this.percentComplete = _data["percentComplete"];
            this.status = _data["status"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(OperationErrorItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OperationProgress {
        data = typeof data === 'object' ? data : {};
        let result = new OperationProgress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["operationToken"] = this.operationToken;
        data["operationType"] = this.operationType;
        data["percentComplete"] = this.percentComplete;
        data["status"] = this.status;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOperationProgress {
    operationToken?: string | undefined;
    operationType?: string | undefined;
    percentComplete?: number;
    status?: OperationStatus;
    errors?: OperationErrorItem[] | undefined;
}

export enum OperationStatus {
    NotStarted = "NotStarted",
    InProgress = "InProgress",
    Completed = "Completed",
    Failed = "Failed",
    Cancelled = "Cancelled",
}

export class OperationErrorItem implements IOperationErrorItem {
    objectId?: number;
    errorMessage?: string | undefined;

    constructor(data?: IOperationErrorItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectId = _data["objectId"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): OperationErrorItem {
        data = typeof data === 'object' ? data : {};
        let result = new OperationErrorItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectId"] = this.objectId;
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IOperationErrorItem {
    objectId?: number;
    errorMessage?: string | undefined;
}

export class AuditReasons implements IAuditReasons {
    /** The audit reasons associated with delete entry. */
    deleteEntry?: WAuditReason[] | undefined;
    /** The audit reasons associated with export document. */
    exportDocument?: WAuditReason[] | undefined;

    constructor(data?: IAuditReasons) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["deleteEntry"])) {
                this.deleteEntry = [] as any;
                for (let item of _data["deleteEntry"])
                    this.deleteEntry!.push(WAuditReason.fromJS(item));
            }
            if (Array.isArray(_data["exportDocument"])) {
                this.exportDocument = [] as any;
                for (let item of _data["exportDocument"])
                    this.exportDocument!.push(WAuditReason.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AuditReasons {
        data = typeof data === 'object' ? data : {};
        let result = new AuditReasons();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.deleteEntry)) {
            data["deleteEntry"] = [];
            for (let item of this.deleteEntry)
                data["deleteEntry"].push(item.toJSON());
        }
        if (Array.isArray(this.exportDocument)) {
            data["exportDocument"] = [];
            for (let item of this.exportDocument)
                data["exportDocument"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAuditReasons {
    /** The audit reasons associated with delete entry. */
    deleteEntry?: WAuditReason[] | undefined;
    /** The audit reasons associated with export document. */
    exportDocument?: WAuditReason[] | undefined;
}

export class WAuditReason implements IWAuditReason {
    /** The audit reason id. */
    id?: number;
    /** The audit reason text. */
    name?: string | undefined;

    constructor(data?: IWAuditReason) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): WAuditReason {
        data = typeof data === 'object' ? data : {};
        let result = new WAuditReason();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IWAuditReason {
    /** The audit reason id. */
    id?: number;
    /** The audit reason text. */
    name?: string | undefined;
}

export class AdvancedSearchRequest implements IAdvancedSearchRequest {
    /** Search command for advanced search */
    searchCommand?: string | undefined;
    /** Fuzzy type (None, Percentage, or NumberOfLetters) */
    fuzzyType?: FuzzyType;
    /** Fuzzy factor (percentage as int or int value) */
    fuzzyFactor?: number;

    constructor(data?: IAdvancedSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchCommand = _data["searchCommand"];
            this.fuzzyType = _data["fuzzyType"];
            this.fuzzyFactor = _data["fuzzyFactor"];
        }
    }

    static fromJS(data: any): AdvancedSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AdvancedSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchCommand"] = this.searchCommand;
        data["fuzzyType"] = this.fuzzyType;
        data["fuzzyFactor"] = this.fuzzyFactor;
        return data;
    }
}

export interface IAdvancedSearchRequest {
    /** Search command for advanced search */
    searchCommand?: string | undefined;
    /** Fuzzy type (None, Percentage, or NumberOfLetters) */
    fuzzyType?: FuzzyType;
    /** Fuzzy factor (percentage as int or int value) */
    fuzzyFactor?: number;
}

export enum FuzzyType {
    None = 0,
    Percentage = 1,
    NumberOfLetters = 2,
}

export class ODataValueOfIListOfContextHit implements IODataValueOfIListOfContextHit {
    value?: ContextHit[];

    constructor(data?: IODataValueOfIListOfContextHit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(ContextHit.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ODataValueOfIListOfContextHit {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueOfIListOfContextHit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

export interface IODataValueOfIListOfContextHit {
    value?: ContextHit[];
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export class ODataValueContextOfIListOfContextHit extends ODataValueOfIListOfContextHit implements IODataValueContextOfIListOfContextHit {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;

    constructor(data?: IODataValueContextOfIListOfContextHit) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.odataNextLink = _data["@odata.nextLink"];
            this.odataCount = _data["@odata.count"];
        }
    }

    static fromJS(data: any): ODataValueContextOfIListOfContextHit {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueContextOfIListOfContextHit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["@odata.nextLink"] = this.odataNextLink;
        data["@odata.count"] = this.odataCount;
        super.toJSON(data);
        return data;
    }
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export interface IODataValueContextOfIListOfContextHit extends IODataValueOfIListOfContextHit {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;
}

export class ContextHit implements IContextHit {
    hitType?: HitType;
    isAnnotationHit?: boolean;
    annotationId?: number;
    pageNumber?: number;
    pageOffset?: number;
    context?: string | undefined;
    highlight1Offset?: number;
    highlight1Length?: number;
    highlight2Offset?: number;
    highlight2Length?: number;
    hitWidth?: number;
    edocHitCount?: number;
    fieldHitCount?: number;
    fieldName?: string | undefined;
    hitNumber?: number;

    constructor(data?: IContextHit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hitType = _data["hitType"];
            this.isAnnotationHit = _data["isAnnotationHit"];
            this.annotationId = _data["annotationId"];
            this.pageNumber = _data["pageNumber"];
            this.pageOffset = _data["pageOffset"];
            this.context = _data["context"];
            this.highlight1Offset = _data["highlight1Offset"];
            this.highlight1Length = _data["highlight1Length"];
            this.highlight2Offset = _data["highlight2Offset"];
            this.highlight2Length = _data["highlight2Length"];
            this.hitWidth = _data["hitWidth"];
            this.edocHitCount = _data["edocHitCount"];
            this.fieldHitCount = _data["fieldHitCount"];
            this.fieldName = _data["fieldName"];
            this.hitNumber = _data["hitNumber"];
        }
    }

    static fromJS(data: any): ContextHit {
        data = typeof data === 'object' ? data : {};
        let result = new ContextHit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hitType"] = this.hitType;
        data["isAnnotationHit"] = this.isAnnotationHit;
        data["annotationId"] = this.annotationId;
        data["pageNumber"] = this.pageNumber;
        data["pageOffset"] = this.pageOffset;
        data["context"] = this.context;
        data["highlight1Offset"] = this.highlight1Offset;
        data["highlight1Length"] = this.highlight1Length;
        data["highlight2Offset"] = this.highlight2Offset;
        data["highlight2Length"] = this.highlight2Length;
        data["hitWidth"] = this.hitWidth;
        data["edocHitCount"] = this.edocHitCount;
        data["fieldHitCount"] = this.fieldHitCount;
        data["fieldName"] = this.fieldName;
        data["hitNumber"] = this.hitNumber;
        return data;
    }
}

export interface IContextHit {
    hitType?: HitType;
    isAnnotationHit?: boolean;
    annotationId?: number;
    pageNumber?: number;
    pageOffset?: number;
    context?: string | undefined;
    highlight1Offset?: number;
    highlight1Length?: number;
    highlight2Offset?: number;
    highlight2Length?: number;
    hitWidth?: number;
    edocHitCount?: number;
    fieldHitCount?: number;
    fieldName?: string | undefined;
    hitNumber?: number;
}

export enum HitType {
    PageContent = 0,
    Note = 1,
    Callout = 2,
    TextBox = 3,
    Edoc = 4,
    Prop = 5,
    Name = 6,
    Extension = 7,
    VersionGroupNote = 8,
    VersionComment = 9,
    Field = 10,
    SignatureComment = 11,
    CertificateSubject = 12,
    TagComment = 13,
    AnnotationComment = 14,
    Attachment = 15,
}

export class SimpleSearchRequest implements ISimpleSearchRequest {
    /** Search command for simple search */
    searchCommand?: string | undefined;

    constructor(data?: ISimpleSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchCommand = _data["searchCommand"];
        }
    }

    static fromJS(data: any): SimpleSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchCommand"] = this.searchCommand;
        return data;
    }
}

export interface ISimpleSearchRequest {
    /** Search command for simple search */
    searchCommand?: string | undefined;
}

export class ODataValueOfIListOfWTemplateInfo implements IODataValueOfIListOfWTemplateInfo {
    value?: WTemplateInfo[];

    constructor(data?: IODataValueOfIListOfWTemplateInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(WTemplateInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ODataValueOfIListOfWTemplateInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueOfIListOfWTemplateInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

export interface IODataValueOfIListOfWTemplateInfo {
    value?: WTemplateInfo[];
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export class ODataValueContextOfIListOfWTemplateInfo extends ODataValueOfIListOfWTemplateInfo implements IODataValueContextOfIListOfWTemplateInfo {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;

    constructor(data?: IODataValueContextOfIListOfWTemplateInfo) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.odataNextLink = _data["@odata.nextLink"];
            this.odataCount = _data["@odata.count"];
        }
    }

    static fromJS(data: any): ODataValueContextOfIListOfWTemplateInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueContextOfIListOfWTemplateInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["@odata.nextLink"] = this.odataNextLink;
        data["@odata.count"] = this.odataCount;
        super.toJSON(data);
        return data;
    }
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export interface IODataValueContextOfIListOfWTemplateInfo extends IODataValueOfIListOfWTemplateInfo {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;
}

export class WTemplateInfo implements IWTemplateInfo {
    /** The ID of the template definition. */
    id?: number;
    /** The name of the template definition. */
    name?: string | undefined;
    /** The localized name of the template definition. */
    displayName?: string | undefined;
    /** The description of the template definition. */
    description?: string | undefined;
    /** The color assigned to the template definition. */
    color?: LFColor | undefined;
    /** The number of fields assigned to the template. */
    fieldCount?: number;

    constructor(data?: IWTemplateInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.color = _data["color"] ? LFColor.fromJS(_data["color"]) : <any>undefined;
            this.fieldCount = _data["fieldCount"];
        }
    }

    static fromJS(data: any): WTemplateInfo {
        data = typeof data === 'object' ? data : {};
        let result = new WTemplateInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["color"] = this.color ? this.color.toJSON() : <any>undefined;
        data["fieldCount"] = this.fieldCount;
        return data;
    }
}

export interface IWTemplateInfo {
    /** The ID of the template definition. */
    id?: number;
    /** The name of the template definition. */
    name?: string | undefined;
    /** The localized name of the template definition. */
    displayName?: string | undefined;
    /** The description of the template definition. */
    description?: string | undefined;
    /** The color assigned to the template definition. */
    color?: LFColor | undefined;
    /** The number of fields assigned to the template. */
    fieldCount?: number;
}

export class LFColor implements ILFColor {
    a?: number;
    r?: number;
    g?: number;
    b?: number;

    constructor(data?: ILFColor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.a = _data["a"];
            this.r = _data["r"];
            this.g = _data["g"];
            this.b = _data["b"];
        }
    }

    static fromJS(data: any): LFColor {
        data = typeof data === 'object' ? data : {};
        let result = new LFColor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["a"] = this.a;
        data["r"] = this.r;
        data["g"] = this.g;
        data["b"] = this.b;
        return data;
    }
}

export interface ILFColor {
    a?: number;
    r?: number;
    g?: number;
    b?: number;
}

export class ODataValueOfIListOfTemplateFieldInfo implements IODataValueOfIListOfTemplateFieldInfo {
    value?: TemplateFieldInfo[];

    constructor(data?: IODataValueOfIListOfTemplateFieldInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(TemplateFieldInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ODataValueOfIListOfTemplateFieldInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueOfIListOfTemplateFieldInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

export interface IODataValueOfIListOfTemplateFieldInfo {
    value?: TemplateFieldInfo[];
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export class ODataValueContextOfIListOfTemplateFieldInfo extends ODataValueOfIListOfTemplateFieldInfo implements IODataValueContextOfIListOfTemplateFieldInfo {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;

    constructor(data?: IODataValueContextOfIListOfTemplateFieldInfo) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.odataNextLink = _data["@odata.nextLink"];
            this.odataCount = _data["@odata.count"];
        }
    }

    static fromJS(data: any): ODataValueContextOfIListOfTemplateFieldInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueContextOfIListOfTemplateFieldInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["@odata.nextLink"] = this.odataNextLink;
        data["@odata.count"] = this.odataCount;
        super.toJSON(data);
        return data;
    }
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export interface IODataValueContextOfIListOfTemplateFieldInfo extends IODataValueOfIListOfTemplateFieldInfo {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;
}

export class TemplateFieldInfo extends WFieldInfo implements ITemplateFieldInfo {
    /** A form logic rule associated with a Laserfiche template and field definition. */
    rule?: Rule | undefined;
    /** The group id of the field in the template. */
    groupId?: number;
    /** The name of field group. */
    groupName?: string | undefined;

    constructor(data?: ITemplateFieldInfo) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.rule = _data["rule"] ? Rule.fromJS(_data["rule"]) : <any>undefined;
            this.groupId = _data["groupId"];
            this.groupName = _data["groupName"];
        }
    }

    static fromJS(data: any): TemplateFieldInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateFieldInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rule"] = this.rule ? this.rule.toJSON() : <any>undefined;
        data["groupId"] = this.groupId;
        data["groupName"] = this.groupName;
        super.toJSON(data);
        return data;
    }
}

export interface ITemplateFieldInfo extends IWFieldInfo {
    /** A form logic rule associated with a Laserfiche template and field definition. */
    rule?: Rule | undefined;
    /** The group id of the field in the template. */
    groupId?: number;
    /** The name of field group. */
    groupName?: string | undefined;
}

export class Rule implements IRule {
    /** The IDs of the parent fields in the template according to the
form logic rule. */
    ancestors?: number[] | undefined;

    constructor(data?: IRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ancestors"])) {
                this.ancestors = [] as any;
                for (let item of _data["ancestors"])
                    this.ancestors!.push(item);
            }
        }
    }

    static fromJS(data: any): Rule {
        data = typeof data === 'object' ? data : {};
        let result = new Rule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ancestors)) {
            data["ancestors"] = [];
            for (let item of this.ancestors)
                data["ancestors"].push(item);
        }
        return data;
    }
}

export interface IRule {
    /** The IDs of the parent fields in the template according to the
form logic rule. */
    ancestors?: number[] | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

class ClientBase {}
export interface IRepositoryApiClient {
  attributesClient: IAttributesClient;
  auditReasonsClient: IAuditReasonsClient;
  entriesClient: IEntriesClient;
  fieldDefinitionsClient: IFieldDefinitionsClient;
  repositoriesClient: IRepositoriesClient;
  searchesClient: ISearchesClient;
  serverSessionClient: IServerSessionClient;
  simpleSearchesClient: ISimpleSearchesClient;
  tagDefinitionsClient: ITagDefinitionsClient;
  tasksClient: ITasksClient;
  templateDefinitionsClient: ITemplateDefinitionsClient;
  get defaultRequestHeaders(): Record<string, string>;
  set defaultRequestHeaders(headers: Record<string, string>);
}
// @ts-ignore
export class RepositoryApiClient implements IRepositoryApiClient {
  private baseUrl: string;

  public attributesClient: IAttributesClient;
  public auditReasonsClient: IAuditReasonsClient;
  public entriesClient: IEntriesClient;
  public fieldDefinitionsClient: IFieldDefinitionsClient;
  public repositoriesClient: IRepositoriesClient;
  public searchesClient: ISearchesClient;
  public serverSessionClient: IServerSessionClient;
  public simpleSearchesClient: ISimpleSearchesClient;
  public tagDefinitionsClient: ITagDefinitionsClient;
  public tasksClient: ITasksClient;
  public templateDefinitionsClient: ITemplateDefinitionsClient;

  private repoClientHandler: RepositoryApiClientHttpHandler;

  public get defaultRequestHeaders(): Record<string, string> {
    return this.repoClientHandler.defaultRequestHeaders;
  }

  public set defaultRequestHeaders(headers: Record<string, string>) {
    this.repoClientHandler.defaultRequestHeaders = headers;
  }

  private constructor(httpRequestHandler: HttpRequestHandler, baseUrlDebug?: string) {
    this.repoClientHandler = new RepositoryApiClientHttpHandler(httpRequestHandler);
    let fetch = this.repoClientHandler.httpHandler;
    fetch = fetch.bind(this.repoClientHandler);
    let http = {
      fetch,
    };
    this.baseUrl = baseUrlDebug ?? '';
    this.attributesClient = new AttributesClient(this.baseUrl, http);
    this.auditReasonsClient = new AuditReasonsClient(this.baseUrl, http);
    this.entriesClient = new EntriesClient(this.baseUrl, http);
    this.fieldDefinitionsClient = new FieldDefinitionsClient(this.baseUrl, http);
    this.repositoriesClient = new RepositoriesClient(this.baseUrl, http);
    this.searchesClient = new SearchesClient(this.baseUrl, http);
    this.serverSessionClient = new ServerSessionClient(this.baseUrl, http);
    this.simpleSearchesClient = new SimpleSearchesClient(this.baseUrl, http);
    this.tagDefinitionsClient = new TagDefinitionsClient(this.baseUrl, http);
    this.tasksClient = new TasksClient(this.baseUrl, http);
    this.templateDefinitionsClient = new TemplateDefinitionsClient(this.baseUrl, http);
  }

  public static createFromHttpRequestHandler(
    httpRequestHandler: HttpRequestHandler,
    baseUrlDebug?: string
  ): RepositoryApiClient {
    if (!httpRequestHandler) throw new Error('Argument cannot be null: httpRequestHandler');
    let repoClient = new RepositoryApiClient(httpRequestHandler, baseUrlDebug);
    return repoClient;
  }

  public static createFromAccessKey(
    servicePrincipalKey: string,
    accessKey: AccessKey,
    baseUrlDebug?: string
  ): RepositoryApiClient {
    let handler = new OAuthClientCredentialsHandler(servicePrincipalKey, accessKey);
    return RepositoryApiClient.createFromHttpRequestHandler(handler, baseUrlDebug);
  }
}
/** @internal */
export class RepositoryApiClientHttpHandler {
  private _httpRequestHandler: HttpRequestHandler;
  public defaultRequestHeaders: Record<string, string>;

  constructor(httpRequestHandler: HttpRequestHandler) {
    this._httpRequestHandler = httpRequestHandler;
    this.defaultRequestHeaders = {};
  }

  public async httpHandler(url: string, init: RequestInit): Promise<Response> {
    const maxRetries = 1;
    let retryCount = 0;
    let shouldRetry = true;

    if (this.defaultRequestHeaders) {
      init.headers = Object.assign({}, this.defaultRequestHeaders, init.headers);
    }
    let response: Response | undefined;
    while (retryCount <= maxRetries && shouldRetry) {
      const beforeSendResult = await this._httpRequestHandler.beforeFetchRequestAsync(url, init);
      let absoluteUrl: string;
      if (url.startsWith('http')) {
        absoluteUrl = url;
      } else {
        const apiBasedAddress = DomainUtils.getRepositoryEndpoint(beforeSendResult.regionalDomain);
        absoluteUrl = UrlUtils.combineURLs(apiBasedAddress, url);
      }

      try {
        response = await fetch(absoluteUrl, init);
        shouldRetry =
          (await this._httpRequestHandler.afterFetchResponseAsync(absoluteUrl, response, init)) ||
          isRetryable(response, init);
        if (!shouldRetry) {
          return response;
        }
      } catch (err) {
        if (retryCount >= maxRetries) {
          throw err;
        }
        shouldRetry = true;
        console.warn(`Retrying fetch due to exception: ${err}`);
      } finally {
        retryCount++;
      }
    }
    if (!response) {
      throw new Error('Undefined response, there is a bug!');
    }
    return response;
  }
}

function isRetryable(response: Response, init: RequestInit): boolean {
  const isIdempotent = init.method != 'POST';
  return (response.status >= 500 || response.status == 408) && isIdempotent;
}

async function getNextLinkListing<T extends IODataValueContextOfIListOfEntry>(
  http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> },
  processListing: (response: Response) => Promise<T>,
  nextLink: string,
  maxPageSize?: number
): Promise<T> {
  if (!nextLink) {
    throw new Error('Next Link is undefined');
  }
  const prefer = CreateMaxPageSizePreferHeaderPayload(maxPageSize);
  let options_ = <RequestInit>{
    method: 'GET',
    headers: {
      Prefer: prefer !== undefined && prefer !== null ? prefer : '',
      Accept: 'application/json',
    },
  };
  let processListingTwo = processListing.bind(http);
  return http.fetch(nextLink, options_).then((_response: Response) => {
    return processListingTwo(_response);
  });
}

function CreateMaxPageSizePreferHeaderPayload(maxSize?: number): string | undefined {
  //puts the max size into the prefer header of the GET request
  if (!maxSize) {
    return undefined;
  } else {
    return `maxpagesize=${maxSize}`;
  }
}

export interface IAttributesClient {
  getTrusteeAttributeKeyValuePairsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfListOfAttribute>;
  GetTrusteeAttributeKeyValuePairsForEach(args: {
    callback: (response: ODataValueContextOfListOfAttribute) => Promise<boolean>;
    repoId: string;
    everyone?: boolean;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;
}

export interface IEntriesClient {
  GetEntryListingForEach(args: {
    callback: (response: ODataValueContextOfIListOfEntry) => Promise<boolean>;
    repoId: string;
    entryId: number;
    groupByEntryType?: boolean;
    fields?: string[];
    formatFields?: boolean;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;

  GetFieldValuesForEach(args: {
    callback: (response: ODataValueContextOfIListOfFieldValue) => Promise<boolean>;
    repoId: string;
    entryId: number;
    prefer?: string;
    formatValue?: boolean;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;

  GetLinkValuesFromEntryForEach(args: {
    callback: (response: ODataValueContextOfIListOfWEntryLinkInfo) => Promise<boolean>;
    repoId: string;
    entryId: number;
    prefer?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;

  GetTagsAssignedToEntryForEach(args: {
    callback: (response: ODataValueContextOfIListOfWTagInfo) => Promise<boolean>;
    repoId: string;
    entryId: number;
    prefer?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;

  getEntryListingNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfEntry>;
  getFieldValuesNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfFieldValue>;
  getLinkValuesFromEntryNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfWEntryLinkInfo>;
  getTagsAssignedToEntryNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfWTagInfo>;
}

export interface IFieldDefinitionsClient {
  GetFieldDefinitionsForEach(args: {
    callback: (response: ODataValueContextOfIListOfWFieldInfo) => Promise<boolean>;
    repoId: string;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;
  getFieldDefinitionsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfEntry>;
}

export interface ISearchesClient {
  GetSearchResultsForEach(args: {
    callback: (response: ODataValueContextOfIListOfEntry) => Promise<boolean>;
    repoId: string;
    searchToken: string;
    groupByEntryType?: boolean;
    refresh?: boolean;
    fields?: string[];
    formatFields?: boolean;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;
  GetSearchContextHitsForEach(args: {
    callback: (response: ODataValueContextOfIListOfContextHit) => Promise<boolean>;
    repoId: string;
    searchToken: string;
    rowNumber: number;
    prefer?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;
  GetSearchResultsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfEntry>;
  GetSearchContextHitsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfContextHit>;
}

export interface ITagDefinitionsClient {
  GetTagDefinitionsForEach(args: {
    callback: (response: ODataValueContextOfIListOfWTagInfo) => Promise<boolean>;
    repoId: string;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;
  getTagDefinitionsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfWTagInfo>;
}

export interface ITemplateDefinitionsClient {
  GetTemplateDefinitionsForEach(args: {
    callback: (response: ODataValueContextOfIListOfWTemplateInfo) => Promise<boolean>;
    repoId: string;
    templateName?: string;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;
  GetTemplateFieldDefinitionsForEach(args: {
    callback: (response: ODataValueContextOfIListOfTemplateFieldInfo) => Promise<boolean>;
    repoId: string;
    templateId: number;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;
  GetTemplateFieldDefinitionsByTemplateNameForEach(args: {
    callback: (response: ODataValueContextOfIListOfTemplateFieldInfo) => Promise<boolean>;
    repoId: string;
    templateName: string;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;
  getTemplateDefinitionsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfWTemplateInfo>;
  getTemplateFieldDefinitionsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfTemplateFieldInfo>;
  getTemplateFieldDefinitionsByTemplateNameNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfTemplateFieldInfo>;
}