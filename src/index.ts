//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.0.0 (NJsonSchema v10.7.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { UrlUtils, StringUtils } from '@laserfiche/lf-js-utils';
import {
  UsernamePasswordHandler,
  OAuthClientCredentialsHandler,
  HttpRequestHandler,
  DomainUtils,
  AccessKey,
  ApiException as ApiExceptionCore
} from '@laserfiche/lf-api-client-core';

export interface IEntriesClient {

    /**
     * Creates a new document in the specified folder with file (no more than 100 MB). Optionally sets metadata and electronic document component. Optional parameter: autoRename (default false). If an entry already exists with the given name, the entry will be automatically renamed. With this route, partial success is possible. The response returns multiple operation (entryCreate operation, setEdoc operation, setLinks operation, etc..) objects, which contain information about any errors that may have occurred during the creation. As long as the entryCreate operation succeeds, the entry will be created, even if all other operations fail.
     * @param args.repoId The requested repository ID.
     * @param args.parentEntryId The entry ID of the folder that the document will be created in.
     * @param args.fileName The created document's file name.
     * @param args.autoRename (optional) An optional query parameter used to indicate if the new document should be automatically
                renamed if an entry already exists with the given name in the folder. The default value is false.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used.
                The value should be a standard language tag. This may be used when setting field values with tokens.
     * @param args.electronicDocument (optional) 
     * @param args.request (optional) 
     * @return Document creation is success.
     */
    importDocument(args: { repoId: string, parentEntryId: number, fileName: string, autoRename?: boolean | undefined, culture?: string | null | undefined, electronicDocument?: FileParameter | undefined, request?: PostEntryWithEdocMetadataRequest | undefined }): Promise<CreateEntryResult>;

    /**
     * Returns a single entry object. Provide an entry ID, and get the entry associated with that ID. Useful when detailed information about the entry is required, such as metadata, path information, etc. Allowed OData query options: Select. If the entry is a subtype (Folder, Document, or Shortcut), the entry will automatically be converted to include those model-specific properties.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The requested entry ID.
     * @param args.select (optional) Limits the properties returned in the result.
     * @return Get entry successfully.
     */
    getEntry(args: { repoId: string, entryId: number, select?: string | null | undefined }): Promise<Entry>;

    /**
     * Begins a task to delete an entry, and returns an operationToken. Provide an entry ID, and queue a delete task to remove it from the repository (includes nested objects if the entry is a Folder type). The entry will not be deleted immediately. Optionally include an audit reason ID and comment in the JSON body. This route returns an operationToken, and will run as an asynchronous operation. Check the progress via the Tasks/{operationToken} route.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The requested entry ID.
     * @param args.request (optional) The submitted audit reason.
     * @return Delete entry operation start successfully.
     */
    deleteEntryInfo(args: { repoId: string, entryId: number, request?: DeleteEntryWithAuditReason | undefined }): Promise<AcceptedOperation>;

    /**
     * Moves and/or renames an entry. Move and/or rename an entry by passing in the new parent folder ID or name in the JSON body. Optional parameter: autoRename (default false). If an entry already exists with the given name, the entry will be automatically renamed.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The requested entry ID.
     * @param args.request (optional) The request containing the folder ID that the entry will be moved to and the new name
                the entry will be renamed to.
     * @param args.autoRename (optional) An optional query parameter used to indicate if the entry should be automatically
                renamed if another entry already exists with the same name in the folder. The default value is false.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used.
                The value should be a standard language tag.
     * @return Moves and/or renames an entry successfully.
     */
    moveOrRenameEntry(args: { repoId: string, entryId: number, request?: PatchEntryRequest | undefined, autoRename?: boolean | undefined, culture?: string | null | undefined }): Promise<Entry>;

    /**
     * Returns a single entry object using the entry path. Optional query parameter: fallbackToClosestAncestor. Use the fallbackToClosestAncestor query parameter to return the closest existing ancestor if the initial entry path is not found.
     * @param args.repoId The requested repository ID.
     * @param args.fullPath The requested entry path.
     * @param args.fallbackToClosestAncestor (optional) An optional query parameter used to indicate whether or not the closest ancestor in the path should be returned if the initial entry path is not found. The default value is false.
     * @return Get entry successfully.
     */
    getEntryByPath(args: { repoId: string, fullPath: string | null, fallbackToClosestAncestor?: boolean | undefined }): Promise<FindEntryResult>;

    /**
     * Returns the children entries of a folder in the repository. Provide an entry ID (must be a folder), and get a paged listing of entries in that folder. Used as a way of navigating through the repository. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer. OData $OrderBy syntax should follow: "PropertyName direction,PropertyName2 direction". Sort order can be either value "asc" or "desc". Optional query parameters: groupByOrderType (bool). This query parameter decides if results are returned in groups based on their entry type. Entries returned in the listing are not automatically converted to their subtype (Folder, Shortcut, Document), so clients who want model-specific information should request it via the GET entry by ID route. Optionally returns field values for the entries in the folder. Each field name needs to be specified in the request. Maximum limit of 10 field names. If field values are requested, only the first value is returned if it is a multi value field. Null or Empty field values should not be used to determine if a field is assigned to the entry.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The folder ID.
     * @param args.groupByEntryType (optional) An optional query parameter used to indicate if the result should be grouped by entry type or not.
     * @param args.fields (optional) Optional array of field names. Field values corresponding to the given field names will be returned for each entry.
     * @param args.formatFields (optional) Boolean for if field values should be formatted. Only applicable if Fields are specified.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag. The formatFields query parameter must be set to true, otherwise
                culture will not be used for formatting.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get the children entries of a Folder successfully.
     */
    getEntryListing(args: { repoId: string, entryId: number, groupByEntryType?: boolean | undefined, fields?: string[] | null | undefined, formatFields?: boolean | undefined, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfEntry>;

    /**
     * Create/copy a new child entry in the designated folder. Provide the parent folder ID, and based on the request body, copy or create a folder/shortcut as a child entry of the designated folder. Optional parameter: autoRename (default false). If an entry already exists with the given name, the entry will be automatically renamed.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The folder ID that the entry will be created in.
     * @param args.request (optional) The entry to create.
     * @param args.autoRename (optional) An optional query parameter used to indicate if the new entry should be automatically
                renamed if an entry already exists with the given name in the folder. The default value is false.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used.
                The value should be a standard language tag.
     * @return Created a new child entry successfully.
     */
    createOrCopyEntry(args: { repoId: string, entryId: number, request?: PostEntryChildrenRequest | undefined, autoRename?: boolean | undefined, culture?: string | null | undefined }): Promise<Entry>;

    /**
     * Returns the fields assigned to an entry. Provide an entry ID, and get a paged listing of all fields assigned to that entry. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The requested entry ID.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.formatValue (optional) An optional query parameter used to indicate if the field values should be formatted.
                The default value is false.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag. The formatValue query parameter must be set to true, otherwise
                culture will not be used for formatting.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get field values successfully.
     */
    getFieldValues(args: { repoId: string, entryId: number, prefer?: string | null | undefined, formatValue?: boolean | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfFieldValue>;

    /**
     * Update the field values assigned to an entry. Provide the new field values to assign to the entry, and remove/reset all previously assigned field values.  This is an overwrite action. The request body must include all desired field values, including any existing field values that should remain assigned to the entry. Field values that are not included in the request will be deleted from the entry. If the field value that is not included is part of a template, it will still be assigned (as required by the template), but its value will be reset.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The entry ID of the entry that will have its fields updated.
     * @param args.fieldsToUpdate (optional) 
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used.
                The value should be a standard language tag. This may be used when setting field values with tokens.
     * @return Update field values successfully.
     */
    assignFieldValues(args: { repoId: string, entryId: number, fieldsToUpdate?: { [key: string]: FieldToUpdate; } | undefined, culture?: string | null | undefined }): Promise<ODataValueOfIListOfFieldValue>;

    /**
     * Returns the tags assigned to an entry. Provide an entry ID, and get a paged listing of tags assigned to that entry. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The requested entry ID.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get entry tags successfully.
     */
    getTagsAssignedToEntry(args: { repoId: string, entryId: number, prefer?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfWTagInfo>;

    /**
     * Assign tags to an entry. Provide an entry ID and a list of tags to assign to that entry. This is an overwrite action. The request must include all tags to assign to the entry, including existing tags that should remain assigned to the entry.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The requested entry ID.
     * @param args.tagsToAdd (optional) The tags to add.
     * @return Assign tags to an entry successfully.
     */
    assignTags(args: { repoId: string, entryId: number, tagsToAdd?: PutTagRequest | undefined }): Promise<ODataValueOfIListOfWTagInfo>;

    /**
     * Assign links to an entry. Provide an entry ID and a list of links to assign to that entry. This is an overwrite action. The request must include all links to assign to the entry, including existing links that should remain assigned to the entry.
     * @param args.repoId The request repository ID.
     * @param args.entryId The requested entry ID.
     * @param args.linksToAdd (optional) 
     * @return Assign links to an entry successfully.
     */
    assignEntryLinks(args: { repoId: string, entryId: number, linksToAdd?: PutLinksRequest[] | undefined }): Promise<ODataValueOfIListOfWEntryLinkInfo>;

    /**
     * Returns the links assigned to an entry. Provide an entry ID, and get a paged listing of links assigned to that entry. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The requested entry ID.
     * @param args.prefer (optional) An optional odata header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get links successfully.
     */
    getLinkValuesFromEntry(args: { repoId: string, entryId: number, prefer?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfWEntryLinkInfo>;

    /**
     * Copy a new child entry in the designated folder async, and potentially return an operationToken. Provide the parent folder ID, and copy an entry as a child of the designated folder. Optional parameter: autoRename (default false). If an entry already exists with the given name, the entry will be automatically renamed.  The status of the operation can be checked via the Tasks/{operationToken} route.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The folder ID that the entry will be created in.
     * @param args.request (optional) Copy entry request.
     * @param args.autoRename (optional) An optional query parameter used to indicate if the new entry should be automatically
                renamed if an entry already exists with the given name in the folder. The default value is false.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used.
                The value should be a standard language tag.
     * @return Copy entry operation is started successfully.
     */
    copyEntry(args: { repoId: string, entryId: number, request?: CopyAsyncRequest | undefined, autoRename?: boolean | undefined, culture?: string | null | undefined }): Promise<AcceptedOperation>;

    /**
     * Delete the edoc associated with the provided entry ID.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The requested document ID.
     * @return Deleted edoc successfully.
     */
    deleteDocument(args: { repoId: string, entryId: number }): Promise<ODataValueOfBoolean>;

    /**
     * Returns information about the edoc content of an entry, without downloading the edoc in its entirety. Provide an entry ID, and get back the Content-Type and Content-Length in the response headers. This route does not provide a way to download the actual edoc. Instead, it just gives metadata information about the edoc associated with the entry.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The requested document ID.
     * @return Get edoc info successfully.
     */
    getDocumentContentType(args: { repoId: string, entryId: number }): Promise<HttpResponseHead<void>>;

    /**
     * Returns an entry's edoc resource in a stream format. Provide an entry ID, and get the edoc resource as part of the response content. Optional header: Range. Use the Range header (single range with byte unit) to retrieve partial content of the edoc, rather than the entire edoc.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The requested document ID.
     * @param args.range (optional) An optional header used to retrieve partial content of the edoc. Only supports single
                range with byte unit.
     * @return Get edoc successfully.
     */
    exportDocument(args: { repoId: string, entryId: number, range?: string | null | undefined }): Promise<FileResponse>;

    /**
     * Delete the pages associated with the provided entry ID. If no pageRange is specified, all pages will be deleted. Optional parameter: pageRange (default empty). The value should be a comma-seperated string which contains non-overlapping single values, or page ranges. Ex: "1,2,3", "1-3,5", "2-7,10-12."
     * @param args.repoId The requested repository ID.
     * @param args.entryId The requested document ID.
     * @param args.pageRange (optional) The pages to be deleted.
     * @return Deleted pages successfully.
     */
    deletePages(args: { repoId: string, entryId: number, pageRange?: string | null | undefined }): Promise<ODataValueOfBoolean>;

    /**
     * Returns an entry's edoc resource in a stream format while including an audit reason. Provide an entry ID and audit reason/comment in the request body, and get the edoc resource as part of the response content. Optional header: Range. Use the Range header (single range with byte unit) to retrieve partial content of the edoc, rather than the entire edoc. This route is identical to the GET edoc route, but allows clients to include an audit reason when downloading the edoc.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The requested document ID.
     * @param args.request (optional) 
     * @param args.range (optional) An optional header used to retrieve partial content of the edoc. Only supports single
                range with byte unit.
     * @return Get edoc successfully.
     */
    exportDocumentWithAuditReason(args: { repoId: string, entryId: number, request?: GetEdocWithAuditReasonRequest | undefined, range?: string | null | undefined }): Promise<FileResponse>;

    /**
     * Returns dynamic field logic values with the current values of the fields in the template. Provide an entry ID and field values in the JSON body to get dynamic field logic values.  Independent and non-dynamic fields in the request body will be ignored, and only related dynamic field logic values for the assigned template will be returned.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The requested entry ID.
     * @param args.request (optional) 
     * @return Get dynamic field logic values successfully.
     */
    getDynamicFieldValues(args: { repoId: string, entryId: number, request?: GetDynamicFieldLogicValueRequest | undefined }): Promise<{ [key: string]: string[]; }>;

    /**
     * Remove the currently assigned template from the specified entry. Provide an entry ID to clear template value on. If the entry does not have a template assigned, no change will be made.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The ID of the entry that will have its template removed.
     * @return Remove the currently assigned template successfully.
     */
    deleteAssignedTemplate(args: { repoId: string, entryId: number }): Promise<Entry>;

    /**
     * Assign a template to an entry. Provide an entry ID, template name, and a list of template fields to assign to that entry. Only template values will be modified. Any existing independent fields on the entry will not be modified, nor will they be added if included in the request. The only modification to fields will only occur on templated fields. If the previously assigned template includes common template fields as the newly assigned template, the common field values will not be modified.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The ID of entry that will have its template updated.
     * @param args.request (optional) The template and template fields that will be assigned to the entry.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used.
                The value should be a standard language tag. This may be used when setting field values with tokens.
     * @return Assign a template successfully.
     */
    writeTemplateValueToEntry(args: { repoId: string, entryId: number, request?: PutTemplateRequest | undefined, culture?: string | null | undefined }): Promise<Entry>;
}

export class EntriesClient implements IEntriesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.laserfiche.com/repository";
    }

    
  /**
   * It will continue to make the same call to get a list of entry listings of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repoId The requested repository ID.
   * @param args.entryId The requested entry ID.
   * @param args.groupByEntryType (optional) An optional query parameter used to indicate if the result should be grouped by entry type or not.
   * @param args.fields (optional) Optional array of field names. Field values corresponding to the given field names will be returned for each entry.
   * @param args.formatFields (optional) Boolean for if field values should be formatted. Only applicable if Fields are specified.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
          The value should be a standard language tag. The formatFields query parameter must be set to true, otherwise
          culture will not be used for formatting. 
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of entry listings allowed per API response schema.
   */
  async getEntryListingForEach(args: {
    callback: (response: ODataValueContextOfIListOfEntry) => Promise<boolean>;
    repoId: string;
    entryId: number;
    groupByEntryType?: boolean;
    fields?: string[];
    formatFields?: boolean;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let {
      callback,
      repoId,
      entryId,
      groupByEntryType,
      fields,
      formatFields,
      prefer,
      culture,
      select,
      orderby,
      top,
      skip,
      count,
      maxPageSize,
    } = args;
    var response = await this.getEntryListing({
      repoId,
      entryId,
      groupByEntryType,
      fields,
      formatFields,
      prefer: createMaxPageSizePreferHeaderPayload(maxPageSize),
      culture,
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink) {
      response = await getNextLinkListing<ODataValueContextOfIListOfEntry>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processGetEntryListing,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }
  /**
   * It will continue to make the same call to get a list of field values of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repoId The requested repository ID.
   * @param args.entryId The requested entry ID.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.formatValue (optional) An optional query parameter used to indicate if the field values should be formatted.
          The default value is false. 
   * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
          The value should be a standard language tag. The formatFields query parameter must be set to true, otherwise
          culture will not be used for formatting. 
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of field values allowed per API response schema.
   */
  async getFieldValuesForEach(args: {
    callback: (response: ODataValueContextOfIListOfFieldValue) => Promise<boolean>;
    repoId: string;
    entryId: number;
    prefer?: string;
    formatValue?: boolean;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let { callback, repoId, entryId, prefer, formatValue, culture, select, orderby, top, skip, count, maxPageSize } =
      args;
    var response = await this.getFieldValues({
      repoId,
      entryId,
      prefer: createMaxPageSizePreferHeaderPayload(maxPageSize),
      formatValue,
      culture,
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink) {
      response = await getNextLinkListing<ODataValueContextOfIListOfFieldValue>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processGetFieldValues,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }
  /**
   * It will continue to make the same call to get a list of link values from entry of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repoId The requested repository ID.
   * @param args.entryId The requested entry ID.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of link values from entry allowed per API response schema.
   */
  async getLinkValuesFromEntryForEach(args: {
    callback: (response: ODataValueContextOfIListOfWEntryLinkInfo) => Promise<boolean>;
    repoId: string;
    entryId: number;
    prefer?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let { callback, repoId, entryId, prefer, select, orderby, top, skip, count, maxPageSize } = args;
    var response = await this.getLinkValuesFromEntry({
      repoId,
      entryId,
      prefer: createMaxPageSizePreferHeaderPayload(maxPageSize),
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink) {
      response = await getNextLinkListing<ODataValueContextOfIListOfWEntryLinkInfo>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processGetLinkValuesFromEntry,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }
  /**
   * It will continue to make the same call to get a list of tags assigned to entry of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repoId The requested repository ID.
   * @param args.entryId The requested entry ID.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of tags assigned to entry allowed per API response schema.
   */
  async getTagsAssignedToEntryForEach(args: {
    callback: (response: ODataValueContextOfIListOfWTagInfo) => Promise<boolean>;
    repoId: string;
    entryId: number;
    prefer?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let { callback, repoId, entryId, prefer, select, orderby, top, skip, count, maxPageSize } = args;
    var response = await this.getTagsAssignedToEntry({
      repoId,
      entryId,
      prefer: createMaxPageSizePreferHeaderPayload(maxPageSize),
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink) {
      response = await getNextLinkListing<ODataValueContextOfIListOfWTagInfo>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processGetTagsAssignedToEntry,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }
  /**
   * Returns the children entries of a folder in the repository using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of entry listings allowed per API response schema
   * @return Get the children entries of a Folder with the next link successfully
   */
  async getEntryListingNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfEntry> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<ODataValueContextOfIListOfEntry>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processGetEntryListing,
      nextLink,
      maxPageSize
    );
  }
  /**
   * Returns the fields assigned to an entry using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of field values allowed per API response schema
   * @return Get field values with the next link successfully
   */
  async getFieldValuesNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfFieldValue> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<ODataValueContextOfIListOfFieldValue>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processGetFieldValues,
      nextLink,
      maxPageSize
    );
  }
  /**
   * Returns the links assigned to an entry using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of link values from entry allowed per API response schema
   * @return Get links with the next link successfully
   */
  async getLinkValuesFromEntryNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfWEntryLinkInfo> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<ODataValueContextOfIListOfWEntryLinkInfo>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processGetLinkValuesFromEntry,
      nextLink,
      maxPageSize
    );
  }
  /**
   * Returns the entry tags assigned to an entry using a link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of tags assigned to entry allowed per API response schema
   * @return Get entry tags with the next link successfully
   */
  async getTagsAssignedToEntryNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfWTagInfo> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<ODataValueContextOfIListOfWEntryLinkInfo>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processGetTagsAssignedToEntry,
      nextLink,
      maxPageSize
    );
  }

    /**
     * Creates a new document in the specified folder with file (no more than 100 MB). Optionally sets metadata and electronic document component. Optional parameter: autoRename (default false). If an entry already exists with the given name, the entry will be automatically renamed. With this route, partial success is possible. The response returns multiple operation (entryCreate operation, setEdoc operation, setLinks operation, etc..) objects, which contain information about any errors that may have occurred during the creation. As long as the entryCreate operation succeeds, the entry will be created, even if all other operations fail.
     * @param args.repoId The requested repository ID.
     * @param args.parentEntryId The entry ID of the folder that the document will be created in.
     * @param args.fileName The created document's file name.
     * @param args.autoRename (optional) An optional query parameter used to indicate if the new document should be automatically
                renamed if an entry already exists with the given name in the folder. The default value is false.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used.
                The value should be a standard language tag. This may be used when setting field values with tokens.
     * @param args.electronicDocument (optional) 
     * @param args.request (optional) 
     * @return Document creation is success.
     */
    importDocument(args: { repoId: string, parentEntryId: number, fileName: string, autoRename?: boolean | undefined, culture?: string | null | undefined, electronicDocument?: FileParameter | undefined, request?: PostEntryWithEdocMetadataRequest | undefined }): Promise<CreateEntryResult> {
        let { repoId, parentEntryId, fileName, autoRename, culture, electronicDocument, request } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{parentEntryId}/{fileName}?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (parentEntryId === undefined || parentEntryId === null)
            throw new Error("The parameter 'parentEntryId' must be defined.");
        url_ = url_.replace("{parentEntryId}", encodeURIComponent("" + parentEntryId));
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        if (autoRename === null)
            throw new Error("The parameter 'autoRename' cannot be null.");
        else if (autoRename !== undefined)
            url_ += "autoRename=" + encodeURIComponent("" + autoRename) + "&";
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (electronicDocument === null || electronicDocument === undefined)
            throw new Error("The parameter 'electronicDocument' cannot be null.");
        else
            content_.append("electronicDocument", electronicDocument.data, electronicDocument.fileName ? electronicDocument.fileName : "electronicDocument");
        if (request === null || request === undefined)
            throw new Error("The parameter 'request' cannot be null.");
        else
            content_.append("request", JSON.stringify(request));

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processImportDocument(_response);
        });
    }

    protected processImportDocument(response: Response): Promise<CreateEntryResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = CreateEntryResult.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = CreateEntryResult.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = CreateEntryResult.fromJS(resultData404);
            return throwException("Parent entry is not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = CreateEntryResult.fromJS(resultData409);
            return throwException("Document creation is partial success.", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = CreateEntryResult.fromJS(resultData500);
            return throwException("Document creation is complete failure.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreateEntryResult>(null as any);
    }

    /**
     * Returns a single entry object. Provide an entry ID, and get the entry associated with that ID. Useful when detailed information about the entry is required, such as metadata, path information, etc. Allowed OData query options: Select. If the entry is a subtype (Folder, Document, or Shortcut), the entry will automatically be converted to include those model-specific properties.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The requested entry ID.
     * @param args.select (optional) Limits the properties returned in the result.
     * @return Get entry successfully.
     */
    getEntry(args: { repoId: string, entryId: number, select?: string | null | undefined }): Promise<Entry> {
        let { repoId, entryId, select } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntry(_response);
        });
    }

    protected processGetEntry(response: Response): Promise<Entry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Entry.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Requested entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry>(null as any);
    }

    /**
     * Begins a task to delete an entry, and returns an operationToken. Provide an entry ID, and queue a delete task to remove it from the repository (includes nested objects if the entry is a Folder type). The entry will not be deleted immediately. Optionally include an audit reason ID and comment in the JSON body. This route returns an operationToken, and will run as an asynchronous operation. Check the progress via the Tasks/{operationToken} route.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The requested entry ID.
     * @param args.request (optional) The submitted audit reason.
     * @return Delete entry operation start successfully.
     */
    deleteEntryInfo(args: { repoId: string, entryId: number, request?: DeleteEntryWithAuditReason | undefined }): Promise<AcceptedOperation> {
        let { repoId, entryId, request } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteEntryInfo(_response);
        });
    }

    protected processDeleteEntryInfo(response: Response): Promise<AcceptedOperation> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = AcceptedOperation.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Operation limit or request limit reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AcceptedOperation>(null as any);
    }

    /**
     * Moves and/or renames an entry. Move and/or rename an entry by passing in the new parent folder ID or name in the JSON body. Optional parameter: autoRename (default false). If an entry already exists with the given name, the entry will be automatically renamed.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The requested entry ID.
     * @param args.request (optional) The request containing the folder ID that the entry will be moved to and the new name
                the entry will be renamed to.
     * @param args.autoRename (optional) An optional query parameter used to indicate if the entry should be automatically
                renamed if another entry already exists with the same name in the folder. The default value is false.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used.
                The value should be a standard language tag.
     * @return Moves and/or renames an entry successfully.
     */
    moveOrRenameEntry(args: { repoId: string, entryId: number, request?: PatchEntryRequest | undefined, autoRename?: boolean | undefined, culture?: string | null | undefined }): Promise<Entry> {
        let { repoId, entryId, request, autoRename, culture } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (autoRename === null)
            throw new Error("The parameter 'autoRename' cannot be null.");
        else if (autoRename !== undefined)
            url_ += "autoRename=" + encodeURIComponent("" + autoRename) + "&";
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMoveOrRenameEntry(_response);
        });
    }

    protected processMoveOrRenameEntry(response: Response): Promise<Entry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Entry.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Entry name conflicts.", status, _responseText, _headers, result409);
            });
        } else if (status === 423) {
            return response.text().then((_responseText) => {
            let result423: any = null;
            let resultData423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result423 = ProblemDetails.fromJS(resultData423);
            return throwException("Entry is locked.", status, _responseText, _headers, result423);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry>(null as any);
    }

    /**
     * Returns a single entry object using the entry path. Optional query parameter: fallbackToClosestAncestor. Use the fallbackToClosestAncestor query parameter to return the closest existing ancestor if the initial entry path is not found.
     * @param args.repoId The requested repository ID.
     * @param args.fullPath The requested entry path.
     * @param args.fallbackToClosestAncestor (optional) An optional query parameter used to indicate whether or not the closest ancestor in the path should be returned if the initial entry path is not found. The default value is false.
     * @return Get entry successfully.
     */
    getEntryByPath(args: { repoId: string, fullPath: string | null, fallbackToClosestAncestor?: boolean | undefined }): Promise<FindEntryResult> {
        let { repoId, fullPath, fallbackToClosestAncestor } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/ByPath?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (fullPath === undefined)
            throw new Error("The parameter 'fullPath' must be defined.");
        else if(fullPath !== null)
            url_ += "fullPath=" + encodeURIComponent("" + fullPath) + "&";
        if (fallbackToClosestAncestor === null)
            throw new Error("The parameter 'fallbackToClosestAncestor' cannot be null.");
        else if (fallbackToClosestAncestor !== undefined)
            url_ += "fallbackToClosestAncestor=" + encodeURIComponent("" + fallbackToClosestAncestor) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntryByPath(_response);
        });
    }

    protected processGetEntryByPath(response: Response): Promise<FindEntryResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FindEntryResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Requested entry path not found", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FindEntryResult>(null as any);
    }

    /**
     * Returns the children entries of a folder in the repository. Provide an entry ID (must be a folder), and get a paged listing of entries in that folder. Used as a way of navigating through the repository. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer. OData $OrderBy syntax should follow: "PropertyName direction,PropertyName2 direction". Sort order can be either value "asc" or "desc". Optional query parameters: groupByOrderType (bool). This query parameter decides if results are returned in groups based on their entry type. Entries returned in the listing are not automatically converted to their subtype (Folder, Shortcut, Document), so clients who want model-specific information should request it via the GET entry by ID route. Optionally returns field values for the entries in the folder. Each field name needs to be specified in the request. Maximum limit of 10 field names. If field values are requested, only the first value is returned if it is a multi value field. Null or Empty field values should not be used to determine if a field is assigned to the entry.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The folder ID.
     * @param args.groupByEntryType (optional) An optional query parameter used to indicate if the result should be grouped by entry type or not.
     * @param args.fields (optional) Optional array of field names. Field values corresponding to the given field names will be returned for each entry.
     * @param args.formatFields (optional) Boolean for if field values should be formatted. Only applicable if Fields are specified.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag. The formatFields query parameter must be set to true, otherwise
                culture will not be used for formatting.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get the children entries of a Folder successfully.
     */
    getEntryListing(args: { repoId: string, entryId: number, groupByEntryType?: boolean | undefined, fields?: string[] | null | undefined, formatFields?: boolean | undefined, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfEntry> {
        let { repoId, entryId, groupByEntryType, fields, formatFields, prefer, culture, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}/Laserfiche.Repository.Folder/children?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (groupByEntryType === null)
            throw new Error("The parameter 'groupByEntryType' cannot be null.");
        else if (groupByEntryType !== undefined)
            url_ += "groupByEntryType=" + encodeURIComponent("" + groupByEntryType) + "&";
        if (fields !== undefined && fields !== null)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (formatFields === null)
            throw new Error("The parameter 'formatFields' cannot be null.");
        else if (formatFields !== undefined)
            url_ += "formatFields=" + encodeURIComponent("" + formatFields) + "&";
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        if (prefer !== null && prefer !== undefined)
            options_.headers = Object.assign({}, options_.headers, {"Prefer": prefer !== undefined && prefer !== null ? "" + prefer : null});

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEntryListing(_response);
        });
    }

    protected processGetEntryListing(response: Response): Promise<ODataValueContextOfIListOfEntry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueContextOfIListOfEntry.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueContextOfIListOfEntry>(null as any);
    }

    /**
     * Create/copy a new child entry in the designated folder. Provide the parent folder ID, and based on the request body, copy or create a folder/shortcut as a child entry of the designated folder. Optional parameter: autoRename (default false). If an entry already exists with the given name, the entry will be automatically renamed.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The folder ID that the entry will be created in.
     * @param args.request (optional) The entry to create.
     * @param args.autoRename (optional) An optional query parameter used to indicate if the new entry should be automatically
                renamed if an entry already exists with the given name in the folder. The default value is false.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used.
                The value should be a standard language tag.
     * @return Created a new child entry successfully.
     */
    createOrCopyEntry(args: { repoId: string, entryId: number, request?: PostEntryChildrenRequest | undefined, autoRename?: boolean | undefined, culture?: string | null | undefined }): Promise<Entry> {
        let { repoId, entryId, request, autoRename, culture } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}/Laserfiche.Repository.Folder/children?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (autoRename === null)
            throw new Error("The parameter 'autoRename' cannot be null.");
        else if (autoRename !== undefined)
            url_ += "autoRename=" + encodeURIComponent("" + autoRename) + "&";
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateOrCopyEntry(_response);
        });
    }

    protected processCreateOrCopyEntry(response: Response): Promise<Entry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Entry.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Entry name conflicts.", status, _responseText, _headers, result409);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry>(null as any);
    }

    /**
     * Returns the fields assigned to an entry. Provide an entry ID, and get a paged listing of all fields assigned to that entry. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The requested entry ID.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.formatValue (optional) An optional query parameter used to indicate if the field values should be formatted.
                The default value is false.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag. The formatValue query parameter must be set to true, otherwise
                culture will not be used for formatting.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get field values successfully.
     */
    getFieldValues(args: { repoId: string, entryId: number, prefer?: string | null | undefined, formatValue?: boolean | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfFieldValue> {
        let { repoId, entryId, prefer, formatValue, culture, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}/fields?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (formatValue === null)
            throw new Error("The parameter 'formatValue' cannot be null.");
        else if (formatValue !== undefined)
            url_ += "formatValue=" + encodeURIComponent("" + formatValue) + "&";
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        if (prefer !== null && prefer !== undefined)
            options_.headers = Object.assign({}, options_.headers, {"Prefer": prefer !== undefined && prefer !== null ? "" + prefer : null});

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFieldValues(_response);
        });
    }

    protected processGetFieldValues(response: Response): Promise<ODataValueContextOfIListOfFieldValue> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueContextOfIListOfFieldValue.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueContextOfIListOfFieldValue>(null as any);
    }

    /**
     * Update the field values assigned to an entry. Provide the new field values to assign to the entry, and remove/reset all previously assigned field values.  This is an overwrite action. The request body must include all desired field values, including any existing field values that should remain assigned to the entry. Field values that are not included in the request will be deleted from the entry. If the field value that is not included is part of a template, it will still be assigned (as required by the template), but its value will be reset.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The entry ID of the entry that will have its fields updated.
     * @param args.fieldsToUpdate (optional) 
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used.
                The value should be a standard language tag. This may be used when setting field values with tokens.
     * @return Update field values successfully.
     */
    assignFieldValues(args: { repoId: string, entryId: number, fieldsToUpdate?: { [key: string]: FieldToUpdate; } | undefined, culture?: string | null | undefined }): Promise<ODataValueOfIListOfFieldValue> {
        let { repoId, entryId, fieldsToUpdate, culture } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}/fields?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(fieldsToUpdate);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAssignFieldValues(_response);
        });
    }

    protected processAssignFieldValues(response: Response): Promise<ODataValueOfIListOfFieldValue> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueOfIListOfFieldValue.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Requested entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 423) {
            return response.text().then((_responseText) => {
            let result423: any = null;
            let resultData423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result423 = ProblemDetails.fromJS(resultData423);
            return throwException("Entry is locked.", status, _responseText, _headers, result423);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueOfIListOfFieldValue>(null as any);
    }

    /**
     * Returns the tags assigned to an entry. Provide an entry ID, and get a paged listing of tags assigned to that entry. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The requested entry ID.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get entry tags successfully.
     */
    getTagsAssignedToEntry(args: { repoId: string, entryId: number, prefer?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfWTagInfo> {
        let { repoId, entryId, prefer, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}/tags?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        if (prefer !== null && prefer !== undefined)
            options_.headers = Object.assign({}, options_.headers, {"Prefer": prefer !== undefined && prefer !== null ? "" + prefer : null});

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTagsAssignedToEntry(_response);
        });
    }

    protected processGetTagsAssignedToEntry(response: Response): Promise<ODataValueContextOfIListOfWTagInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueContextOfIListOfWTagInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueContextOfIListOfWTagInfo>(null as any);
    }

    /**
     * Assign tags to an entry. Provide an entry ID and a list of tags to assign to that entry. This is an overwrite action. The request must include all tags to assign to the entry, including existing tags that should remain assigned to the entry.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The requested entry ID.
     * @param args.tagsToAdd (optional) The tags to add.
     * @return Assign tags to an entry successfully.
     */
    assignTags(args: { repoId: string, entryId: number, tagsToAdd?: PutTagRequest | undefined }): Promise<ODataValueOfIListOfWTagInfo> {
        let { repoId, entryId, tagsToAdd } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}/tags";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tagsToAdd);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAssignTags(_response);
        });
    }

    protected processAssignTags(response: Response): Promise<ODataValueOfIListOfWTagInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueOfIListOfWTagInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 423) {
            return response.text().then((_responseText) => {
            let result423: any = null;
            let resultData423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result423 = ProblemDetails.fromJS(resultData423);
            return throwException("Entry is locked.", status, _responseText, _headers, result423);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueOfIListOfWTagInfo>(null as any);
    }

    /**
     * Assign links to an entry. Provide an entry ID and a list of links to assign to that entry. This is an overwrite action. The request must include all links to assign to the entry, including existing links that should remain assigned to the entry.
     * @param args.repoId The request repository ID.
     * @param args.entryId The requested entry ID.
     * @param args.linksToAdd (optional) 
     * @return Assign links to an entry successfully.
     */
    assignEntryLinks(args: { repoId: string, entryId: number, linksToAdd?: PutLinksRequest[] | undefined }): Promise<ODataValueOfIListOfWEntryLinkInfo> {
        let { repoId, entryId, linksToAdd } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}/links";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(linksToAdd);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAssignEntryLinks(_response);
        });
    }

    protected processAssignEntryLinks(response: Response): Promise<ODataValueOfIListOfWEntryLinkInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueOfIListOfWEntryLinkInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 423) {
            return response.text().then((_responseText) => {
            let result423: any = null;
            let resultData423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result423 = ProblemDetails.fromJS(resultData423);
            return throwException("Entry is locked.", status, _responseText, _headers, result423);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueOfIListOfWEntryLinkInfo>(null as any);
    }

    /**
     * Returns the links assigned to an entry. Provide an entry ID, and get a paged listing of links assigned to that entry. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The requested entry ID.
     * @param args.prefer (optional) An optional odata header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get links successfully.
     */
    getLinkValuesFromEntry(args: { repoId: string, entryId: number, prefer?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfWEntryLinkInfo> {
        let { repoId, entryId, prefer, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}/links?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        if (prefer !== null && prefer !== undefined)
            options_.headers = Object.assign({}, options_.headers, {"Prefer": prefer !== undefined && prefer !== null ? "" + prefer : null});

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLinkValuesFromEntry(_response);
        });
    }

    protected processGetLinkValuesFromEntry(response: Response): Promise<ODataValueContextOfIListOfWEntryLinkInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueContextOfIListOfWEntryLinkInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueContextOfIListOfWEntryLinkInfo>(null as any);
    }

    /**
     * Copy a new child entry in the designated folder async, and potentially return an operationToken. Provide the parent folder ID, and copy an entry as a child of the designated folder. Optional parameter: autoRename (default false). If an entry already exists with the given name, the entry will be automatically renamed.  The status of the operation can be checked via the Tasks/{operationToken} route.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The folder ID that the entry will be created in.
     * @param args.request (optional) Copy entry request.
     * @param args.autoRename (optional) An optional query parameter used to indicate if the new entry should be automatically
                renamed if an entry already exists with the given name in the folder. The default value is false.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used.
                The value should be a standard language tag.
     * @return Copy entry operation is started successfully.
     */
    copyEntry(args: { repoId: string, entryId: number, request?: CopyAsyncRequest | undefined, autoRename?: boolean | undefined, culture?: string | null | undefined }): Promise<AcceptedOperation> {
        let { repoId, entryId, request, autoRename, culture } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}/Laserfiche.Repository.Folder/CopyAsync?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (autoRename === null)
            throw new Error("The parameter 'autoRename' cannot be null.");
        else if (autoRename !== undefined)
            url_ += "autoRename=" + encodeURIComponent("" + autoRename) + "&";
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCopyEntry(_response);
        });
    }

    protected processCopyEntry(response: Response): Promise<AcceptedOperation> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = AcceptedOperation.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Operation limit or request limit reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AcceptedOperation>(null as any);
    }

    /**
     * Delete the edoc associated with the provided entry ID.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The requested document ID.
     * @return Deleted edoc successfully.
     */
    deleteDocument(args: { repoId: string, entryId: number }): Promise<ODataValueOfBoolean> {
        let { repoId, entryId } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}/Laserfiche.Repository.Document/edoc";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDocument(_response);
        });
    }

    protected processDeleteDocument(response: Response): Promise<ODataValueOfBoolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueOfBoolean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 423) {
            return response.text().then((_responseText) => {
            let result423: any = null;
            let resultData423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result423 = ProblemDetails.fromJS(resultData423);
            return throwException("Entry is locked.", status, _responseText, _headers, result423);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueOfBoolean>(null as any);
    }

    /**
     * Returns information about the edoc content of an entry, without downloading the edoc in its entirety. Provide an entry ID, and get back the Content-Type and Content-Length in the response headers. This route does not provide a way to download the actual edoc. Instead, it just gives metadata information about the edoc associated with the entry.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The requested document ID.
     * @return Get edoc info successfully.
     */
    getDocumentContentType(args: { repoId: string, entryId: number }): Promise<HttpResponseHead<void>> {
        let { repoId, entryId } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}/Laserfiche.Repository.Document/edoc";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "HEAD",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDocumentContentType(_response);
        });
    }

    protected processGetDocumentContentType(response: Response): Promise<HttpResponseHead<void>> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return new HttpResponseHead(status, _headers, null as any);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid or bad request.", status, _responseText, _headers);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            return throwException("Access token is invalid or expired.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("Access denied for the operation.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Request entry id not found.", status, _responseText, _headers);
            });
        } else if (status === 423) {
            return response.text().then((_responseText) => {
            return throwException("Entry is locked.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            return throwException("Rate limit is reached.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HttpResponseHead<void>>(new HttpResponseHead(status, _headers, null as any));
    }

    /**
     * Returns an entry's edoc resource in a stream format. Provide an entry ID, and get the edoc resource as part of the response content. Optional header: Range. Use the Range header (single range with byte unit) to retrieve partial content of the edoc, rather than the entire edoc.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The requested document ID.
     * @param args.range (optional) An optional header used to retrieve partial content of the edoc. Only supports single
                range with byte unit.
     * @return Get edoc successfully.
     */
    exportDocument(args: { repoId: string, entryId: number, range?: string | null | undefined }): Promise<FileResponse> {
        let { repoId, entryId, range } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}/Laserfiche.Repository.Document/edoc";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        if (range !== null && range !== undefined)
            options_.headers = Object.assign({}, options_.headers, {"Range": range !== undefined && range !== null ? "" + range : null});

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExportDocument(_response);
        });
    }

    protected processExportDocument(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 423) {
            return response.text().then((_responseText) => {
            let result423: any = null;
            let resultData423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result423 = ProblemDetails.fromJS(resultData423);
            return throwException("Entry is locked.", status, _responseText, _headers, result423);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Delete the pages associated with the provided entry ID. If no pageRange is specified, all pages will be deleted. Optional parameter: pageRange (default empty). The value should be a comma-seperated string which contains non-overlapping single values, or page ranges. Ex: "1,2,3", "1-3,5", "2-7,10-12."
     * @param args.repoId The requested repository ID.
     * @param args.entryId The requested document ID.
     * @param args.pageRange (optional) The pages to be deleted.
     * @return Deleted pages successfully.
     */
    deletePages(args: { repoId: string, entryId: number, pageRange?: string | null | undefined }): Promise<ODataValueOfBoolean> {
        let { repoId, entryId, pageRange } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}/Laserfiche.Repository.Document/pages?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (pageRange !== undefined && pageRange !== null)
            url_ += "pageRange=" + encodeURIComponent("" + pageRange) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeletePages(_response);
        });
    }

    protected processDeletePages(response: Response): Promise<ODataValueOfBoolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueOfBoolean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 423) {
            return response.text().then((_responseText) => {
            let result423: any = null;
            let resultData423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result423 = ProblemDetails.fromJS(resultData423);
            return throwException("Entry is locked.", status, _responseText, _headers, result423);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueOfBoolean>(null as any);
    }

    /**
     * Returns an entry's edoc resource in a stream format while including an audit reason. Provide an entry ID and audit reason/comment in the request body, and get the edoc resource as part of the response content. Optional header: Range. Use the Range header (single range with byte unit) to retrieve partial content of the edoc, rather than the entire edoc. This route is identical to the GET edoc route, but allows clients to include an audit reason when downloading the edoc.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The requested document ID.
     * @param args.request (optional) 
     * @param args.range (optional) An optional header used to retrieve partial content of the edoc. Only supports single
                range with byte unit.
     * @return Get edoc successfully.
     */
    exportDocumentWithAuditReason(args: { repoId: string, entryId: number, request?: GetEdocWithAuditReasonRequest | undefined, range?: string | null | undefined }): Promise<FileResponse> {
        let { repoId, entryId, request, range } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}/Laserfiche.Repository.Document/GetEdocWithAuditReason";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        if (range !== null && range !== undefined)
            options_.headers = Object.assign({}, options_.headers, {"Range": range !== undefined && range !== null ? "" + range : null});

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExportDocumentWithAuditReason(_response);
        });
    }

    protected processExportDocumentWithAuditReason(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 423) {
            return response.text().then((_responseText) => {
            let result423: any = null;
            let resultData423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result423 = ProblemDetails.fromJS(resultData423);
            return throwException("Entry is locked.", status, _responseText, _headers, result423);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Returns dynamic field logic values with the current values of the fields in the template. Provide an entry ID and field values in the JSON body to get dynamic field logic values.  Independent and non-dynamic fields in the request body will be ignored, and only related dynamic field logic values for the assigned template will be returned.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The requested entry ID.
     * @param args.request (optional) 
     * @return Get dynamic field logic values successfully.
     */
    getDynamicFieldValues(args: { repoId: string, entryId: number, request?: GetDynamicFieldLogicValueRequest | undefined }): Promise<{ [key: string]: string[]; }> {
        let { repoId, entryId, request } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}/fields/GetDynamicFieldLogicValue";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDynamicFieldValues(_response);
        });
    }

    protected processGetDynamicFieldValues(response: Response): Promise<{ [key: string]: string[]; }> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : [];
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: string[]; }>(null as any);
    }

    /**
     * Remove the currently assigned template from the specified entry. Provide an entry ID to clear template value on. If the entry does not have a template assigned, no change will be made.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The ID of the entry that will have its template removed.
     * @return Remove the currently assigned template successfully.
     */
    deleteAssignedTemplate(args: { repoId: string, entryId: number }): Promise<Entry> {
        let { repoId, entryId } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}/template";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteAssignedTemplate(_response);
        });
    }

    protected processDeleteAssignedTemplate(response: Response): Promise<Entry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Entry.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 423) {
            return response.text().then((_responseText) => {
            let result423: any = null;
            let resultData423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result423 = ProblemDetails.fromJS(resultData423);
            return throwException("Entry is locked.", status, _responseText, _headers, result423);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry>(null as any);
    }

    /**
     * Assign a template to an entry. Provide an entry ID, template name, and a list of template fields to assign to that entry. Only template values will be modified. Any existing independent fields on the entry will not be modified, nor will they be added if included in the request. The only modification to fields will only occur on templated fields. If the previously assigned template includes common template fields as the newly assigned template, the common field values will not be modified.
     * @param args.repoId The requested repository ID.
     * @param args.entryId The ID of entry that will have its template updated.
     * @param args.request (optional) The template and template fields that will be assigned to the entry.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used.
                The value should be a standard language tag. This may be used when setting field values with tokens.
     * @return Assign a template successfully.
     */
    writeTemplateValueToEntry(args: { repoId: string, entryId: number, request?: PutTemplateRequest | undefined, culture?: string | null | undefined }): Promise<Entry> {
        let { repoId, entryId, request, culture } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Entries/{entryId}/template?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (entryId === undefined || entryId === null)
            throw new Error("The parameter 'entryId' must be defined.");
        url_ = url_.replace("{entryId}", encodeURIComponent("" + entryId));
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processWriteTemplateValueToEntry(_response);
        });
    }

    protected processWriteTemplateValueToEntry(response: Response): Promise<Entry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Entry.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request entry id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 423) {
            return response.text().then((_responseText) => {
            let result423: any = null;
            let resultData423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result423 = ProblemDetails.fromJS(resultData423);
            return throwException("Entry is locked.", status, _responseText, _headers, result423);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Entry>(null as any);
    }
}

export interface IAttributesClient {

    /**
     * Returns the attribute key value pairs associated with the authenticated user. Alternatively, return only the attribute key value pairs that are associated with the "Everyone" group. Attribute keys can be used with subsequent calls to get specific attribute values. Default page size: 100. Allowed OData query options: Select, Count, OrderBy, Skip, Top, SkipToken, Prefer. Optional query parameters: everyone (bool, default false). When true, this route does not return the attributes that are tied to the currently authenticated user, but rather the attributes assigned to the "Everyone" group. Note when this is true, the response does not include both the "Everyone" groups attribute and the currently authenticated user, but only the "Everyone" groups.
     * @param args.repoId The requested repository ID.
     * @param args.everyone (optional) Boolean value that indicates whether to return attributes key value pairs associated with everyone or the currently authenticated user.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get trustee attribute key value pairs successfully.
     */
    getTrusteeAttributeKeyValuePairs(args: { repoId: string, everyone?: boolean | undefined, prefer?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfListOfAttribute>;

    /**
     * Returns the attribute associated with the key. Alternatively, return the attribute associated with the key within "Everyone" group. Optional query parameters: everyone (bool, default false). When true, the server only searches for the attribute value with the given key upon the authenticated users attributes. If false, only the authenticated users attributes will be queried.
     * @param args.repoId The requested repository ID.
     * @param args.attributeKey The requested attribute key.
     * @param args.everyone (optional) Boolean value that indicates whether to return attributes associated with everyone or the currently authenticated user.
     * @return Get trustee attribute value successfully.
     */
    getTrusteeAttributeValueByKey(args: { repoId: string, attributeKey: string, everyone?: boolean | undefined }): Promise<Attribute>;
}

export class AttributesClient implements IAttributesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.laserfiche.com/repository";
    }

    
  /**
   * It will continue to make the same call to get a list of attributes key value pairs of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repoId The requested repository ID.
   * @param args.everyone (optional) Boolean value that indicates whether to return attributes key value pairs associated with everyone or the currently authenticated user.
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of attributes key value pairs allowed per API response schema
   */
  async getTrusteeAttributeKeyValuePairsForEach(args: {
    callback: (response: ODataValueContextOfListOfAttribute) => Promise<boolean>;
    repoId: string;
    everyone?: boolean;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let { callback, repoId, everyone, select, orderby, top, skip, count, maxPageSize } = args;
    var response = await this.getTrusteeAttributeKeyValuePairs({
      repoId,
      everyone,
      prefer: createMaxPageSizePreferHeaderPayload(maxPageSize),
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink) {
      response = await getNextLinkListing<ODataValueContextOfListOfAttribute>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processGetTrusteeAttributeKeyValuePairs,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }
  /**
   * Returns the attribute key value pairs using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection.
   * @param args.maxPageSize (optional) the maximum page size or number of attribute keys allowed per API response schema.
   * @return Get trustee attribute keys with the next link successfully
   */
  async getTrusteeAttributeKeyValuePairsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfListOfAttribute> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<ODataValueContextOfListOfAttribute>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processGetTrusteeAttributeKeyValuePairs,
      nextLink,
      maxPageSize
    );
  }

    /**
     * Returns the attribute key value pairs associated with the authenticated user. Alternatively, return only the attribute key value pairs that are associated with the "Everyone" group. Attribute keys can be used with subsequent calls to get specific attribute values. Default page size: 100. Allowed OData query options: Select, Count, OrderBy, Skip, Top, SkipToken, Prefer. Optional query parameters: everyone (bool, default false). When true, this route does not return the attributes that are tied to the currently authenticated user, but rather the attributes assigned to the "Everyone" group. Note when this is true, the response does not include both the "Everyone" groups attribute and the currently authenticated user, but only the "Everyone" groups.
     * @param args.repoId The requested repository ID.
     * @param args.everyone (optional) Boolean value that indicates whether to return attributes key value pairs associated with everyone or the currently authenticated user.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get trustee attribute key value pairs successfully.
     */
    getTrusteeAttributeKeyValuePairs(args: { repoId: string, everyone?: boolean | undefined, prefer?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfListOfAttribute> {
        let { repoId, everyone, prefer, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Attributes?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (everyone === null)
            throw new Error("The parameter 'everyone' cannot be null.");
        else if (everyone !== undefined)
            url_ += "everyone=" + encodeURIComponent("" + everyone) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        if (prefer !== null && prefer !== undefined)
            options_.headers = Object.assign({}, options_.headers, {"Prefer": prefer !== undefined && prefer !== null ? "" + prefer : null});

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTrusteeAttributeKeyValuePairs(_response);
        });
    }

    protected processGetTrusteeAttributeKeyValuePairs(response: Response): Promise<ODataValueContextOfListOfAttribute> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueContextOfListOfAttribute.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueContextOfListOfAttribute>(null as any);
    }

    /**
     * Returns the attribute associated with the key. Alternatively, return the attribute associated with the key within "Everyone" group. Optional query parameters: everyone (bool, default false). When true, the server only searches for the attribute value with the given key upon the authenticated users attributes. If false, only the authenticated users attributes will be queried.
     * @param args.repoId The requested repository ID.
     * @param args.attributeKey The requested attribute key.
     * @param args.everyone (optional) Boolean value that indicates whether to return attributes associated with everyone or the currently authenticated user.
     * @return Get trustee attribute value successfully.
     */
    getTrusteeAttributeValueByKey(args: { repoId: string, attributeKey: string, everyone?: boolean | undefined }): Promise<Attribute> {
        let { repoId, attributeKey, everyone } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Attributes/{attributeKey}?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (attributeKey === undefined || attributeKey === null)
            throw new Error("The parameter 'attributeKey' must be defined.");
        url_ = url_.replace("{attributeKey}", encodeURIComponent("" + attributeKey));
        if (everyone === null)
            throw new Error("The parameter 'everyone' cannot be null.");
        else if (everyone !== undefined)
            url_ += "everyone=" + encodeURIComponent("" + everyone) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTrusteeAttributeValueByKey(_response);
        });
    }

    protected processGetTrusteeAttributeValueByKey(response: Response): Promise<Attribute> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Attribute.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Requested attribute key not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Attribute>(null as any);
    }
}

export interface IFieldDefinitionsClient {

    /**
     * Returns a single field definition associated with the specified ID.  Useful when a route provides a minimal amount of details and more information about the specific field definition is needed. Allowed OData query options: Select
     * @param args.repoId The requested repository ID.
     * @param args.fieldDefinitionId The requested field definition ID.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag.
     * @param args.select (optional) Limits the properties returned in the result.
     * @return Get field definition successfully.
     */
    getFieldDefinitionById(args: { repoId: string, fieldDefinitionId: number, culture?: string | null | undefined, select?: string | null | undefined }): Promise<WFieldInfo>;

    /**
     * Returns a paged listing of field definitions available in the specified repository. Useful when trying to find a list of all field definitions available, rather than only those assigned to a specific entry/template. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param args.repoId The requested repository ID.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get field definitions successfully.
     */
    getFieldDefinitions(args: { repoId: string, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfWFieldInfo>;
}

export class FieldDefinitionsClient implements IFieldDefinitionsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.laserfiche.com/repository";
    }

    
  /**
   * It will continue to make the same call to get a list of field definitions of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repoId The requested repository ID.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
          The value should be a standard language tag. The formatFields query parameter must be set to true, otherwise
          culture will not be used for formatting.  
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of field definitions allowed per API response schema.
   */
  async getFieldDefinitionsForEach(args: {
    callback: (response: ODataValueContextOfIListOfWFieldInfo) => Promise<boolean>;
    repoId: string;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let { callback, repoId, prefer, culture, select, orderby, top, skip, count, maxPageSize } = args;
    var response = await this.getFieldDefinitions({
      repoId,
      prefer: createMaxPageSizePreferHeaderPayload(maxPageSize),
      culture,
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink) {
      response = await getNextLinkListing<ODataValueContextOfIListOfWFieldInfo>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processGetFieldDefinitions,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }
  /**
   * Returns a paged listing of field definitions available in the specified repository using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of field definitions allowed per API response schema
   * @return Get field definitions with the next link successfully
   */
  async getFieldDefinitionsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfWFieldInfo> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<ODataValueContextOfIListOfWFieldInfo>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processGetFieldDefinitions,
      nextLink,
      maxPageSize
    );
  }

    /**
     * Returns a single field definition associated with the specified ID.  Useful when a route provides a minimal amount of details and more information about the specific field definition is needed. Allowed OData query options: Select
     * @param args.repoId The requested repository ID.
     * @param args.fieldDefinitionId The requested field definition ID.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag.
     * @param args.select (optional) Limits the properties returned in the result.
     * @return Get field definition successfully.
     */
    getFieldDefinitionById(args: { repoId: string, fieldDefinitionId: number, culture?: string | null | undefined, select?: string | null | undefined }): Promise<WFieldInfo> {
        let { repoId, fieldDefinitionId, culture, select } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/FieldDefinitions/{fieldDefinitionId}?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (fieldDefinitionId === undefined || fieldDefinitionId === null)
            throw new Error("The parameter 'fieldDefinitionId' must be defined.");
        url_ = url_.replace("{fieldDefinitionId}", encodeURIComponent("" + fieldDefinitionId));
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFieldDefinitionById(_response);
        });
    }

    protected processGetFieldDefinitionById(response: Response): Promise<WFieldInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WFieldInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Requested field definition id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WFieldInfo>(null as any);
    }

    /**
     * Returns a paged listing of field definitions available in the specified repository. Useful when trying to find a list of all field definitions available, rather than only those assigned to a specific entry/template. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param args.repoId The requested repository ID.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get field definitions successfully.
     */
    getFieldDefinitions(args: { repoId: string, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfWFieldInfo> {
        let { repoId, prefer, culture, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/FieldDefinitions?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        if (prefer !== null && prefer !== undefined)
            options_.headers = Object.assign({}, options_.headers, {"Prefer": prefer !== undefined && prefer !== null ? "" + prefer : null});

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFieldDefinitions(_response);
        });
    }

    protected processGetFieldDefinitions(response: Response): Promise<ODataValueContextOfIListOfWFieldInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueContextOfIListOfWFieldInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueContextOfIListOfWFieldInfo>(null as any);
    }
}

export interface ILinkDefinitionsClient {

    /**
     * Returns the link definitions in the repository. Provide a repository ID and get a paged listing of link definitions available in the repository. Useful when trying to display all link definitions available, not only links assigned to a specific entry. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param args.repoId The requested repository ID.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get link definitions successfully.
     */
    getLinkDefinitions(args: { repoId: string, prefer?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfEntryLinkTypeInfo>;

    /**
     * Returns a single link definition associated with the specified ID. Provide a link type ID and get the associated link definition. Useful when a route provides a minimal amount of details and more information about the specific link definition is needed. Allowed OData query options: Select
     * @param args.repoId The requested repository ID.
     * @param args.linkTypeId The requested link type ID.
     * @param args.select (optional) Limits the properties returned in the result.
     * @return Get link definition successfully.
     */
    getLinkDefinitionById(args: { repoId: string, linkTypeId: number, select?: string | null | undefined }): Promise<EntryLinkTypeInfo>;
}

export class LinkDefinitionsClient implements ILinkDefinitionsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.laserfiche.com/repository";
    }

    
  /**
   * It will continue to make the same call to get a list of link definitions of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repoId The requested repository ID.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of link definitions allowed per API response schema.
   */
  async getLinkDefinitionsForEach(args: {
    callback: (response: ODataValueContextOfIListOfEntryLinkTypeInfo) => Promise<boolean>;
    repoId: string;
    prefer?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let { callback, repoId, prefer, select, orderby, top, skip, count, maxPageSize } = args;
    var response = await this.getLinkDefinitions({
      repoId,
      prefer: createMaxPageSizePreferHeaderPayload(maxPageSize),
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink) {
      response = await getNextLinkListing<ODataValueContextOfIListOfEntryLinkTypeInfo>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processGetLinkDefinitions,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }

  /**
   * Returns all link definitions in the repository using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of link definitions allowed per API response schema
   * @return Get link definitions with the next link successfully
   */
  async getLinkDefinitionsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfEntryLinkTypeInfo> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<ODataValueContextOfIListOfEntryLinkTypeInfo>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processGetLinkDefinitions,
      nextLink,
      maxPageSize
    );
  }

    /**
     * Returns the link definitions in the repository. Provide a repository ID and get a paged listing of link definitions available in the repository. Useful when trying to display all link definitions available, not only links assigned to a specific entry. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param args.repoId The requested repository ID.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get link definitions successfully.
     */
    getLinkDefinitions(args: { repoId: string, prefer?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfEntryLinkTypeInfo> {
        let { repoId, prefer, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/LinkDefinitions?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        if (prefer !== null && prefer !== undefined)
            options_.headers = Object.assign({}, options_.headers, {"Prefer": prefer !== undefined && prefer !== null ? "" + prefer : null});

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLinkDefinitions(_response);
        });
    }

    protected processGetLinkDefinitions(response: Response): Promise<ODataValueContextOfIListOfEntryLinkTypeInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueContextOfIListOfEntryLinkTypeInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueContextOfIListOfEntryLinkTypeInfo>(null as any);
    }

    /**
     * Returns a single link definition associated with the specified ID. Provide a link type ID and get the associated link definition. Useful when a route provides a minimal amount of details and more information about the specific link definition is needed. Allowed OData query options: Select
     * @param args.repoId The requested repository ID.
     * @param args.linkTypeId The requested link type ID.
     * @param args.select (optional) Limits the properties returned in the result.
     * @return Get link definition successfully.
     */
    getLinkDefinitionById(args: { repoId: string, linkTypeId: number, select?: string | null | undefined }): Promise<EntryLinkTypeInfo> {
        let { repoId, linkTypeId, select } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/LinkDefinitions/{linkTypeId}?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (linkTypeId === undefined || linkTypeId === null)
            throw new Error("The parameter 'linkTypeId' must be defined.");
        url_ = url_.replace("{linkTypeId}", encodeURIComponent("" + linkTypeId));
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLinkDefinitionById(_response);
        });
    }

    protected processGetLinkDefinitionById(response: Response): Promise<EntryLinkTypeInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntryLinkTypeInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Requested link type definition ID not found", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EntryLinkTypeInfo>(null as any);
    }
}

export interface IRepositoriesClient {

    /**
     * Returns the repository resource list that current user has access to.
     * @return Get the respository resource list successfully.
     */
    getRepositoryList(args: {  }): Promise<RepositoryInfo[]>;
}

export class RepositoriesClient implements IRepositoriesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.laserfiche.com/repository";
    }

    /**
     * Returns the repository resource list that current user has access to.
     * @return Get the respository resource list successfully.
     */
    getRepositoryList(args: {  }): Promise<RepositoryInfo[]> {
        let {  } = args;
        let url_ = this.baseUrl + "/v1/Repositories";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRepositoryList(_response);
        });
    }

    protected processGetRepositoryList(response: Response): Promise<RepositoryInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RepositoryInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RepositoryInfo[]>(null as any);
    }
}

export interface IAuditReasonsClient {

    /**
     * Returns the audit reasons associated with the authenticated user. Inherited audit reasons are included. Only includes audit reasons associated with available API functionalities, like delete entry and export document. If the authenticated user does not have the appropriate Laserfiche feature right, the audit reasons associated with that feature right will not be included.
     * @param args.repoId The requested repository ID.
     * @return Get audit reasons successfully.
     */
    getAuditReasons(args: { repoId: string }): Promise<AuditReasons>;
}

export class AuditReasonsClient implements IAuditReasonsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.laserfiche.com/repository";
    }

    /**
     * Returns the audit reasons associated with the authenticated user. Inherited audit reasons are included. Only includes audit reasons associated with available API functionalities, like delete entry and export document. If the authenticated user does not have the appropriate Laserfiche feature right, the audit reasons associated with that feature right will not be included.
     * @param args.repoId The requested repository ID.
     * @return Get audit reasons successfully.
     */
    getAuditReasons(args: { repoId: string }): Promise<AuditReasons> {
        let { repoId } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/AuditReasons";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAuditReasons(_response);
        });
    }

    protected processGetAuditReasons(response: Response): Promise<AuditReasons> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuditReasons.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuditReasons>(null as any);
    }
}

export interface ISearchesClient {

    /**
     * Runs a search operation on the repository. Optional body parameters: FuzzyType: (default none), which can be used to determine what is considered a match by number of letters or percentage. FuzzyFactor: integer value that determines the degree to which a search will be considered a match (integer value for NumberOfLetters, or int value representing a percentage). The status for search operations must be checked via the Search specific status checking route.
     * @param args.repoId The requested repository ID.
     * @param args.request (optional) The Laserfiche search command to run, optionally include fuzzy search settings.
     * @return Search operation start successfully.
     */
    createSearchOperation(args: { repoId: string, request?: AdvancedSearchRequest | undefined }): Promise<AcceptedOperation>;

    /**
     * Returns search status. Provide a token (returned in the create search asynchronous route), and get the search status, progress, and any errors that may have occurred. When the search is completed, the Location header can be inspected as a link to the search results. OperationStatus can be one of the following : NotStarted, InProgress, Completed, Failed, or Canceled.
     * @param args.repoId The requested repository ID.
     * @param args.searchToken The requested searchToken.
     * @return Search has failed. Check the errors property to find out why.
     */
    getSearchStatus(args: { repoId: string, searchToken: string }): Promise<OperationProgress>;

    /**
     * Cancels a currently running search. Closes a completed search.
     * @param args.repoId The requested repository ID.
     * @param args.searchToken The requested searchToken.
     * @return Cancel or closed search successfully.
     */
    cancelOrCloseSearch(args: { repoId: string, searchToken: string }): Promise<ODataValueOfBoolean>;

    /**
     * Returns a search result listing if the search is completed. Optional query parameter: groupByOrderType (default false). This query parameter decides whether or not results are returned in groups based on their entry type. Optional query parameter: refresh (default false). If the search listing should be refreshed to show updated values. Default page size: 150. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer. OData $OrderBy syntax should follow: "PropertyName direction,PropertyName2 direction". sort order can be either "asc" or "desc". Search results expire after 5 minutes, but can be refreshed by retrieving the results again. Optionally returns field values for the entries in the search result listing. Each field name needs to be specified in the request. Maximum limit of 10 field names. If field values are requested, only the first value is returned if it is a multi value field. Null or Empty field values should not be used to determine if a field is assigned to the entry.
     * @param args.repoId The requested repository ID.
     * @param args.searchToken The requested searchToken.
     * @param args.groupByEntryType (optional) An optional query parameter used to indicate if the result should be grouped by entry type or not.
     * @param args.refresh (optional) If the search listing should be refreshed to show updated values.
     * @param args.fields (optional) Optional array of field names. Field values corresponding to the given field names will be returned for each search result.
     * @param args.formatFields (optional) Boolean for if field values should be formatted. Only applicable if Fields are specified.
     * @param args.prefer (optional) An optional odata header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag. The formatFields query parameter must be set to true, otherwise
                culture will not be used for formatting.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get search result successfully.
     */
    getSearchResults(args: { repoId: string, searchToken: string, groupByEntryType?: boolean | undefined, refresh?: boolean | undefined, fields?: string[] | null | undefined, formatFields?: boolean | undefined, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfEntry>;

    /**
     * Returns the context hits associated with a search result entry. Given a searchToken, and rowNumber associated with a search entry in the listing, return the context hits for that entry. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param args.repoId The requested repository ID.
     * @param args.searchToken The requested searchToken.
     * @param args.rowNumber The search result listing row number to get context hits for.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get search context hits successfully.
     */
    getSearchContextHits(args: { repoId: string, searchToken: string, rowNumber: number, prefer?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfContextHit>;
}

export class SearchesClient implements ISearchesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.laserfiche.com/repository";
    }

    
  /**
   * It will continue to make the same call to get a list of search results of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repoId The requested repository ID.
   * @param args.searchToken The requested searchToken.
   * @param args.groupByEntryType (optional) An optional query parameter used to indicate if the result should be grouped by entry type or not.
   * @param args.refresh (optional) If the search listing should be refreshed to show updated values.
   * @param args.fields (optional) Optional array of field names. Field values corresponding to the given field names will be returned for each entry.
   * @param args.formatFields (optional) Boolean for if field values should be formatted. Only applicable if Fields are specified.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
          The value should be a standard language tag. The formatFields query parameter must be set to true, otherwise
          culture will not be used for formatting.  
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of search results allowed per API response schema.
   */
  async getSearchResultsForEach(args: {
    callback: (response: ODataValueContextOfIListOfEntry) => Promise<boolean>;
    repoId: string;
    searchToken: string;
    groupByEntryType?: boolean;
    refresh?: boolean;
    fields?: string[];
    formatFields?: boolean;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let {
      callback,
      repoId,
      searchToken,
      groupByEntryType,
      refresh,
      fields,
      formatFields,
      prefer,
      culture,
      select,
      orderby,
      top,
      skip,
      count,
      maxPageSize,
    } = args;
    var response = await this.getSearchResults({
      repoId,
      searchToken,
      groupByEntryType,
      refresh,
      fields,
      formatFields,
      prefer: createMaxPageSizePreferHeaderPayload(maxPageSize),
      culture,
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink) {
      response = await getNextLinkListing<ODataValueContextOfIListOfEntry>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processGetSearchResults,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }
  /**
   * It will continue to make the same call to get a list of search context hits of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repoId The requested repository ID.
   * @param args.searchToken The requested searchToken.
   * @param args.rowNumber The search result listing row number to get context hits for.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of search context hits allowed per API response schema.
   */
  async getSearchContextHitsForEach(args: {
    callback: (response: ODataValueContextOfIListOfContextHit) => Promise<boolean>;
    repoId: string;
    searchToken: string;
    rowNumber: number;
    prefer?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let { callback, repoId, searchToken, rowNumber, prefer, select, orderby, top, skip, count, maxPageSize } = args;
    var response = await this.getSearchContextHits({
      repoId,
      searchToken,
      rowNumber,
      prefer: createMaxPageSizePreferHeaderPayload(maxPageSize),
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink) {
      response = await getNextLinkListing<ODataValueContextOfIListOfContextHit>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processGetSearchContextHits,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }
  /**
   * Returns a search result listing if the search is completed using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of search results allowed per API response schema
   * @return Get search result with the next link successfully
   */
  async getSearchResultsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfEntry> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<ODataValueContextOfIListOfEntry>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processGetSearchResults,
      nextLink,
      maxPageSize
    );
  }
  /**
   * Returns the context hits associated with a search result entry using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of search context hits allowed per API response schema
   * @return Get search context hits with the next link successfully
   */
  async getSearchContextHitsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfContextHit> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<ODataValueContextOfIListOfContextHit>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processGetSearchContextHits,
      nextLink,
      maxPageSize
    );
  }

    /**
     * Runs a search operation on the repository. Optional body parameters: FuzzyType: (default none), which can be used to determine what is considered a match by number of letters or percentage. FuzzyFactor: integer value that determines the degree to which a search will be considered a match (integer value for NumberOfLetters, or int value representing a percentage). The status for search operations must be checked via the Search specific status checking route.
     * @param args.repoId The requested repository ID.
     * @param args.request (optional) The Laserfiche search command to run, optionally include fuzzy search settings.
     * @return Search operation start successfully.
     */
    createSearchOperation(args: { repoId: string, request?: AdvancedSearchRequest | undefined }): Promise<AcceptedOperation> {
        let { repoId, request } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Searches";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSearchOperation(_response);
        });
    }

    protected processCreateSearchOperation(response: Response): Promise<AcceptedOperation> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = AcceptedOperation.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Operation limit or request limit reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AcceptedOperation>(null as any);
    }

    /**
     * Returns search status. Provide a token (returned in the create search asynchronous route), and get the search status, progress, and any errors that may have occurred. When the search is completed, the Location header can be inspected as a link to the search results. OperationStatus can be one of the following : NotStarted, InProgress, Completed, Failed, or Canceled.
     * @param args.repoId The requested repository ID.
     * @param args.searchToken The requested searchToken.
     * @return Search has failed. Check the errors property to find out why.
     */
    getSearchStatus(args: { repoId: string, searchToken: string }): Promise<OperationProgress> {
        let { repoId, searchToken } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Searches/{searchToken}";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (searchToken === undefined || searchToken === null)
            throw new Error("The parameter 'searchToken' must be defined.");
        url_ = url_.replace("{searchToken}", encodeURIComponent("" + searchToken));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSearchStatus(_response);
        });
    }

    protected processGetSearchStatus(response: Response): Promise<OperationProgress> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OperationProgress.fromJS(resultData200);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = OperationProgress.fromJS(resultData201);
            return result201;
            });
        } else if (status === 202) {
            return response.text().then((_responseText) => {
            let result202: any = null;
            let resultData202 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result202 = OperationProgress.fromJS(resultData202);
            return result202;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request search token not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OperationProgress>(null as any);
    }

    /**
     * Cancels a currently running search. Closes a completed search.
     * @param args.repoId The requested repository ID.
     * @param args.searchToken The requested searchToken.
     * @return Cancel or closed search successfully.
     */
    cancelOrCloseSearch(args: { repoId: string, searchToken: string }): Promise<ODataValueOfBoolean> {
        let { repoId, searchToken } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Searches/{searchToken}";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (searchToken === undefined || searchToken === null)
            throw new Error("The parameter 'searchToken' must be defined.");
        url_ = url_.replace("{searchToken}", encodeURIComponent("" + searchToken));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCancelOrCloseSearch(_response);
        });
    }

    protected processCancelOrCloseSearch(response: Response): Promise<ODataValueOfBoolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueOfBoolean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request search token not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueOfBoolean>(null as any);
    }

    /**
     * Returns a search result listing if the search is completed. Optional query parameter: groupByOrderType (default false). This query parameter decides whether or not results are returned in groups based on their entry type. Optional query parameter: refresh (default false). If the search listing should be refreshed to show updated values. Default page size: 150. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer. OData $OrderBy syntax should follow: "PropertyName direction,PropertyName2 direction". sort order can be either "asc" or "desc". Search results expire after 5 minutes, but can be refreshed by retrieving the results again. Optionally returns field values for the entries in the search result listing. Each field name needs to be specified in the request. Maximum limit of 10 field names. If field values are requested, only the first value is returned if it is a multi value field. Null or Empty field values should not be used to determine if a field is assigned to the entry.
     * @param args.repoId The requested repository ID.
     * @param args.searchToken The requested searchToken.
     * @param args.groupByEntryType (optional) An optional query parameter used to indicate if the result should be grouped by entry type or not.
     * @param args.refresh (optional) If the search listing should be refreshed to show updated values.
     * @param args.fields (optional) Optional array of field names. Field values corresponding to the given field names will be returned for each search result.
     * @param args.formatFields (optional) Boolean for if field values should be formatted. Only applicable if Fields are specified.
     * @param args.prefer (optional) An optional odata header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag. The formatFields query parameter must be set to true, otherwise
                culture will not be used for formatting.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get search result successfully.
     */
    getSearchResults(args: { repoId: string, searchToken: string, groupByEntryType?: boolean | undefined, refresh?: boolean | undefined, fields?: string[] | null | undefined, formatFields?: boolean | undefined, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfEntry> {
        let { repoId, searchToken, groupByEntryType, refresh, fields, formatFields, prefer, culture, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Searches/{searchToken}/Results?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (searchToken === undefined || searchToken === null)
            throw new Error("The parameter 'searchToken' must be defined.");
        url_ = url_.replace("{searchToken}", encodeURIComponent("" + searchToken));
        if (groupByEntryType === null)
            throw new Error("The parameter 'groupByEntryType' cannot be null.");
        else if (groupByEntryType !== undefined)
            url_ += "groupByEntryType=" + encodeURIComponent("" + groupByEntryType) + "&";
        if (refresh === null)
            throw new Error("The parameter 'refresh' cannot be null.");
        else if (refresh !== undefined)
            url_ += "refresh=" + encodeURIComponent("" + refresh) + "&";
        if (fields !== undefined && fields !== null)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (formatFields === null)
            throw new Error("The parameter 'formatFields' cannot be null.");
        else if (formatFields !== undefined)
            url_ += "formatFields=" + encodeURIComponent("" + formatFields) + "&";
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        if (prefer !== null && prefer !== undefined)
            options_.headers = Object.assign({}, options_.headers, {"Prefer": prefer !== undefined && prefer !== null ? "" + prefer : null});

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSearchResults(_response);
        });
    }

    protected processGetSearchResults(response: Response): Promise<ODataValueContextOfIListOfEntry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueContextOfIListOfEntry.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request search token not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueContextOfIListOfEntry>(null as any);
    }

    /**
     * Returns the context hits associated with a search result entry. Given a searchToken, and rowNumber associated with a search entry in the listing, return the context hits for that entry. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param args.repoId The requested repository ID.
     * @param args.searchToken The requested searchToken.
     * @param args.rowNumber The search result listing row number to get context hits for.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get search context hits successfully.
     */
    getSearchContextHits(args: { repoId: string, searchToken: string, rowNumber: number, prefer?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfContextHit> {
        let { repoId, searchToken, rowNumber, prefer, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Searches/{searchToken}/Results/{rowNumber}/ContextHits?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (searchToken === undefined || searchToken === null)
            throw new Error("The parameter 'searchToken' must be defined.");
        url_ = url_.replace("{searchToken}", encodeURIComponent("" + searchToken));
        if (rowNumber === undefined || rowNumber === null)
            throw new Error("The parameter 'rowNumber' must be defined.");
        url_ = url_.replace("{rowNumber}", encodeURIComponent("" + rowNumber));
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        if (prefer !== null && prefer !== undefined)
            options_.headers = Object.assign({}, options_.headers, {"Prefer": prefer !== undefined && prefer !== null ? "" + prefer : null});

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSearchContextHits(_response);
        });
    }

    protected processGetSearchContextHits(response: Response): Promise<ODataValueContextOfIListOfContextHit> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueContextOfIListOfContextHit.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request search token not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueContextOfIListOfContextHit>(null as any);
    }
}

export interface ISimpleSearchesClient {

    /**
     * Runs a "simple" search operation on the repository. Returns a truncated search result listing. Search result listing may be truncated, depending on number of results. Additionally, searches may time out if they take too long. Use the other search route to run full searches. Optionally returns field values for the entries in the search result listing. Each field name needs to be specified in the request. Maximum limit of 10 field names. If field values are requested, only the first value is returned if it is a multi value field. Null or Empty field values should not be used to determine if a field is assigned to the entry.
     * @param args.repoId The requested repository ID.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @param args.fields (optional) Optional array of field names. Field values corresponding to the given field names will be returned for each search result.
     * @param args.formatFields (optional) Boolean for if field values should be formatted. Only applicable if Fields are specified.
     * @param args.request (optional) The Laserfiche search command to run.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag. The formatFields query parameter must be set to true, otherwise
                culture will not be used for formatting.
     * @return Simple search run successfully.
     */
    createSimpleSearchOperation(args: { repoId: string, select?: string | undefined, orderby?: string | undefined, count?: boolean | undefined, fields?: string[] | null | undefined, formatFields?: boolean | undefined, request?: SimpleSearchRequest | undefined, culture?: string | null | undefined }): Promise<ODataValueContextOfIListOfEntry>;
}

export class SimpleSearchesClient implements ISimpleSearchesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.laserfiche.com/repository";
    }

    /**
     * Runs a "simple" search operation on the repository. Returns a truncated search result listing. Search result listing may be truncated, depending on number of results. Additionally, searches may time out if they take too long. Use the other search route to run full searches. Optionally returns field values for the entries in the search result listing. Each field name needs to be specified in the request. Maximum limit of 10 field names. If field values are requested, only the first value is returned if it is a multi value field. Null or Empty field values should not be used to determine if a field is assigned to the entry.
     * @param args.repoId The requested repository ID.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @param args.fields (optional) Optional array of field names. Field values corresponding to the given field names will be returned for each search result.
     * @param args.formatFields (optional) Boolean for if field values should be formatted. Only applicable if Fields are specified.
     * @param args.request (optional) The Laserfiche search command to run.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag. The formatFields query parameter must be set to true, otherwise
                culture will not be used for formatting.
     * @return Simple search run successfully.
     */
    createSimpleSearchOperation(args: { repoId: string, select?: string | undefined, orderby?: string | undefined, count?: boolean | undefined, fields?: string[] | null | undefined, formatFields?: boolean | undefined, request?: SimpleSearchRequest | undefined, culture?: string | null | undefined }): Promise<ODataValueContextOfIListOfEntry> {
        let { repoId, select, orderby, count, fields, formatFields, request, culture } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/SimpleSearches?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (select === null)
            throw new Error("The parameter 'select' cannot be null.");
        else if (select !== undefined)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby === null)
            throw new Error("The parameter 'orderby' cannot be null.");
        else if (orderby !== undefined)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        if (fields !== undefined && fields !== null)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (formatFields === null)
            throw new Error("The parameter 'formatFields' cannot be null.");
        else if (formatFields !== undefined)
            url_ += "formatFields=" + encodeURIComponent("" + formatFields) + "&";
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateSimpleSearchOperation(_response);
        });
    }

    protected processCreateSimpleSearchOperation(response: Response): Promise<ODataValueContextOfIListOfEntry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueContextOfIListOfEntry.fromJS(resultData200);
            return result200;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return throwException("No search results found.", status, _responseText, _headers);
            });
        } else if (status === 206) {
            return response.text().then((_responseText) => {
            let result206: any = null;
            let resultData206 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result206 = ODataValueContextOfIListOfEntry.fromJS(resultData206);
            return result206;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Operation limit or request limit reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueContextOfIListOfEntry>(null as any);
    }
}

export interface ITagDefinitionsClient {

    /**
     * Returns all tag definitions in the repository. Provide a repository ID and get a paged listing of tag definitions available in the repository. Useful when trying to display all tag definitions available, not only tags assigned to a specific entry. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param args.repoId The requested repository ID.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get tag definitions successfully.
     */
    getTagDefinitions(args: { repoId: string, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfWTagInfo>;

    /**
     * Returns a single tag definition. Provide a tag definition ID, and get the single tag definition associated with that ID. Useful when another route provides a minimal amount of details, and more information about the specific tag is needed. Allowed OData query options: Select
     * @param args.repoId The requested repository ID.
     * @param args.tagId The requested tag definition ID.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag.
     * @param args.select (optional) Limits the properties returned in the result.
     * @return Get tag definition successfully.
     */
    getTagDefinitionById(args: { repoId: string, tagId: number, culture?: string | null | undefined, select?: string | null | undefined }): Promise<WTagInfo>;
}

export class TagDefinitionsClient implements ITagDefinitionsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.laserfiche.com/repository";
    }

    
  /**
   * It will continue to make the same call to get a list of tag definitions of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repoId The requested repository ID.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
          The value should be a standard language tag. The formatFields query parameter must be set to true, otherwise
          culture will not be used for formatting.  
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of tag definitions allowed per API response schema.
   */
  async getTagDefinitionsForEach(args: {
    callback: (response: ODataValueContextOfIListOfWTagInfo) => Promise<boolean>;
    repoId: string;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let { callback, repoId, prefer, culture, select, orderby, top, skip, count, maxPageSize } = args;
    var response = await this.getTagDefinitions({
      repoId,
      prefer: createMaxPageSizePreferHeaderPayload(maxPageSize),
      culture,
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink) {
      response = await getNextLinkListing<ODataValueContextOfIListOfWTagInfo>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processGetTagDefinitions,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }
  /**
   * Returns all tag definitions in the repository using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of tag definitions allowed per API response schema
   * @return Get tag definitions with the next link successfully
   */
  async getTagDefinitionsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfWTagInfo> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<ODataValueContextOfIListOfWTagInfo>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processGetTagDefinitions,
      nextLink,
      maxPageSize
    );
  }

    /**
     * Returns all tag definitions in the repository. Provide a repository ID and get a paged listing of tag definitions available in the repository. Useful when trying to display all tag definitions available, not only tags assigned to a specific entry. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param args.repoId The requested repository ID.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get tag definitions successfully.
     */
    getTagDefinitions(args: { repoId: string, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfWTagInfo> {
        let { repoId, prefer, culture, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/TagDefinitions?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        if (prefer !== null && prefer !== undefined)
            options_.headers = Object.assign({}, options_.headers, {"Prefer": prefer !== undefined && prefer !== null ? "" + prefer : null});

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTagDefinitions(_response);
        });
    }

    protected processGetTagDefinitions(response: Response): Promise<ODataValueContextOfIListOfWTagInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueContextOfIListOfWTagInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueContextOfIListOfWTagInfo>(null as any);
    }

    /**
     * Returns a single tag definition. Provide a tag definition ID, and get the single tag definition associated with that ID. Useful when another route provides a minimal amount of details, and more information about the specific tag is needed. Allowed OData query options: Select
     * @param args.repoId The requested repository ID.
     * @param args.tagId The requested tag definition ID.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag.
     * @param args.select (optional) Limits the properties returned in the result.
     * @return Get tag definition successfully.
     */
    getTagDefinitionById(args: { repoId: string, tagId: number, culture?: string | null | undefined, select?: string | null | undefined }): Promise<WTagInfo> {
        let { repoId, tagId, culture, select } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/TagDefinitions/{tagId}?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (tagId === undefined || tagId === null)
            throw new Error("The parameter 'tagId' must be defined.");
        url_ = url_.replace("{tagId}", encodeURIComponent("" + tagId));
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTagDefinitionById(_response);
        });
    }

    protected processGetTagDefinitionById(response: Response): Promise<WTagInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WTagInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request tag definition id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WTagInfo>(null as any);
    }
}

export interface ITasksClient {

    /**
     * Returns the status of an operation. Provide an operationToken (returned in other asynchronous routes) to get the operation status, progress, and any errors that may have occurred. When the operation is completed, the Location header can be inspected as a link to the modified resources (if relevant). OperationStatus can be one of the following values: NotStarted, InProgress, Completed, or Failed.
     * @param args.repoId The requested repository ID
     * @param args.operationToken The operation token
     * @return Get completed or failed operation status with no result successfully.
     */
    getOperationStatusAndProgress(args: { repoId: string, operationToken: string }): Promise<OperationProgress>;

    /**
     * Cancels an operation. Provide an operationToken to cancel the operation, if possible. Should be used if an operation was created in error, or is no longer necessary. Rollbacks must be done manually. For example, if a copy operation is started and is halfway complete when canceled, the client application is responsible for cleaning up the files that were successfully copied before the operation was canceled.
     * @param args.repoId The requested repository ID
     * @param args.operationToken The operation token
     * @return Cancel operation successfully.
     */
    cancelOperation(args: { repoId: string, operationToken: string }): Promise<void>;
}

export class TasksClient implements ITasksClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.laserfiche.com/repository";
    }

    /**
     * Returns the status of an operation. Provide an operationToken (returned in other asynchronous routes) to get the operation status, progress, and any errors that may have occurred. When the operation is completed, the Location header can be inspected as a link to the modified resources (if relevant). OperationStatus can be one of the following values: NotStarted, InProgress, Completed, or Failed.
     * @param args.repoId The requested repository ID
     * @param args.operationToken The operation token
     * @return Get completed or failed operation status with no result successfully.
     */
    getOperationStatusAndProgress(args: { repoId: string, operationToken: string }): Promise<OperationProgress> {
        let { repoId, operationToken } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Tasks/{operationToken}";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (operationToken === undefined || operationToken === null)
            throw new Error("The parameter 'operationToken' must be defined.");
        url_ = url_.replace("{operationToken}", encodeURIComponent("" + operationToken));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOperationStatusAndProgress(_response);
        });
    }

    protected processGetOperationStatusAndProgress(response: Response): Promise<OperationProgress> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OperationProgress.fromJS(resultData200);
            return result200;
            });
        } else if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = OperationProgress.fromJS(resultData201);
            return result201;
            });
        } else if (status === 202) {
            return response.text().then((_responseText) => {
            let result202: any = null;
            let resultData202 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result202 = OperationProgress.fromJS(resultData202);
            return result202;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request operationToken not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OperationProgress>(null as any);
    }

    /**
     * Cancels an operation. Provide an operationToken to cancel the operation, if possible. Should be used if an operation was created in error, or is no longer necessary. Rollbacks must be done manually. For example, if a copy operation is started and is halfway complete when canceled, the client application is responsible for cleaning up the files that were successfully copied before the operation was canceled.
     * @param args.repoId The requested repository ID
     * @param args.operationToken The operation token
     * @return Cancel operation successfully.
     */
    cancelOperation(args: { repoId: string, operationToken: string }): Promise<void> {
        let { repoId, operationToken } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/Tasks/{operationToken}";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (operationToken === undefined || operationToken === null)
            throw new Error("The parameter 'operationToken' must be defined.");
        url_ = url_.replace("{operationToken}", encodeURIComponent("" + operationToken));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCancelOperation(_response);
        });
    }

    protected processCancelOperation(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request operationToken not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface ITemplateDefinitionsClient {

    /**
     * Returns all template definitions (including field definitions) in the repository. If a template name query parameter is given, then a single template definition is returned. Provide a repository ID, and get a paged listing of template definitions available in the repository. Useful when trying to find a list of all template definitions available, rather than a specific one. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param args.repoId The requested repository ID.
     * @param args.templateName (optional) An optional query parameter. Can be used to get a single template definition using the template name.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get template definitions successfully.
     */
    getTemplateDefinitions(args: { repoId: string, templateName?: string | null | undefined, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfWTemplateInfo>;

    /**
     * Returns a single template definition (including field definitions, if relevant). Provide a template definition ID, and get the single template definition associated with that ID. Useful when a route provides a minimal amount of details, and more information about the specific template is needed. Allowed OData query options: Select
     * @param args.repoId The requested repository ID.
     * @param args.templateId The requested template definition ID.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag.
     * @param args.select (optional) Limits the properties returned in the result.
     * @return Get template definition successfully.
     */
    getTemplateDefinitionById(args: { repoId: string, templateId: number, culture?: string | null | undefined, select?: string | null | undefined }): Promise<WTemplateInfo>;

    /**
     * Returns the field definitions assigned to a template definition. Provide a template definition ID, and get a paged listing of the field definitions assigned to that template.  Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param args.repoId The requested repository ID.
     * @param args.templateId The requested template definition ID.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get template field definitions successfully.
     */
    getTemplateFieldDefinitions(args: { repoId: string, templateId: number, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfTemplateFieldInfo>;

    /**
     * Returns the field definitions assigned to a template definition. Provide a template definition name, and get a paged listing of the field definitions assigned to that template.  Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param args.repoId The requested repository ID.
     * @param args.templateName A required query parameter for the requested template name.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get template field definitions successfully.
     */
    getTemplateFieldDefinitionsByTemplateName(args: { repoId: string, templateName: string | null, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfTemplateFieldInfo>;
}

export class TemplateDefinitionsClient implements ITemplateDefinitionsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.laserfiche.com/repository";
    }

    
  /**
   * Given a maximum page size, it will continue to make the same call to get a list of template definitions of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repoId The requested repository ID.
   * @param args.templateName (optional) An optional query parameter. Can be used to get a single template definition using the template name.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
          The value should be a standard language tag. The formatFields query parameter must be set to true, otherwise
          culture will not be used for formatting.  
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of template definitions allowed per API response schema.
   */
  async getTemplateDefinitionsForEach(args: {
    callback: (response: ODataValueContextOfIListOfWTemplateInfo) => Promise<boolean>;
    repoId: string;
    templateName?: string;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let { callback, repoId, templateName, prefer, culture, select, orderby, top, skip, count, maxPageSize } = args;
    var response = await this.getTemplateDefinitions({
      repoId,
      templateName,
      prefer: createMaxPageSizePreferHeaderPayload(maxPageSize),
      culture,
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink) {
      response = await getNextLinkListing<ODataValueContextOfIListOfWTemplateInfo>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processGetTemplateDefinitions,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }
  /**
   * It will continue to make the same call to get a list of template field definitions of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repoId The requested repository ID.
   * @param args.templateName (optional) An optional query parameter. Can be used to get a single template definition using the template name.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
          The value should be a standard language tag. The formatFields query parameter must be set to true, otherwise
          culture will not be used for formatting.  
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of template field definitions allowed per API response schema.
   */
  async getTemplateFieldDefinitionsForEach(args: {
    callback: (response: ODataValueContextOfIListOfTemplateFieldInfo) => Promise<boolean>;
    repoId: string;
    templateId: number;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let { callback, repoId, templateId, prefer, culture, select, orderby, top, skip, count, maxPageSize } = args;
    var response = await this.getTemplateFieldDefinitions({
      repoId,
      templateId,
      prefer: createMaxPageSizePreferHeaderPayload(maxPageSize),
      culture,
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink) {
      response = await getNextLinkListing<ODataValueContextOfIListOfTemplateFieldInfo>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processGetTemplateFieldDefinitions,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }
  /**
   * It will continue to make the same call to get a list of template field definitions by template name of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repoId The requested repository ID.
   * @param args.templateName (optional) An optional query parameter. Can be used to get a single template definition using the template name.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
          The value should be a standard language tag. The formatFields query parameter must be set to true, otherwise
          culture will not be used for formatting.  
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of template field definitions by template name allowed per API response schema.
   */
  async getTemplateFieldDefinitionsByTemplateNameForEach(args: {
    callback: (response: ODataValueContextOfIListOfTemplateFieldInfo) => Promise<boolean>;
    repoId: string;
    templateName: string;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void> {
    let { callback, repoId, templateName, prefer, culture, select, orderby, top, skip, count, maxPageSize } = args;
    var response = await this.getTemplateFieldDefinitionsByTemplateName({
      repoId,
      templateName,
      prefer: createMaxPageSizePreferHeaderPayload(maxPageSize),
      culture,
      select,
      orderby,
      top,
      skip,
      count,
    });
    let nextLink = response.odataNextLink;
    while ((await callback(response)) && nextLink) {
      response = await getNextLinkListing<ODataValueContextOfIListOfTemplateFieldInfo>(
        // @ts-ignore: allow sub class to use private variable from the super class
        this.http,
        this.processGetTemplateFieldDefinitionsByTemplateName,
        nextLink,
        maxPageSize
      );
      nextLink = response.odataNextLink;
    }
  }
  /**
   * Returns all template definitions (including field definitions) in the repository using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of template definitions allowed per API response schema
   * @return Get template definitions with the next link successfully
   */
  async getTemplateDefinitionsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfWTemplateInfo> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<ODataValueContextOfIListOfWTemplateInfo>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processGetTemplateDefinitions,
      nextLink,
      maxPageSize
    );
  }
  /**
   * Returns the field definitions assigned to a template definition using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of template field definitions allowed per API response schema
   * @return Get field definitions with the next link successfully
   */
  async getTemplateFieldDefinitionsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfTemplateFieldInfo> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<ODataValueContextOfIListOfTemplateFieldInfo>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processGetTemplateFieldDefinitions,
      nextLink,
      maxPageSize
    );
  }
  /**
   * Returns the field definitions assigned to a template definition by template name using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of template field definitions by template name allowed per API response schema
   * @return Get field definitions by template name with the next link successfully
   */
  async getTemplateFieldDefinitionsByTemplateNameNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfTemplateFieldInfo> {
    let { nextLink, maxPageSize } = args;
    return await getNextLinkListing<ODataValueContextOfIListOfTemplateFieldInfo>(
      // @ts-ignore: allow sub class to use private variable from the super class
      this.http,
      this.processGetTemplateFieldDefinitionsByTemplateName,
      nextLink,
      maxPageSize
    );
  }

    /**
     * Returns all template definitions (including field definitions) in the repository. If a template name query parameter is given, then a single template definition is returned. Provide a repository ID, and get a paged listing of template definitions available in the repository. Useful when trying to find a list of all template definitions available, rather than a specific one. Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param args.repoId The requested repository ID.
     * @param args.templateName (optional) An optional query parameter. Can be used to get a single template definition using the template name.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get template definitions successfully.
     */
    getTemplateDefinitions(args: { repoId: string, templateName?: string | null | undefined, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfWTemplateInfo> {
        let { repoId, templateName, prefer, culture, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/TemplateDefinitions?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (templateName !== undefined && templateName !== null)
            url_ += "templateName=" + encodeURIComponent("" + templateName) + "&";
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        if (prefer !== null && prefer !== undefined)
            options_.headers = Object.assign({}, options_.headers, {"Prefer": prefer !== undefined && prefer !== null ? "" + prefer : null});

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTemplateDefinitions(_response);
        });
    }

    protected processGetTemplateDefinitions(response: Response): Promise<ODataValueContextOfIListOfWTemplateInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueContextOfIListOfWTemplateInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request template name not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueContextOfIListOfWTemplateInfo>(null as any);
    }

    /**
     * Returns a single template definition (including field definitions, if relevant). Provide a template definition ID, and get the single template definition associated with that ID. Useful when a route provides a minimal amount of details, and more information about the specific template is needed. Allowed OData query options: Select
     * @param args.repoId The requested repository ID.
     * @param args.templateId The requested template definition ID.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag.
     * @param args.select (optional) Limits the properties returned in the result.
     * @return Get template definition successfully.
     */
    getTemplateDefinitionById(args: { repoId: string, templateId: number, culture?: string | null | undefined, select?: string | null | undefined }): Promise<WTemplateInfo> {
        let { repoId, templateId, culture, select } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/TemplateDefinitions/{templateId}?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (templateId === undefined || templateId === null)
            throw new Error("The parameter 'templateId' must be defined.");
        url_ = url_.replace("{templateId}", encodeURIComponent("" + templateId));
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTemplateDefinitionById(_response);
        });
    }

    protected processGetTemplateDefinitionById(response: Response): Promise<WTemplateInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WTemplateInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request template id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WTemplateInfo>(null as any);
    }

    /**
     * Returns the field definitions assigned to a template definition. Provide a template definition ID, and get a paged listing of the field definitions assigned to that template.  Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param args.repoId The requested repository ID.
     * @param args.templateId The requested template definition ID.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get template field definitions successfully.
     */
    getTemplateFieldDefinitions(args: { repoId: string, templateId: number, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfTemplateFieldInfo> {
        let { repoId, templateId, prefer, culture, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/TemplateDefinitions/{templateId}/Fields?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (templateId === undefined || templateId === null)
            throw new Error("The parameter 'templateId' must be defined.");
        url_ = url_.replace("{templateId}", encodeURIComponent("" + templateId));
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        if (prefer !== null && prefer !== undefined)
            options_.headers = Object.assign({}, options_.headers, {"Prefer": prefer !== undefined && prefer !== null ? "" + prefer : null});

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTemplateFieldDefinitions(_response);
        });
    }

    protected processGetTemplateFieldDefinitions(response: Response): Promise<ODataValueContextOfIListOfTemplateFieldInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueContextOfIListOfTemplateFieldInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request template id not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueContextOfIListOfTemplateFieldInfo>(null as any);
    }

    /**
     * Returns the field definitions assigned to a template definition. Provide a template definition name, and get a paged listing of the field definitions assigned to that template.  Default page size: 100. Allowed OData query options: Select | Count | OrderBy | Skip | Top | SkipToken | Prefer.
     * @param args.repoId The requested repository ID.
     * @param args.templateName A required query parameter for the requested template name.
     * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
     * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
                The value should be a standard language tag.
     * @param args.select (optional) Limits the properties returned in the result.
     * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
     * @param args.top (optional) Limits the number of items returned from a collection.
     * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
     * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
     * @return Get template field definitions successfully.
     */
    getTemplateFieldDefinitionsByTemplateName(args: { repoId: string, templateName: string | null, prefer?: string | null | undefined, culture?: string | null | undefined, select?: string | null | undefined, orderby?: string | null | undefined, top?: number | undefined, skip?: number | undefined, count?: boolean | undefined }): Promise<ODataValueContextOfIListOfTemplateFieldInfo> {
        let { repoId, templateName, prefer, culture, select, orderby, top, skip, count } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/TemplateDefinitions/Fields?";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        if (templateName === undefined)
            throw new Error("The parameter 'templateName' must be defined.");
        else if(templateName !== null)
            url_ += "templateName=" + encodeURIComponent("" + templateName) + "&";
        if (culture !== undefined && culture !== null)
            url_ += "culture=" + encodeURIComponent("" + culture) + "&";
        if (select !== undefined && select !== null)
            url_ += "$select=" + encodeURIComponent("" + select) + "&";
        if (orderby !== undefined && orderby !== null)
            url_ += "$orderby=" + encodeURIComponent("" + orderby) + "&";
        if (top === null)
            throw new Error("The parameter 'top' cannot be null.");
        else if (top !== undefined)
            url_ += "$top=" + encodeURIComponent("" + top) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "$skip=" + encodeURIComponent("" + skip) + "&";
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "$count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        if (prefer !== null && prefer !== undefined)
            options_.headers = Object.assign({}, options_.headers, {"Prefer": prefer !== undefined && prefer !== null ? "" + prefer : null});

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTemplateFieldDefinitionsByTemplateName(_response);
        });
    }

    protected processGetTemplateFieldDefinitionsByTemplateName(response: Response): Promise<ODataValueContextOfIListOfTemplateFieldInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueContextOfIListOfTemplateFieldInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Request template name not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueContextOfIListOfTemplateFieldInfo>(null as any);
    }
}

export interface IServerSessionClient {

    /**
     * Deprecated. Invalidates the server session. Acts as a "logout" operation, and invalidates the session associated with the provided access token. This method should be used when the client wants to clean up the current session. Only available in Laserfiche Cloud.
     * @param args.repoId The requested repository ID.
     * @return Invalidate the server session successfully.
     * @deprecated
     */
    invalidateServerSession(args: { repoId: string }): Promise<ODataValueOfBoolean>;

    /**
     * Deprecated. Refreshes the session associated with the access token. This is only necessary if you want to keep the same session alive, otherwise a new session will be automatically created when the session expires. When a client application wants to keep a session alive that has been idle for an hour, this route can be used to refresh the expiration timer associated with the access token. Only available in Laserfiche Cloud.
     * @param args.repoId The requested repository ID.
     * @return Refresh the session successfully.
     * @deprecated
     */
    refreshServerSession(args: { repoId: string }): Promise<ODataValueOfDateTime>;

    /**
     * Deprecated. This function is a no-op, always returns 200. Only available in Laserfiche Cloud.
     * @param args.repoId The requested repository ID.
     * @return Create the session successfully.
     * @deprecated
     */
    createServerSession(args: { repoId: string }): Promise<ODataValueOfBoolean>;
}

export class ServerSessionClient implements IServerSessionClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://api.laserfiche.com/repository";
    }

    /**
     * Deprecated. Invalidates the server session. Acts as a "logout" operation, and invalidates the session associated with the provided access token. This method should be used when the client wants to clean up the current session. Only available in Laserfiche Cloud.
     * @param args.repoId The requested repository ID.
     * @return Invalidate the server session successfully.
     * @deprecated
     */
    invalidateServerSession(args: { repoId: string }): Promise<ODataValueOfBoolean> {
        let { repoId } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/ServerSession/Invalidate";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInvalidateServerSession(_response);
        });
    }

    protected processInvalidateServerSession(response: Response): Promise<ODataValueOfBoolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueOfBoolean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueOfBoolean>(null as any);
    }

    /**
     * Deprecated. Refreshes the session associated with the access token. This is only necessary if you want to keep the same session alive, otherwise a new session will be automatically created when the session expires. When a client application wants to keep a session alive that has been idle for an hour, this route can be used to refresh the expiration timer associated with the access token. Only available in Laserfiche Cloud.
     * @param args.repoId The requested repository ID.
     * @return Refresh the session successfully.
     * @deprecated
     */
    refreshServerSession(args: { repoId: string }): Promise<ODataValueOfDateTime> {
        let { repoId } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/ServerSession/Refresh";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefreshServerSession(_response);
        });
    }

    protected processRefreshServerSession(response: Response): Promise<ODataValueOfDateTime> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueOfDateTime.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Invalid or bad request.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            let resultData429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result429 = ProblemDetails.fromJS(resultData429);
            return throwException("Rate limit is reached.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueOfDateTime>(null as any);
    }

    /**
     * Deprecated. This function is a no-op, always returns 200. Only available in Laserfiche Cloud.
     * @param args.repoId The requested repository ID.
     * @return Create the session successfully.
     * @deprecated
     */
    createServerSession(args: { repoId: string }): Promise<ODataValueOfBoolean> {
        let { repoId } = args;
        let url_ = this.baseUrl + "/v1/Repositories/{repoId}/ServerSession/Create";
        if (repoId === undefined || repoId === null)
            throw new Error("The parameter 'repoId' must be defined.");
        url_ = url_.replace("{repoId}", encodeURIComponent("" + repoId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateServerSession(_response);
        });
    }

    protected processCreateServerSession(response: Response): Promise<ODataValueOfBoolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ODataValueOfBoolean.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Access token is invalid or expired.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Access denied for the operation.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ODataValueOfBoolean>(null as any);
    }
}

export class CreateEntryResult implements ICreateEntryResult {
    operations?: CreateEntryOperations;
    /** A link to get the created entry. */
    documentLink?: string | undefined;

    
    
    /** @internal */
  getSummary(): string {
    let messages = [];
    const entryId: number = this.operations?.entryCreate?.entryId ?? 0;
    if (entryId !== 0) {
      messages.push(`entryId = ${entryId}`);
    }

    function getErrorMessages(errors: APIServerException[] | undefined): string {
      if (errors == null) {
        return "";
      }
      
      return errors.map(item => item.message).join(" ");
    }

    messages.push(getErrorMessages(this.operations?.entryCreate?.exceptions));
    messages.push(getErrorMessages(this.operations?.setEdoc?.exceptions));
    messages.push(getErrorMessages(this.operations?.setFields?.exceptions));
    messages.push(getErrorMessages(this.operations?.setLinks?.exceptions));
    messages.push(getErrorMessages(this.operations?.setTags?.exceptions));
    messages.push(getErrorMessages(this.operations?.setTemplate?.exceptions));

    return messages.filter(item => item).join(" ");
  }

    constructor(data?: ICreateEntryResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.operations = _data["operations"] ? CreateEntryOperations.fromJS(_data["operations"]) : <any>undefined;
            this.documentLink = _data["documentLink"];
        }
    }

    static fromJS(data: any): CreateEntryResult {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEntryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["operations"] = this.operations ? this.operations.toJSON() : <any>undefined;
        data["documentLink"] = this.documentLink;
        return data;
    }
}

export interface ICreateEntryResult {
    operations?: CreateEntryOperations;
    /** A link to get the created entry. */
    documentLink?: string | undefined;
}

/** The results of each operation needed in order to create the electronic document with optional template and fields. */
export class CreateEntryOperations implements ICreateEntryOperations {
    entryCreate?: EntryCreate;
    setEdoc?: SetEdoc;
    setTemplate?: SetTemplate;
    setFields?: SetFields;
    setTags?: SetTags;
    setLinks?: SetLinks;

    
    
    constructor(data?: ICreateEntryOperations) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entryCreate = _data["entryCreate"] ? EntryCreate.fromJS(_data["entryCreate"]) : <any>undefined;
            this.setEdoc = _data["setEdoc"] ? SetEdoc.fromJS(_data["setEdoc"]) : <any>undefined;
            this.setTemplate = _data["setTemplate"] ? SetTemplate.fromJS(_data["setTemplate"]) : <any>undefined;
            this.setFields = _data["setFields"] ? SetFields.fromJS(_data["setFields"]) : <any>undefined;
            this.setTags = _data["setTags"] ? SetTags.fromJS(_data["setTags"]) : <any>undefined;
            this.setLinks = _data["setLinks"] ? SetLinks.fromJS(_data["setLinks"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateEntryOperations {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEntryOperations();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entryCreate"] = this.entryCreate ? this.entryCreate.toJSON() : <any>undefined;
        data["setEdoc"] = this.setEdoc ? this.setEdoc.toJSON() : <any>undefined;
        data["setTemplate"] = this.setTemplate ? this.setTemplate.toJSON() : <any>undefined;
        data["setFields"] = this.setFields ? this.setFields.toJSON() : <any>undefined;
        data["setTags"] = this.setTags ? this.setTags.toJSON() : <any>undefined;
        data["setLinks"] = this.setLinks ? this.setLinks.toJSON() : <any>undefined;
        return data;
    }
}

/** The results of each operation needed in order to create the electronic document with optional template and fields. */
export interface ICreateEntryOperations {
    entryCreate?: EntryCreate;
    setEdoc?: SetEdoc;
    setTemplate?: SetTemplate;
    setFields?: SetFields;
    setTags?: SetTags;
    setLinks?: SetLinks;
}

/** The result of trying to create the entry. */
export class EntryCreate implements IEntryCreate {
    /** The list of exceptions that occured when trying to perform the operation. */
    exceptions?: APIServerException[] | undefined;
    /** The id of the created entry. If the id is 0, then the entry was not created. */
    entryId?: number;

    
    
    constructor(data?: IEntryCreate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["exceptions"])) {
                this.exceptions = [] as any;
                for (let item of _data["exceptions"])
                    this.exceptions!.push(APIServerException.fromJS(item));
            }
            this.entryId = _data["entryId"];
        }
    }

    static fromJS(data: any): EntryCreate {
        data = typeof data === 'object' ? data : {};
        let result = new EntryCreate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.exceptions)) {
            data["exceptions"] = [];
            for (let item of this.exceptions)
                data["exceptions"].push(item.toJSON());
        }
        data["entryId"] = this.entryId;
        return data;
    }
}

/** The result of trying to create the entry. */
export interface IEntryCreate {
    /** The list of exceptions that occured when trying to perform the operation. */
    exceptions?: APIServerException[] | undefined;
    /** The id of the created entry. If the id is 0, then the entry was not created. */
    entryId?: number;
}

export class APIServerException implements IAPIServerException {
    /** The id of the operation that threw the exception. */
    operationId?: string | undefined;
    /** The explaination of the exception that occurred. */
    message?: string | undefined;
    /** The code associated with the exception. */
    errorCode?: number | undefined;
    /** The class of exceptions this belongs to. */
    errorClass?: string | undefined;
    /** The HTTP status code returned. */
    statusCode?: number | undefined;
    /** The source of where the exception occurred. */
    errorSource?: string | undefined;

    
    
    constructor(data?: IAPIServerException) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.operationId = _data["operationId"];
            this.message = _data["message"];
            this.errorCode = _data["errorCode"];
            this.errorClass = _data["errorClass"];
            this.statusCode = _data["statusCode"];
            this.errorSource = _data["errorSource"];
        }
    }

    static fromJS(data: any): APIServerException {
        data = typeof data === 'object' ? data : {};
        let result = new APIServerException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["operationId"] = this.operationId;
        data["message"] = this.message;
        data["errorCode"] = this.errorCode;
        data["errorClass"] = this.errorClass;
        data["statusCode"] = this.statusCode;
        data["errorSource"] = this.errorSource;
        return data;
    }
}

export interface IAPIServerException {
    /** The id of the operation that threw the exception. */
    operationId?: string | undefined;
    /** The explaination of the exception that occurred. */
    message?: string | undefined;
    /** The code associated with the exception. */
    errorCode?: number | undefined;
    /** The class of exceptions this belongs to. */
    errorClass?: string | undefined;
    /** The HTTP status code returned. */
    statusCode?: number | undefined;
    /** The source of where the exception occurred. */
    errorSource?: string | undefined;
}

/** The result of trying to create the electronic document. */
export class SetEdoc implements ISetEdoc {
    /** The list of exceptions that occured when trying to perform the operation. */
    exceptions?: APIServerException[] | undefined;

    
    
    constructor(data?: ISetEdoc) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["exceptions"])) {
                this.exceptions = [] as any;
                for (let item of _data["exceptions"])
                    this.exceptions!.push(APIServerException.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SetEdoc {
        data = typeof data === 'object' ? data : {};
        let result = new SetEdoc();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.exceptions)) {
            data["exceptions"] = [];
            for (let item of this.exceptions)
                data["exceptions"].push(item.toJSON());
        }
        return data;
    }
}

/** The result of trying to create the electronic document. */
export interface ISetEdoc {
    /** The list of exceptions that occured when trying to perform the operation. */
    exceptions?: APIServerException[] | undefined;
}

/** The result of trying to assign a template to the entry. */
export class SetTemplate implements ISetTemplate {
    /** The list of exceptions that occured when trying to perform the operation. */
    exceptions?: APIServerException[] | undefined;
    /** The name of the template assigned to the entry. If this is null, then no template was assigned. */
    template?: string | undefined;

    
    
    constructor(data?: ISetTemplate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["exceptions"])) {
                this.exceptions = [] as any;
                for (let item of _data["exceptions"])
                    this.exceptions!.push(APIServerException.fromJS(item));
            }
            this.template = _data["template"];
        }
    }

    static fromJS(data: any): SetTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new SetTemplate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.exceptions)) {
            data["exceptions"] = [];
            for (let item of this.exceptions)
                data["exceptions"].push(item.toJSON());
        }
        data["template"] = this.template;
        return data;
    }
}

/** The result of trying to assign a template to the entry. */
export interface ISetTemplate {
    /** The list of exceptions that occured when trying to perform the operation. */
    exceptions?: APIServerException[] | undefined;
    /** The name of the template assigned to the entry. If this is null, then no template was assigned. */
    template?: string | undefined;
}

/** The result of trying to assign fields to the entry. */
export class SetFields implements ISetFields {
    /** The list of exceptions that occured when trying to perform the operation. */
    exceptions?: APIServerException[] | undefined;
    /** The number of fields assigned to the entry. */
    fieldCount?: number;

    
    
    constructor(data?: ISetFields) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["exceptions"])) {
                this.exceptions = [] as any;
                for (let item of _data["exceptions"])
                    this.exceptions!.push(APIServerException.fromJS(item));
            }
            this.fieldCount = _data["fieldCount"];
        }
    }

    static fromJS(data: any): SetFields {
        data = typeof data === 'object' ? data : {};
        let result = new SetFields();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.exceptions)) {
            data["exceptions"] = [];
            for (let item of this.exceptions)
                data["exceptions"].push(item.toJSON());
        }
        data["fieldCount"] = this.fieldCount;
        return data;
    }
}

/** The result of trying to assign fields to the entry. */
export interface ISetFields {
    /** The list of exceptions that occured when trying to perform the operation. */
    exceptions?: APIServerException[] | undefined;
    /** The number of fields assigned to the entry. */
    fieldCount?: number;
}

/** The result of trying to assign fields to the entry. */
export class SetTags implements ISetTags {
    /** The list of exceptions that occured when trying to perform the operation. */
    exceptions?: APIServerException[] | undefined;
    /** The tags that were assigned to the entry */
    assignedTags?: string[] | undefined;

    
    
    constructor(data?: ISetTags) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["exceptions"])) {
                this.exceptions = [] as any;
                for (let item of _data["exceptions"])
                    this.exceptions!.push(APIServerException.fromJS(item));
            }
            if (Array.isArray(_data["assignedTags"])) {
                this.assignedTags = [] as any;
                for (let item of _data["assignedTags"])
                    this.assignedTags!.push(item);
            }
        }
    }

    static fromJS(data: any): SetTags {
        data = typeof data === 'object' ? data : {};
        let result = new SetTags();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.exceptions)) {
            data["exceptions"] = [];
            for (let item of this.exceptions)
                data["exceptions"].push(item.toJSON());
        }
        if (Array.isArray(this.assignedTags)) {
            data["assignedTags"] = [];
            for (let item of this.assignedTags)
                data["assignedTags"].push(item);
        }
        return data;
    }
}

/** The result of trying to assign fields to the entry. */
export interface ISetTags {
    /** The list of exceptions that occured when trying to perform the operation. */
    exceptions?: APIServerException[] | undefined;
    /** The tags that were assigned to the entry */
    assignedTags?: string[] | undefined;
}

/** The result of trying to assign a entry link to the entry. */
export class SetLinks implements ISetLinks {
    /** The list of exceptions that occured when trying to perform the operation. */
    exceptions?: APIServerException[] | undefined;
    /** The ids of the other entries linked to the entry */
    otherEntryIds?: number[] | undefined;

    
    
    constructor(data?: ISetLinks) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["exceptions"])) {
                this.exceptions = [] as any;
                for (let item of _data["exceptions"])
                    this.exceptions!.push(APIServerException.fromJS(item));
            }
            if (Array.isArray(_data["otherEntryIds"])) {
                this.otherEntryIds = [] as any;
                for (let item of _data["otherEntryIds"])
                    this.otherEntryIds!.push(item);
            }
        }
    }

    static fromJS(data: any): SetLinks {
        data = typeof data === 'object' ? data : {};
        let result = new SetLinks();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.exceptions)) {
            data["exceptions"] = [];
            for (let item of this.exceptions)
                data["exceptions"].push(item.toJSON());
        }
        if (Array.isArray(this.otherEntryIds)) {
            data["otherEntryIds"] = [];
            for (let item of this.otherEntryIds)
                data["otherEntryIds"].push(item);
        }
        return data;
    }
}

/** The result of trying to assign a entry link to the entry. */
export interface ISetLinks {
    /** The list of exceptions that occured when trying to perform the operation. */
    exceptions?: APIServerException[] | undefined;
    /** The ids of the other entries linked to the entry */
    otherEntryIds?: number[] | undefined;
}

/** A machine-readable format for specifying errors in HTTP API responses based on https://tools.ietf.org/html/rfc7807. */
export class ProblemDetails implements IProblemDetails {
    /** The problem type. */
    type?: string | undefined;
    /** A short, human-readable summary of the problem type. */
    title?: string | undefined;
    /** The HTTP status code. */
    status!: number;
    /** A human-readable explanation specific to this occurrence of the problem. */
    detail?: string | undefined;
    /** A URI reference that identifies the specific occurrence of the problem. */
    instance?: string | undefined;
    /** The operation id. */
    operationId?: string | undefined;
    /** The error source. */
    errorSource?: string | undefined;
    /** The error code. */
    errorCode?: number;
    /** The trace id. */
    traceId?: string | undefined;

    
    
    extensions: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            this.operationId = _data["operationId"];
            this.errorSource = _data["errorSource"];
            this.errorCode = _data["errorCode"];
            this.traceId = _data["traceId"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        data["operationId"] = this.operationId;
        data["errorSource"] = this.errorSource;
        data["errorCode"] = this.errorCode;
        data["traceId"] = this.traceId;
        return data;
    }
}

/** A machine-readable format for specifying errors in HTTP API responses based on https://tools.ietf.org/html/rfc7807. */
export interface IProblemDetails {
    /** The problem type. */
    type?: string | undefined;
    /** A short, human-readable summary of the problem type. */
    title?: string | undefined;
    /** The HTTP status code. */
    status: number;
    /** A human-readable explanation specific to this occurrence of the problem. */
    detail?: string | undefined;
    /** A URI reference that identifies the specific occurrence of the problem. */
    instance?: string | undefined;
    /** The operation id. */
    operationId?: string | undefined;
    /** The error source. */
    errorSource?: string | undefined;
    /** The error code. */
    errorCode?: number;
    /** The trace id. */
    traceId?: string | undefined;
}

export abstract class IHeaderDictionary implements IIHeaderDictionary {
    item?: any[];
    contentLength?: number | undefined;
    accept?: any[];
    acceptCharset?: any[];
    acceptEncoding?: any[];
    acceptLanguage?: any[];
    acceptRanges?: any[];
    accessControlAllowCredentials?: any[];
    accessControlAllowHeaders?: any[];
    accessControlAllowMethods?: any[];
    accessControlAllowOrigin?: any[];
    accessControlExposeHeaders?: any[];
    accessControlMaxAge?: any[];
    accessControlRequestHeaders?: any[];
    accessControlRequestMethod?: any[];
    age?: any[];
    allow?: any[];
    altSvc?: any[];
    authorization?: any[];
    baggage?: any[];
    cacheControl?: any[];
    connection?: any[];
    contentDisposition?: any[];
    contentEncoding?: any[];
    contentLanguage?: any[];
    contentLocation?: any[];
    contentMD5?: any[];
    contentRange?: any[];
    contentSecurityPolicy?: any[];
    contentSecurityPolicyReportOnly?: any[];
    contentType?: any[];
    correlationContext?: any[];
    cookie?: any[];
    date?: any[];
    eTag?: any[];
    expires?: any[];
    expect?: any[];
    from?: any[];
    grpcAcceptEncoding?: any[];
    grpcEncoding?: any[];
    grpcMessage?: any[];
    grpcStatus?: any[];
    grpcTimeout?: any[];
    host?: any[];
    keepAlive?: any[];
    ifMatch?: any[];
    ifModifiedSince?: any[];
    ifNoneMatch?: any[];
    ifRange?: any[];
    ifUnmodifiedSince?: any[];
    lastModified?: any[];
    link?: any[];
    location?: any[];
    maxForwards?: any[];
    origin?: any[];
    pragma?: any[];
    proxyAuthenticate?: any[];
    proxyAuthorization?: any[];
    proxyConnection?: any[];
    range?: any[];
    referer?: any[];
    retryAfter?: any[];
    requestId?: any[];
    secWebSocketAccept?: any[];
    secWebSocketKey?: any[];
    secWebSocketProtocol?: any[];
    secWebSocketVersion?: any[];
    secWebSocketExtensions?: any[];
    server?: any[];
    setCookie?: any[];
    strictTransportSecurity?: any[];
    tE?: any[];
    trailer?: any[];
    transferEncoding?: any[];
    translate?: any[];
    traceParent?: any[];
    traceState?: any[];
    upgrade?: any[];
    upgradeInsecureRequests?: any[];
    userAgent?: any[];
    vary?: any[];
    via?: any[];
    warning?: any[];
    webSocketSubProtocols?: any[];
    wWWAuthenticate?: any[];
    xContentTypeOptions?: any[];
    xFrameOptions?: any[];
    xPoweredBy?: any[];
    xRequestedWith?: any[];
    xUACompatible?: any[];
    xXSSProtection?: any[];

    
    
    constructor(data?: IIHeaderDictionary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["Item"])) {
                this.item = [] as any;
                for (let item of _data["Item"])
                    this.item!.push(item);
            }
            this.contentLength = _data["ContentLength"];
            if (Array.isArray(_data["Accept"])) {
                this.accept = [] as any;
                for (let item of _data["Accept"])
                    this.accept!.push(item);
            }
            if (Array.isArray(_data["AcceptCharset"])) {
                this.acceptCharset = [] as any;
                for (let item of _data["AcceptCharset"])
                    this.acceptCharset!.push(item);
            }
            if (Array.isArray(_data["AcceptEncoding"])) {
                this.acceptEncoding = [] as any;
                for (let item of _data["AcceptEncoding"])
                    this.acceptEncoding!.push(item);
            }
            if (Array.isArray(_data["AcceptLanguage"])) {
                this.acceptLanguage = [] as any;
                for (let item of _data["AcceptLanguage"])
                    this.acceptLanguage!.push(item);
            }
            if (Array.isArray(_data["AcceptRanges"])) {
                this.acceptRanges = [] as any;
                for (let item of _data["AcceptRanges"])
                    this.acceptRanges!.push(item);
            }
            if (Array.isArray(_data["AccessControlAllowCredentials"])) {
                this.accessControlAllowCredentials = [] as any;
                for (let item of _data["AccessControlAllowCredentials"])
                    this.accessControlAllowCredentials!.push(item);
            }
            if (Array.isArray(_data["AccessControlAllowHeaders"])) {
                this.accessControlAllowHeaders = [] as any;
                for (let item of _data["AccessControlAllowHeaders"])
                    this.accessControlAllowHeaders!.push(item);
            }
            if (Array.isArray(_data["AccessControlAllowMethods"])) {
                this.accessControlAllowMethods = [] as any;
                for (let item of _data["AccessControlAllowMethods"])
                    this.accessControlAllowMethods!.push(item);
            }
            if (Array.isArray(_data["AccessControlAllowOrigin"])) {
                this.accessControlAllowOrigin = [] as any;
                for (let item of _data["AccessControlAllowOrigin"])
                    this.accessControlAllowOrigin!.push(item);
            }
            if (Array.isArray(_data["AccessControlExposeHeaders"])) {
                this.accessControlExposeHeaders = [] as any;
                for (let item of _data["AccessControlExposeHeaders"])
                    this.accessControlExposeHeaders!.push(item);
            }
            if (Array.isArray(_data["AccessControlMaxAge"])) {
                this.accessControlMaxAge = [] as any;
                for (let item of _data["AccessControlMaxAge"])
                    this.accessControlMaxAge!.push(item);
            }
            if (Array.isArray(_data["AccessControlRequestHeaders"])) {
                this.accessControlRequestHeaders = [] as any;
                for (let item of _data["AccessControlRequestHeaders"])
                    this.accessControlRequestHeaders!.push(item);
            }
            if (Array.isArray(_data["AccessControlRequestMethod"])) {
                this.accessControlRequestMethod = [] as any;
                for (let item of _data["AccessControlRequestMethod"])
                    this.accessControlRequestMethod!.push(item);
            }
            if (Array.isArray(_data["Age"])) {
                this.age = [] as any;
                for (let item of _data["Age"])
                    this.age!.push(item);
            }
            if (Array.isArray(_data["Allow"])) {
                this.allow = [] as any;
                for (let item of _data["Allow"])
                    this.allow!.push(item);
            }
            if (Array.isArray(_data["AltSvc"])) {
                this.altSvc = [] as any;
                for (let item of _data["AltSvc"])
                    this.altSvc!.push(item);
            }
            if (Array.isArray(_data["Authorization"])) {
                this.authorization = [] as any;
                for (let item of _data["Authorization"])
                    this.authorization!.push(item);
            }
            if (Array.isArray(_data["Baggage"])) {
                this.baggage = [] as any;
                for (let item of _data["Baggage"])
                    this.baggage!.push(item);
            }
            if (Array.isArray(_data["CacheControl"])) {
                this.cacheControl = [] as any;
                for (let item of _data["CacheControl"])
                    this.cacheControl!.push(item);
            }
            if (Array.isArray(_data["Connection"])) {
                this.connection = [] as any;
                for (let item of _data["Connection"])
                    this.connection!.push(item);
            }
            if (Array.isArray(_data["ContentDisposition"])) {
                this.contentDisposition = [] as any;
                for (let item of _data["ContentDisposition"])
                    this.contentDisposition!.push(item);
            }
            if (Array.isArray(_data["ContentEncoding"])) {
                this.contentEncoding = [] as any;
                for (let item of _data["ContentEncoding"])
                    this.contentEncoding!.push(item);
            }
            if (Array.isArray(_data["ContentLanguage"])) {
                this.contentLanguage = [] as any;
                for (let item of _data["ContentLanguage"])
                    this.contentLanguage!.push(item);
            }
            if (Array.isArray(_data["ContentLocation"])) {
                this.contentLocation = [] as any;
                for (let item of _data["ContentLocation"])
                    this.contentLocation!.push(item);
            }
            if (Array.isArray(_data["ContentMD5"])) {
                this.contentMD5 = [] as any;
                for (let item of _data["ContentMD5"])
                    this.contentMD5!.push(item);
            }
            if (Array.isArray(_data["ContentRange"])) {
                this.contentRange = [] as any;
                for (let item of _data["ContentRange"])
                    this.contentRange!.push(item);
            }
            if (Array.isArray(_data["ContentSecurityPolicy"])) {
                this.contentSecurityPolicy = [] as any;
                for (let item of _data["ContentSecurityPolicy"])
                    this.contentSecurityPolicy!.push(item);
            }
            if (Array.isArray(_data["ContentSecurityPolicyReportOnly"])) {
                this.contentSecurityPolicyReportOnly = [] as any;
                for (let item of _data["ContentSecurityPolicyReportOnly"])
                    this.contentSecurityPolicyReportOnly!.push(item);
            }
            if (Array.isArray(_data["ContentType"])) {
                this.contentType = [] as any;
                for (let item of _data["ContentType"])
                    this.contentType!.push(item);
            }
            if (Array.isArray(_data["CorrelationContext"])) {
                this.correlationContext = [] as any;
                for (let item of _data["CorrelationContext"])
                    this.correlationContext!.push(item);
            }
            if (Array.isArray(_data["Cookie"])) {
                this.cookie = [] as any;
                for (let item of _data["Cookie"])
                    this.cookie!.push(item);
            }
            if (Array.isArray(_data["Date"])) {
                this.date = [] as any;
                for (let item of _data["Date"])
                    this.date!.push(item);
            }
            if (Array.isArray(_data["ETag"])) {
                this.eTag = [] as any;
                for (let item of _data["ETag"])
                    this.eTag!.push(item);
            }
            if (Array.isArray(_data["Expires"])) {
                this.expires = [] as any;
                for (let item of _data["Expires"])
                    this.expires!.push(item);
            }
            if (Array.isArray(_data["Expect"])) {
                this.expect = [] as any;
                for (let item of _data["Expect"])
                    this.expect!.push(item);
            }
            if (Array.isArray(_data["From"])) {
                this.from = [] as any;
                for (let item of _data["From"])
                    this.from!.push(item);
            }
            if (Array.isArray(_data["GrpcAcceptEncoding"])) {
                this.grpcAcceptEncoding = [] as any;
                for (let item of _data["GrpcAcceptEncoding"])
                    this.grpcAcceptEncoding!.push(item);
            }
            if (Array.isArray(_data["GrpcEncoding"])) {
                this.grpcEncoding = [] as any;
                for (let item of _data["GrpcEncoding"])
                    this.grpcEncoding!.push(item);
            }
            if (Array.isArray(_data["GrpcMessage"])) {
                this.grpcMessage = [] as any;
                for (let item of _data["GrpcMessage"])
                    this.grpcMessage!.push(item);
            }
            if (Array.isArray(_data["GrpcStatus"])) {
                this.grpcStatus = [] as any;
                for (let item of _data["GrpcStatus"])
                    this.grpcStatus!.push(item);
            }
            if (Array.isArray(_data["GrpcTimeout"])) {
                this.grpcTimeout = [] as any;
                for (let item of _data["GrpcTimeout"])
                    this.grpcTimeout!.push(item);
            }
            if (Array.isArray(_data["Host"])) {
                this.host = [] as any;
                for (let item of _data["Host"])
                    this.host!.push(item);
            }
            if (Array.isArray(_data["KeepAlive"])) {
                this.keepAlive = [] as any;
                for (let item of _data["KeepAlive"])
                    this.keepAlive!.push(item);
            }
            if (Array.isArray(_data["IfMatch"])) {
                this.ifMatch = [] as any;
                for (let item of _data["IfMatch"])
                    this.ifMatch!.push(item);
            }
            if (Array.isArray(_data["IfModifiedSince"])) {
                this.ifModifiedSince = [] as any;
                for (let item of _data["IfModifiedSince"])
                    this.ifModifiedSince!.push(item);
            }
            if (Array.isArray(_data["IfNoneMatch"])) {
                this.ifNoneMatch = [] as any;
                for (let item of _data["IfNoneMatch"])
                    this.ifNoneMatch!.push(item);
            }
            if (Array.isArray(_data["IfRange"])) {
                this.ifRange = [] as any;
                for (let item of _data["IfRange"])
                    this.ifRange!.push(item);
            }
            if (Array.isArray(_data["IfUnmodifiedSince"])) {
                this.ifUnmodifiedSince = [] as any;
                for (let item of _data["IfUnmodifiedSince"])
                    this.ifUnmodifiedSince!.push(item);
            }
            if (Array.isArray(_data["LastModified"])) {
                this.lastModified = [] as any;
                for (let item of _data["LastModified"])
                    this.lastModified!.push(item);
            }
            if (Array.isArray(_data["Link"])) {
                this.link = [] as any;
                for (let item of _data["Link"])
                    this.link!.push(item);
            }
            if (Array.isArray(_data["Location"])) {
                this.location = [] as any;
                for (let item of _data["Location"])
                    this.location!.push(item);
            }
            if (Array.isArray(_data["MaxForwards"])) {
                this.maxForwards = [] as any;
                for (let item of _data["MaxForwards"])
                    this.maxForwards!.push(item);
            }
            if (Array.isArray(_data["Origin"])) {
                this.origin = [] as any;
                for (let item of _data["Origin"])
                    this.origin!.push(item);
            }
            if (Array.isArray(_data["Pragma"])) {
                this.pragma = [] as any;
                for (let item of _data["Pragma"])
                    this.pragma!.push(item);
            }
            if (Array.isArray(_data["ProxyAuthenticate"])) {
                this.proxyAuthenticate = [] as any;
                for (let item of _data["ProxyAuthenticate"])
                    this.proxyAuthenticate!.push(item);
            }
            if (Array.isArray(_data["ProxyAuthorization"])) {
                this.proxyAuthorization = [] as any;
                for (let item of _data["ProxyAuthorization"])
                    this.proxyAuthorization!.push(item);
            }
            if (Array.isArray(_data["ProxyConnection"])) {
                this.proxyConnection = [] as any;
                for (let item of _data["ProxyConnection"])
                    this.proxyConnection!.push(item);
            }
            if (Array.isArray(_data["Range"])) {
                this.range = [] as any;
                for (let item of _data["Range"])
                    this.range!.push(item);
            }
            if (Array.isArray(_data["Referer"])) {
                this.referer = [] as any;
                for (let item of _data["Referer"])
                    this.referer!.push(item);
            }
            if (Array.isArray(_data["RetryAfter"])) {
                this.retryAfter = [] as any;
                for (let item of _data["RetryAfter"])
                    this.retryAfter!.push(item);
            }
            if (Array.isArray(_data["RequestId"])) {
                this.requestId = [] as any;
                for (let item of _data["RequestId"])
                    this.requestId!.push(item);
            }
            if (Array.isArray(_data["SecWebSocketAccept"])) {
                this.secWebSocketAccept = [] as any;
                for (let item of _data["SecWebSocketAccept"])
                    this.secWebSocketAccept!.push(item);
            }
            if (Array.isArray(_data["SecWebSocketKey"])) {
                this.secWebSocketKey = [] as any;
                for (let item of _data["SecWebSocketKey"])
                    this.secWebSocketKey!.push(item);
            }
            if (Array.isArray(_data["SecWebSocketProtocol"])) {
                this.secWebSocketProtocol = [] as any;
                for (let item of _data["SecWebSocketProtocol"])
                    this.secWebSocketProtocol!.push(item);
            }
            if (Array.isArray(_data["SecWebSocketVersion"])) {
                this.secWebSocketVersion = [] as any;
                for (let item of _data["SecWebSocketVersion"])
                    this.secWebSocketVersion!.push(item);
            }
            if (Array.isArray(_data["SecWebSocketExtensions"])) {
                this.secWebSocketExtensions = [] as any;
                for (let item of _data["SecWebSocketExtensions"])
                    this.secWebSocketExtensions!.push(item);
            }
            if (Array.isArray(_data["Server"])) {
                this.server = [] as any;
                for (let item of _data["Server"])
                    this.server!.push(item);
            }
            if (Array.isArray(_data["SetCookie"])) {
                this.setCookie = [] as any;
                for (let item of _data["SetCookie"])
                    this.setCookie!.push(item);
            }
            if (Array.isArray(_data["StrictTransportSecurity"])) {
                this.strictTransportSecurity = [] as any;
                for (let item of _data["StrictTransportSecurity"])
                    this.strictTransportSecurity!.push(item);
            }
            if (Array.isArray(_data["TE"])) {
                this.tE = [] as any;
                for (let item of _data["TE"])
                    this.tE!.push(item);
            }
            if (Array.isArray(_data["Trailer"])) {
                this.trailer = [] as any;
                for (let item of _data["Trailer"])
                    this.trailer!.push(item);
            }
            if (Array.isArray(_data["TransferEncoding"])) {
                this.transferEncoding = [] as any;
                for (let item of _data["TransferEncoding"])
                    this.transferEncoding!.push(item);
            }
            if (Array.isArray(_data["Translate"])) {
                this.translate = [] as any;
                for (let item of _data["Translate"])
                    this.translate!.push(item);
            }
            if (Array.isArray(_data["TraceParent"])) {
                this.traceParent = [] as any;
                for (let item of _data["TraceParent"])
                    this.traceParent!.push(item);
            }
            if (Array.isArray(_data["TraceState"])) {
                this.traceState = [] as any;
                for (let item of _data["TraceState"])
                    this.traceState!.push(item);
            }
            if (Array.isArray(_data["Upgrade"])) {
                this.upgrade = [] as any;
                for (let item of _data["Upgrade"])
                    this.upgrade!.push(item);
            }
            if (Array.isArray(_data["UpgradeInsecureRequests"])) {
                this.upgradeInsecureRequests = [] as any;
                for (let item of _data["UpgradeInsecureRequests"])
                    this.upgradeInsecureRequests!.push(item);
            }
            if (Array.isArray(_data["UserAgent"])) {
                this.userAgent = [] as any;
                for (let item of _data["UserAgent"])
                    this.userAgent!.push(item);
            }
            if (Array.isArray(_data["Vary"])) {
                this.vary = [] as any;
                for (let item of _data["Vary"])
                    this.vary!.push(item);
            }
            if (Array.isArray(_data["Via"])) {
                this.via = [] as any;
                for (let item of _data["Via"])
                    this.via!.push(item);
            }
            if (Array.isArray(_data["Warning"])) {
                this.warning = [] as any;
                for (let item of _data["Warning"])
                    this.warning!.push(item);
            }
            if (Array.isArray(_data["WebSocketSubProtocols"])) {
                this.webSocketSubProtocols = [] as any;
                for (let item of _data["WebSocketSubProtocols"])
                    this.webSocketSubProtocols!.push(item);
            }
            if (Array.isArray(_data["WWWAuthenticate"])) {
                this.wWWAuthenticate = [] as any;
                for (let item of _data["WWWAuthenticate"])
                    this.wWWAuthenticate!.push(item);
            }
            if (Array.isArray(_data["XContentTypeOptions"])) {
                this.xContentTypeOptions = [] as any;
                for (let item of _data["XContentTypeOptions"])
                    this.xContentTypeOptions!.push(item);
            }
            if (Array.isArray(_data["XFrameOptions"])) {
                this.xFrameOptions = [] as any;
                for (let item of _data["XFrameOptions"])
                    this.xFrameOptions!.push(item);
            }
            if (Array.isArray(_data["XPoweredBy"])) {
                this.xPoweredBy = [] as any;
                for (let item of _data["XPoweredBy"])
                    this.xPoweredBy!.push(item);
            }
            if (Array.isArray(_data["XRequestedWith"])) {
                this.xRequestedWith = [] as any;
                for (let item of _data["XRequestedWith"])
                    this.xRequestedWith!.push(item);
            }
            if (Array.isArray(_data["XUACompatible"])) {
                this.xUACompatible = [] as any;
                for (let item of _data["XUACompatible"])
                    this.xUACompatible!.push(item);
            }
            if (Array.isArray(_data["XXSSProtection"])) {
                this.xXSSProtection = [] as any;
                for (let item of _data["XXSSProtection"])
                    this.xXSSProtection!.push(item);
            }
        }
    }

    static fromJS(data: any): IHeaderDictionary {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IHeaderDictionary' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.item)) {
            data["Item"] = [];
            for (let item of this.item)
                data["Item"].push(item);
        }
        data["ContentLength"] = this.contentLength;
        if (Array.isArray(this.accept)) {
            data["Accept"] = [];
            for (let item of this.accept)
                data["Accept"].push(item);
        }
        if (Array.isArray(this.acceptCharset)) {
            data["AcceptCharset"] = [];
            for (let item of this.acceptCharset)
                data["AcceptCharset"].push(item);
        }
        if (Array.isArray(this.acceptEncoding)) {
            data["AcceptEncoding"] = [];
            for (let item of this.acceptEncoding)
                data["AcceptEncoding"].push(item);
        }
        if (Array.isArray(this.acceptLanguage)) {
            data["AcceptLanguage"] = [];
            for (let item of this.acceptLanguage)
                data["AcceptLanguage"].push(item);
        }
        if (Array.isArray(this.acceptRanges)) {
            data["AcceptRanges"] = [];
            for (let item of this.acceptRanges)
                data["AcceptRanges"].push(item);
        }
        if (Array.isArray(this.accessControlAllowCredentials)) {
            data["AccessControlAllowCredentials"] = [];
            for (let item of this.accessControlAllowCredentials)
                data["AccessControlAllowCredentials"].push(item);
        }
        if (Array.isArray(this.accessControlAllowHeaders)) {
            data["AccessControlAllowHeaders"] = [];
            for (let item of this.accessControlAllowHeaders)
                data["AccessControlAllowHeaders"].push(item);
        }
        if (Array.isArray(this.accessControlAllowMethods)) {
            data["AccessControlAllowMethods"] = [];
            for (let item of this.accessControlAllowMethods)
                data["AccessControlAllowMethods"].push(item);
        }
        if (Array.isArray(this.accessControlAllowOrigin)) {
            data["AccessControlAllowOrigin"] = [];
            for (let item of this.accessControlAllowOrigin)
                data["AccessControlAllowOrigin"].push(item);
        }
        if (Array.isArray(this.accessControlExposeHeaders)) {
            data["AccessControlExposeHeaders"] = [];
            for (let item of this.accessControlExposeHeaders)
                data["AccessControlExposeHeaders"].push(item);
        }
        if (Array.isArray(this.accessControlMaxAge)) {
            data["AccessControlMaxAge"] = [];
            for (let item of this.accessControlMaxAge)
                data["AccessControlMaxAge"].push(item);
        }
        if (Array.isArray(this.accessControlRequestHeaders)) {
            data["AccessControlRequestHeaders"] = [];
            for (let item of this.accessControlRequestHeaders)
                data["AccessControlRequestHeaders"].push(item);
        }
        if (Array.isArray(this.accessControlRequestMethod)) {
            data["AccessControlRequestMethod"] = [];
            for (let item of this.accessControlRequestMethod)
                data["AccessControlRequestMethod"].push(item);
        }
        if (Array.isArray(this.age)) {
            data["Age"] = [];
            for (let item of this.age)
                data["Age"].push(item);
        }
        if (Array.isArray(this.allow)) {
            data["Allow"] = [];
            for (let item of this.allow)
                data["Allow"].push(item);
        }
        if (Array.isArray(this.altSvc)) {
            data["AltSvc"] = [];
            for (let item of this.altSvc)
                data["AltSvc"].push(item);
        }
        if (Array.isArray(this.authorization)) {
            data["Authorization"] = [];
            for (let item of this.authorization)
                data["Authorization"].push(item);
        }
        if (Array.isArray(this.baggage)) {
            data["Baggage"] = [];
            for (let item of this.baggage)
                data["Baggage"].push(item);
        }
        if (Array.isArray(this.cacheControl)) {
            data["CacheControl"] = [];
            for (let item of this.cacheControl)
                data["CacheControl"].push(item);
        }
        if (Array.isArray(this.connection)) {
            data["Connection"] = [];
            for (let item of this.connection)
                data["Connection"].push(item);
        }
        if (Array.isArray(this.contentDisposition)) {
            data["ContentDisposition"] = [];
            for (let item of this.contentDisposition)
                data["ContentDisposition"].push(item);
        }
        if (Array.isArray(this.contentEncoding)) {
            data["ContentEncoding"] = [];
            for (let item of this.contentEncoding)
                data["ContentEncoding"].push(item);
        }
        if (Array.isArray(this.contentLanguage)) {
            data["ContentLanguage"] = [];
            for (let item of this.contentLanguage)
                data["ContentLanguage"].push(item);
        }
        if (Array.isArray(this.contentLocation)) {
            data["ContentLocation"] = [];
            for (let item of this.contentLocation)
                data["ContentLocation"].push(item);
        }
        if (Array.isArray(this.contentMD5)) {
            data["ContentMD5"] = [];
            for (let item of this.contentMD5)
                data["ContentMD5"].push(item);
        }
        if (Array.isArray(this.contentRange)) {
            data["ContentRange"] = [];
            for (let item of this.contentRange)
                data["ContentRange"].push(item);
        }
        if (Array.isArray(this.contentSecurityPolicy)) {
            data["ContentSecurityPolicy"] = [];
            for (let item of this.contentSecurityPolicy)
                data["ContentSecurityPolicy"].push(item);
        }
        if (Array.isArray(this.contentSecurityPolicyReportOnly)) {
            data["ContentSecurityPolicyReportOnly"] = [];
            for (let item of this.contentSecurityPolicyReportOnly)
                data["ContentSecurityPolicyReportOnly"].push(item);
        }
        if (Array.isArray(this.contentType)) {
            data["ContentType"] = [];
            for (let item of this.contentType)
                data["ContentType"].push(item);
        }
        if (Array.isArray(this.correlationContext)) {
            data["CorrelationContext"] = [];
            for (let item of this.correlationContext)
                data["CorrelationContext"].push(item);
        }
        if (Array.isArray(this.cookie)) {
            data["Cookie"] = [];
            for (let item of this.cookie)
                data["Cookie"].push(item);
        }
        if (Array.isArray(this.date)) {
            data["Date"] = [];
            for (let item of this.date)
                data["Date"].push(item);
        }
        if (Array.isArray(this.eTag)) {
            data["ETag"] = [];
            for (let item of this.eTag)
                data["ETag"].push(item);
        }
        if (Array.isArray(this.expires)) {
            data["Expires"] = [];
            for (let item of this.expires)
                data["Expires"].push(item);
        }
        if (Array.isArray(this.expect)) {
            data["Expect"] = [];
            for (let item of this.expect)
                data["Expect"].push(item);
        }
        if (Array.isArray(this.from)) {
            data["From"] = [];
            for (let item of this.from)
                data["From"].push(item);
        }
        if (Array.isArray(this.grpcAcceptEncoding)) {
            data["GrpcAcceptEncoding"] = [];
            for (let item of this.grpcAcceptEncoding)
                data["GrpcAcceptEncoding"].push(item);
        }
        if (Array.isArray(this.grpcEncoding)) {
            data["GrpcEncoding"] = [];
            for (let item of this.grpcEncoding)
                data["GrpcEncoding"].push(item);
        }
        if (Array.isArray(this.grpcMessage)) {
            data["GrpcMessage"] = [];
            for (let item of this.grpcMessage)
                data["GrpcMessage"].push(item);
        }
        if (Array.isArray(this.grpcStatus)) {
            data["GrpcStatus"] = [];
            for (let item of this.grpcStatus)
                data["GrpcStatus"].push(item);
        }
        if (Array.isArray(this.grpcTimeout)) {
            data["GrpcTimeout"] = [];
            for (let item of this.grpcTimeout)
                data["GrpcTimeout"].push(item);
        }
        if (Array.isArray(this.host)) {
            data["Host"] = [];
            for (let item of this.host)
                data["Host"].push(item);
        }
        if (Array.isArray(this.keepAlive)) {
            data["KeepAlive"] = [];
            for (let item of this.keepAlive)
                data["KeepAlive"].push(item);
        }
        if (Array.isArray(this.ifMatch)) {
            data["IfMatch"] = [];
            for (let item of this.ifMatch)
                data["IfMatch"].push(item);
        }
        if (Array.isArray(this.ifModifiedSince)) {
            data["IfModifiedSince"] = [];
            for (let item of this.ifModifiedSince)
                data["IfModifiedSince"].push(item);
        }
        if (Array.isArray(this.ifNoneMatch)) {
            data["IfNoneMatch"] = [];
            for (let item of this.ifNoneMatch)
                data["IfNoneMatch"].push(item);
        }
        if (Array.isArray(this.ifRange)) {
            data["IfRange"] = [];
            for (let item of this.ifRange)
                data["IfRange"].push(item);
        }
        if (Array.isArray(this.ifUnmodifiedSince)) {
            data["IfUnmodifiedSince"] = [];
            for (let item of this.ifUnmodifiedSince)
                data["IfUnmodifiedSince"].push(item);
        }
        if (Array.isArray(this.lastModified)) {
            data["LastModified"] = [];
            for (let item of this.lastModified)
                data["LastModified"].push(item);
        }
        if (Array.isArray(this.link)) {
            data["Link"] = [];
            for (let item of this.link)
                data["Link"].push(item);
        }
        if (Array.isArray(this.location)) {
            data["Location"] = [];
            for (let item of this.location)
                data["Location"].push(item);
        }
        if (Array.isArray(this.maxForwards)) {
            data["MaxForwards"] = [];
            for (let item of this.maxForwards)
                data["MaxForwards"].push(item);
        }
        if (Array.isArray(this.origin)) {
            data["Origin"] = [];
            for (let item of this.origin)
                data["Origin"].push(item);
        }
        if (Array.isArray(this.pragma)) {
            data["Pragma"] = [];
            for (let item of this.pragma)
                data["Pragma"].push(item);
        }
        if (Array.isArray(this.proxyAuthenticate)) {
            data["ProxyAuthenticate"] = [];
            for (let item of this.proxyAuthenticate)
                data["ProxyAuthenticate"].push(item);
        }
        if (Array.isArray(this.proxyAuthorization)) {
            data["ProxyAuthorization"] = [];
            for (let item of this.proxyAuthorization)
                data["ProxyAuthorization"].push(item);
        }
        if (Array.isArray(this.proxyConnection)) {
            data["ProxyConnection"] = [];
            for (let item of this.proxyConnection)
                data["ProxyConnection"].push(item);
        }
        if (Array.isArray(this.range)) {
            data["Range"] = [];
            for (let item of this.range)
                data["Range"].push(item);
        }
        if (Array.isArray(this.referer)) {
            data["Referer"] = [];
            for (let item of this.referer)
                data["Referer"].push(item);
        }
        if (Array.isArray(this.retryAfter)) {
            data["RetryAfter"] = [];
            for (let item of this.retryAfter)
                data["RetryAfter"].push(item);
        }
        if (Array.isArray(this.requestId)) {
            data["RequestId"] = [];
            for (let item of this.requestId)
                data["RequestId"].push(item);
        }
        if (Array.isArray(this.secWebSocketAccept)) {
            data["SecWebSocketAccept"] = [];
            for (let item of this.secWebSocketAccept)
                data["SecWebSocketAccept"].push(item);
        }
        if (Array.isArray(this.secWebSocketKey)) {
            data["SecWebSocketKey"] = [];
            for (let item of this.secWebSocketKey)
                data["SecWebSocketKey"].push(item);
        }
        if (Array.isArray(this.secWebSocketProtocol)) {
            data["SecWebSocketProtocol"] = [];
            for (let item of this.secWebSocketProtocol)
                data["SecWebSocketProtocol"].push(item);
        }
        if (Array.isArray(this.secWebSocketVersion)) {
            data["SecWebSocketVersion"] = [];
            for (let item of this.secWebSocketVersion)
                data["SecWebSocketVersion"].push(item);
        }
        if (Array.isArray(this.secWebSocketExtensions)) {
            data["SecWebSocketExtensions"] = [];
            for (let item of this.secWebSocketExtensions)
                data["SecWebSocketExtensions"].push(item);
        }
        if (Array.isArray(this.server)) {
            data["Server"] = [];
            for (let item of this.server)
                data["Server"].push(item);
        }
        if (Array.isArray(this.setCookie)) {
            data["SetCookie"] = [];
            for (let item of this.setCookie)
                data["SetCookie"].push(item);
        }
        if (Array.isArray(this.strictTransportSecurity)) {
            data["StrictTransportSecurity"] = [];
            for (let item of this.strictTransportSecurity)
                data["StrictTransportSecurity"].push(item);
        }
        if (Array.isArray(this.tE)) {
            data["TE"] = [];
            for (let item of this.tE)
                data["TE"].push(item);
        }
        if (Array.isArray(this.trailer)) {
            data["Trailer"] = [];
            for (let item of this.trailer)
                data["Trailer"].push(item);
        }
        if (Array.isArray(this.transferEncoding)) {
            data["TransferEncoding"] = [];
            for (let item of this.transferEncoding)
                data["TransferEncoding"].push(item);
        }
        if (Array.isArray(this.translate)) {
            data["Translate"] = [];
            for (let item of this.translate)
                data["Translate"].push(item);
        }
        if (Array.isArray(this.traceParent)) {
            data["TraceParent"] = [];
            for (let item of this.traceParent)
                data["TraceParent"].push(item);
        }
        if (Array.isArray(this.traceState)) {
            data["TraceState"] = [];
            for (let item of this.traceState)
                data["TraceState"].push(item);
        }
        if (Array.isArray(this.upgrade)) {
            data["Upgrade"] = [];
            for (let item of this.upgrade)
                data["Upgrade"].push(item);
        }
        if (Array.isArray(this.upgradeInsecureRequests)) {
            data["UpgradeInsecureRequests"] = [];
            for (let item of this.upgradeInsecureRequests)
                data["UpgradeInsecureRequests"].push(item);
        }
        if (Array.isArray(this.userAgent)) {
            data["UserAgent"] = [];
            for (let item of this.userAgent)
                data["UserAgent"].push(item);
        }
        if (Array.isArray(this.vary)) {
            data["Vary"] = [];
            for (let item of this.vary)
                data["Vary"].push(item);
        }
        if (Array.isArray(this.via)) {
            data["Via"] = [];
            for (let item of this.via)
                data["Via"].push(item);
        }
        if (Array.isArray(this.warning)) {
            data["Warning"] = [];
            for (let item of this.warning)
                data["Warning"].push(item);
        }
        if (Array.isArray(this.webSocketSubProtocols)) {
            data["WebSocketSubProtocols"] = [];
            for (let item of this.webSocketSubProtocols)
                data["WebSocketSubProtocols"].push(item);
        }
        if (Array.isArray(this.wWWAuthenticate)) {
            data["WWWAuthenticate"] = [];
            for (let item of this.wWWAuthenticate)
                data["WWWAuthenticate"].push(item);
        }
        if (Array.isArray(this.xContentTypeOptions)) {
            data["XContentTypeOptions"] = [];
            for (let item of this.xContentTypeOptions)
                data["XContentTypeOptions"].push(item);
        }
        if (Array.isArray(this.xFrameOptions)) {
            data["XFrameOptions"] = [];
            for (let item of this.xFrameOptions)
                data["XFrameOptions"].push(item);
        }
        if (Array.isArray(this.xPoweredBy)) {
            data["XPoweredBy"] = [];
            for (let item of this.xPoweredBy)
                data["XPoweredBy"].push(item);
        }
        if (Array.isArray(this.xRequestedWith)) {
            data["XRequestedWith"] = [];
            for (let item of this.xRequestedWith)
                data["XRequestedWith"].push(item);
        }
        if (Array.isArray(this.xUACompatible)) {
            data["XUACompatible"] = [];
            for (let item of this.xUACompatible)
                data["XUACompatible"].push(item);
        }
        if (Array.isArray(this.xXSSProtection)) {
            data["XXSSProtection"] = [];
            for (let item of this.xXSSProtection)
                data["XXSSProtection"].push(item);
        }
        return data;
    }
}

export interface IIHeaderDictionary {
    item?: any[];
    contentLength?: number | undefined;
    accept?: any[];
    acceptCharset?: any[];
    acceptEncoding?: any[];
    acceptLanguage?: any[];
    acceptRanges?: any[];
    accessControlAllowCredentials?: any[];
    accessControlAllowHeaders?: any[];
    accessControlAllowMethods?: any[];
    accessControlAllowOrigin?: any[];
    accessControlExposeHeaders?: any[];
    accessControlMaxAge?: any[];
    accessControlRequestHeaders?: any[];
    accessControlRequestMethod?: any[];
    age?: any[];
    allow?: any[];
    altSvc?: any[];
    authorization?: any[];
    baggage?: any[];
    cacheControl?: any[];
    connection?: any[];
    contentDisposition?: any[];
    contentEncoding?: any[];
    contentLanguage?: any[];
    contentLocation?: any[];
    contentMD5?: any[];
    contentRange?: any[];
    contentSecurityPolicy?: any[];
    contentSecurityPolicyReportOnly?: any[];
    contentType?: any[];
    correlationContext?: any[];
    cookie?: any[];
    date?: any[];
    eTag?: any[];
    expires?: any[];
    expect?: any[];
    from?: any[];
    grpcAcceptEncoding?: any[];
    grpcEncoding?: any[];
    grpcMessage?: any[];
    grpcStatus?: any[];
    grpcTimeout?: any[];
    host?: any[];
    keepAlive?: any[];
    ifMatch?: any[];
    ifModifiedSince?: any[];
    ifNoneMatch?: any[];
    ifRange?: any[];
    ifUnmodifiedSince?: any[];
    lastModified?: any[];
    link?: any[];
    location?: any[];
    maxForwards?: any[];
    origin?: any[];
    pragma?: any[];
    proxyAuthenticate?: any[];
    proxyAuthorization?: any[];
    proxyConnection?: any[];
    range?: any[];
    referer?: any[];
    retryAfter?: any[];
    requestId?: any[];
    secWebSocketAccept?: any[];
    secWebSocketKey?: any[];
    secWebSocketProtocol?: any[];
    secWebSocketVersion?: any[];
    secWebSocketExtensions?: any[];
    server?: any[];
    setCookie?: any[];
    strictTransportSecurity?: any[];
    tE?: any[];
    trailer?: any[];
    transferEncoding?: any[];
    translate?: any[];
    traceParent?: any[];
    traceState?: any[];
    upgrade?: any[];
    upgradeInsecureRequests?: any[];
    userAgent?: any[];
    vary?: any[];
    via?: any[];
    warning?: any[];
    webSocketSubProtocols?: any[];
    wWWAuthenticate?: any[];
    xContentTypeOptions?: any[];
    xFrameOptions?: any[];
    xPoweredBy?: any[];
    xRequestedWith?: any[];
    xUACompatible?: any[];
    xXSSProtection?: any[];
}

/** The request body containing fields that will be assigned to the entry. */
export class FieldToUpdate implements IFieldToUpdate {
    /** The field values that will be assigned to the field. */
    values?: ValueToUpdate[] | undefined;

    
    
    constructor(data?: IFieldToUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(ValueToUpdate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FieldToUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new FieldToUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item.toJSON());
        }
        return data;
    }
}

/** The request body containing fields that will be assigned to the entry. */
export interface IFieldToUpdate {
    /** The field values that will be assigned to the field. */
    values?: ValueToUpdate[] | undefined;
}

export class ValueToUpdate implements IValueToUpdate {
    /** The value assigned to the field at the position specified. */
    value?: string | undefined;
    /** The position of the value in the field. This is 1-indexed for multi value field. It will be ignored for single value field. */
    position?: number;

    
    
    constructor(data?: IValueToUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.position = _data["position"];
        }
    }

    static fromJS(data: any): ValueToUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new ValueToUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["position"] = this.position;
        return data;
    }
}

export interface IValueToUpdate {
    /** The value assigned to the field at the position specified. */
    value?: string | undefined;
    /** The position of the value in the field. This is 1-indexed for multi value field. It will be ignored for single value field. */
    position?: number;
}

export class LinkToUpdate implements ILinkToUpdate {
    /** The id of the link assigned to the entry. */
    linkTypeId?: number;
    /** The id of the other source linked to the entry. */
    otherSourceId?: number;
    /** Whether the entry is the source for the link. */
    isSource?: boolean;

    
    
    constructor(data?: ILinkToUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.linkTypeId = _data["linkTypeId"];
            this.otherSourceId = _data["otherSourceId"];
            this.isSource = _data["isSource"];
        }
    }

    static fromJS(data: any): LinkToUpdate {
        data = typeof data === 'object' ? data : {};
        let result = new LinkToUpdate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["linkTypeId"] = this.linkTypeId;
        data["otherSourceId"] = this.otherSourceId;
        data["isSource"] = this.isSource;
        return data;
    }
}

export interface ILinkToUpdate {
    /** The id of the link assigned to the entry. */
    linkTypeId?: number;
    /** The id of the other source linked to the entry. */
    otherSourceId?: number;
    /** Whether the entry is the source for the link. */
    isSource?: boolean;
}

export class PostEntryWithEdocMetadataRequest implements IPostEntryWithEdocMetadataRequest {
    /** The name of the template assigned to the entry. */
    template?: string | undefined;
    metadata?: PutFieldValsRequest;
    /** The name of the volume to use. Will use the default parent entry volume if not specified. This is ignored in Laserfiche Cloud. */
    volumeName?: string | undefined;

    
    
    constructor(data?: IPostEntryWithEdocMetadataRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.template = _data["template"];
            this.metadata = _data["metadata"] ? PutFieldValsRequest.fromJS(_data["metadata"]) : <any>undefined;
            this.volumeName = _data["volumeName"];
        }
    }

    static fromJS(data: any): PostEntryWithEdocMetadataRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PostEntryWithEdocMetadataRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["template"] = this.template;
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        data["volumeName"] = this.volumeName;
        return data;
    }
}

export interface IPostEntryWithEdocMetadataRequest {
    /** The name of the template assigned to the entry. */
    template?: string | undefined;
    metadata?: PutFieldValsRequest;
    /** The name of the volume to use. Will use the default parent entry volume if not specified. This is ignored in Laserfiche Cloud. */
    volumeName?: string | undefined;
}

export class SimpleImportMetadata implements ISimpleImportMetadata {
    /** The fields that will be assigned to the entry. */
    fields?: { [key: string]: FieldToUpdate; } | undefined;
    /** The tags that will be assigned to the entry. */
    tags?: string[] | undefined;

    
    
    constructor(data?: ISimpleImportMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["fields"]) {
                this.fields = {} as any;
                for (let key in _data["fields"]) {
                    if (_data["fields"].hasOwnProperty(key))
                        (<any>this.fields)![key] = _data["fields"][key] ? FieldToUpdate.fromJS(_data["fields"][key]) : new FieldToUpdate();
                }
            }
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): SimpleImportMetadata {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleImportMetadata();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.fields) {
            data["fields"] = {};
            for (let key in this.fields) {
                if (this.fields.hasOwnProperty(key))
                    (<any>data["fields"])[key] = this.fields[key] ? this.fields[key].toJSON() : <any>undefined;
            }
        }
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }
}

export interface ISimpleImportMetadata {
    /** The fields that will be assigned to the entry. */
    fields?: { [key: string]: FieldToUpdate; } | undefined;
    /** The tags that will be assigned to the entry. */
    tags?: string[] | undefined;
}

/** The request body containing fields that will be assigned to the entry. */
export class PutFieldValsRequest extends SimpleImportMetadata implements IPutFieldValsRequest {
    /** The links that will be assigned to the entry. */
    links?: LinkToUpdate[] | undefined;

    
    
    constructor(data?: IPutFieldValsRequest) {
        super(data);
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(LinkToUpdate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PutFieldValsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PutFieldValsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** The request body containing fields that will be assigned to the entry. */
export interface IPutFieldValsRequest extends ISimpleImportMetadata {
    /** The links that will be assigned to the entry. */
    links?: LinkToUpdate[] | undefined;
}

export class ODataValueOfListOfAttribute implements IODataValueOfListOfAttribute {
    value?: Attribute[];

    
    
    constructor(data?: IODataValueOfListOfAttribute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(Attribute.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ODataValueOfListOfAttribute {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueOfListOfAttribute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

export interface IODataValueOfListOfAttribute {
    value?: Attribute[];
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export class ODataValueContextOfListOfAttribute extends ODataValueOfListOfAttribute implements IODataValueContextOfListOfAttribute {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;

    
    
    constructor(data?: IODataValueContextOfListOfAttribute) {
        super(data);
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.odataNextLink = _data["@odata.nextLink"];
            this.odataCount = _data["@odata.count"];
        }
    }

    static fromJS(data: any): ODataValueContextOfListOfAttribute {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueContextOfListOfAttribute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["@odata.nextLink"] = this.odataNextLink;
        data["@odata.count"] = this.odataCount;
        super.toJSON(data);
        return data;
    }
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export interface IODataValueContextOfListOfAttribute extends IODataValueOfListOfAttribute {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;
}

export class Attribute implements IAttribute {
    key?: string | undefined;
    value?: string | undefined;

    
    
    constructor(data?: IAttribute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Attribute {
        data = typeof data === 'object' ? data : {};
        let result = new Attribute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IAttribute {
    key?: string | undefined;
    value?: string | undefined;
}

export class WFieldInfo implements IWFieldInfo {
    /** The name of the field. */
    name?: string | undefined;
    /** The localized name of the field. */
    displayName?: string | undefined;
    /** The ID of the field. */
    id?: number;
    /** The description of the field. */
    description?: string | undefined;
    /** The type of the field. */
    fieldType?: WFieldType;
    /** The length of the field for variable length data types. */
    length?: number;
    /** The default value of the field for new entries that are assigned
to a template the represented field is a member of. */
    defaultValue?: string | undefined;
    /** A boolean indicating if the represented template field supports multiple values. */
    isMultiValue?: boolean;
    /** A boolean indicating if the represented field must have a value set
on entries assigned to a template that the field is a member of. */
    isRequired?: boolean;
    /** The constraint for values stored in the represented field. */
    constraint?: string | undefined;
    /** The error string that will be returned when the field constraint
is violated when setting a value for this field. */
    constraintError?: string | undefined;
    /** The list of items assigned to the represented field. */
    listValues?: string[] | undefined;
    /** The display format of the represented field. */
    format?: WFieldFormat;
    /** The name of the currency that will be using when formatting
the represented field when the Format property is set to the
Currency member of the WFieldFormat enumeration. */
    currency?: string | undefined;
    /** The custom format pattern for fields that are configured to
use a custom format. */
    formatPattern?: string | undefined;

    
    
    constructor(data?: IWFieldInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.id = _data["id"];
            this.description = _data["description"];
            this.fieldType = _data["fieldType"];
            this.length = _data["length"];
            this.defaultValue = _data["defaultValue"];
            this.isMultiValue = _data["isMultiValue"];
            this.isRequired = _data["isRequired"];
            this.constraint = _data["constraint"];
            this.constraintError = _data["constraintError"];
            if (Array.isArray(_data["listValues"])) {
                this.listValues = [] as any;
                for (let item of _data["listValues"])
                    this.listValues!.push(item);
            }
            this.format = _data["format"];
            this.currency = _data["currency"];
            this.formatPattern = _data["formatPattern"];
        }
    }

    static fromJS(data: any): WFieldInfo {
        data = typeof data === 'object' ? data : {};
        let result = new WFieldInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["id"] = this.id;
        data["description"] = this.description;
        data["fieldType"] = this.fieldType;
        data["length"] = this.length;
        data["defaultValue"] = this.defaultValue;
        data["isMultiValue"] = this.isMultiValue;
        data["isRequired"] = this.isRequired;
        data["constraint"] = this.constraint;
        data["constraintError"] = this.constraintError;
        if (Array.isArray(this.listValues)) {
            data["listValues"] = [];
            for (let item of this.listValues)
                data["listValues"].push(item);
        }
        data["format"] = this.format;
        data["currency"] = this.currency;
        data["formatPattern"] = this.formatPattern;
        return data;
    }
}

export interface IWFieldInfo {
    /** The name of the field. */
    name?: string | undefined;
    /** The localized name of the field. */
    displayName?: string | undefined;
    /** The ID of the field. */
    id?: number;
    /** The description of the field. */
    description?: string | undefined;
    /** The type of the field. */
    fieldType?: WFieldType;
    /** The length of the field for variable length data types. */
    length?: number;
    /** The default value of the field for new entries that are assigned
to a template the represented field is a member of. */
    defaultValue?: string | undefined;
    /** A boolean indicating if the represented template field supports multiple values. */
    isMultiValue?: boolean;
    /** A boolean indicating if the represented field must have a value set
on entries assigned to a template that the field is a member of. */
    isRequired?: boolean;
    /** The constraint for values stored in the represented field. */
    constraint?: string | undefined;
    /** The error string that will be returned when the field constraint
is violated when setting a value for this field. */
    constraintError?: string | undefined;
    /** The list of items assigned to the represented field. */
    listValues?: string[] | undefined;
    /** The display format of the represented field. */
    format?: WFieldFormat;
    /** The name of the currency that will be using when formatting
the represented field when the Format property is set to the
Currency member of the WFieldFormat enumeration. */
    currency?: string | undefined;
    /** The custom format pattern for fields that are configured to
use a custom format. */
    formatPattern?: string | undefined;
}

/** Enumeration of Laserfiche template field types. */
export enum WFieldType {
    DateTime = "DateTime",
    Blob = "Blob",
    Date = "Date",
    ShortInteger = "ShortInteger",
    LongInteger = "LongInteger",
    List = "List",
    Number = "Number",
    String = "String",
    Time = "Time",
}

/** Enumeration of Laserfiche template field formats. */
export enum WFieldFormat {
    None = "None",
    ShortDate = "ShortDate",
    LongDate = "LongDate",
    ShortDateTime = "ShortDateTime",
    LongDateTime = "LongDateTime",
    ShortTime = "ShortTime",
    LongTime = "LongTime",
    GeneralNumber = "GeneralNumber",
    Currency = "Currency",
    Percent = "Percent",
    Scientific = "Scientific",
    Custom = "Custom",
}

export class ODataValueOfIListOfWFieldInfo implements IODataValueOfIListOfWFieldInfo {
    value?: WFieldInfo[];

    
    
    constructor(data?: IODataValueOfIListOfWFieldInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(WFieldInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ODataValueOfIListOfWFieldInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueOfIListOfWFieldInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

export interface IODataValueOfIListOfWFieldInfo {
    value?: WFieldInfo[];
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export class ODataValueContextOfIListOfWFieldInfo extends ODataValueOfIListOfWFieldInfo implements IODataValueContextOfIListOfWFieldInfo {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;

    
    
    constructor(data?: IODataValueContextOfIListOfWFieldInfo) {
        super(data);
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.odataNextLink = _data["@odata.nextLink"];
            this.odataCount = _data["@odata.count"];
        }
    }

    static fromJS(data: any): ODataValueContextOfIListOfWFieldInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueContextOfIListOfWFieldInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["@odata.nextLink"] = this.odataNextLink;
        data["@odata.count"] = this.odataCount;
        super.toJSON(data);
        return data;
    }
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export interface IODataValueContextOfIListOfWFieldInfo extends IODataValueOfIListOfWFieldInfo {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;
}

export class ODataValueOfIListOfEntryLinkTypeInfo implements IODataValueOfIListOfEntryLinkTypeInfo {
    value?: EntryLinkTypeInfo[];

    
    
    constructor(data?: IODataValueOfIListOfEntryLinkTypeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(EntryLinkTypeInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ODataValueOfIListOfEntryLinkTypeInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueOfIListOfEntryLinkTypeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

export interface IODataValueOfIListOfEntryLinkTypeInfo {
    value?: EntryLinkTypeInfo[];
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export class ODataValueContextOfIListOfEntryLinkTypeInfo extends ODataValueOfIListOfEntryLinkTypeInfo implements IODataValueContextOfIListOfEntryLinkTypeInfo {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;

    
    
    constructor(data?: IODataValueContextOfIListOfEntryLinkTypeInfo) {
        super(data);
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.odataNextLink = _data["@odata.nextLink"];
            this.odataCount = _data["@odata.count"];
        }
    }

    static fromJS(data: any): ODataValueContextOfIListOfEntryLinkTypeInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueContextOfIListOfEntryLinkTypeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["@odata.nextLink"] = this.odataNextLink;
        data["@odata.count"] = this.odataCount;
        super.toJSON(data);
        return data;
    }
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export interface IODataValueContextOfIListOfEntryLinkTypeInfo extends IODataValueOfIListOfEntryLinkTypeInfo {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;
}

export class EntryLinkTypeInfo implements IEntryLinkTypeInfo {
    /** The ID of the entry link type. */
    linkTypeId?: number;
    /** The label for the source entry in the link type. */
    sourceLabel?: string | undefined;
    /** The label for the target entry in the link type. */
    targetLabel?: string | undefined;
    /** The description of the link type. */
    linkTypeDescription?: string | undefined;

    
    
    constructor(data?: IEntryLinkTypeInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.linkTypeId = _data["linkTypeId"];
            this.sourceLabel = _data["sourceLabel"];
            this.targetLabel = _data["targetLabel"];
            this.linkTypeDescription = _data["linkTypeDescription"];
        }
    }

    static fromJS(data: any): EntryLinkTypeInfo {
        data = typeof data === 'object' ? data : {};
        let result = new EntryLinkTypeInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["linkTypeId"] = this.linkTypeId;
        data["sourceLabel"] = this.sourceLabel;
        data["targetLabel"] = this.targetLabel;
        data["linkTypeDescription"] = this.linkTypeDescription;
        return data;
    }
}

export interface IEntryLinkTypeInfo {
    /** The ID of the entry link type. */
    linkTypeId?: number;
    /** The label for the source entry in the link type. */
    sourceLabel?: string | undefined;
    /** The label for the target entry in the link type. */
    targetLabel?: string | undefined;
    /** The description of the link type. */
    linkTypeDescription?: string | undefined;
}

export abstract class Entry implements IEntry {
    /** The ID of the entry. */
    id?: number;
    /** The name of the entry. */
    name?: string | undefined;
    /** The ID of the parent entry. */
    parentId?: number | undefined;
    /** The full path in the Laserfiche repository to the entry. */
    fullPath?: string | undefined;
    /** The path in the Laserfiche repository to the parent folder. */
    folderPath?: string | undefined;
    /** The name of the user that created this entry. */
    creator?: string | undefined;
    /** The creation time of the entry. */
    creationTime?: Date;
    /** The last modification time of the entry. */
    lastModifiedTime?: Date;
    /** The type of the entry. */
    entryType?: EntryType;
    /** A boolean indicating if this entry is a container object; it can have other entries as children. */
    isContainer?: boolean;
    /** A boolean indicating if this entry is a leaf object; it cannot have other entries as children. */
    isLeaf?: boolean;
    /** The name of the template assigned to this entry. */
    templateName?: string | undefined;
    /** The id of the template assigned to this entry. */
    templateId?: number;
    /** The names of the fields assigned to the template assigned to this entry. */
    templateFieldNames?: string[] | undefined;
    /** The name of the volume that this entry is associated with. */
    volumeName?: string | undefined;
    /** Row number assigned to this entry in the listing. */
    rowNumber?: number;
    /** The fields assigned to this entry. */
    fields?: EntryFieldValue[] | undefined;
    protected _discriminator: string;

    
    
    constructor(data?: IEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "Entry";
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.parentId = _data["parentId"];
            this.fullPath = _data["fullPath"];
            this.folderPath = _data["folderPath"];
            this.creator = _data["creator"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifiedTime = _data["lastModifiedTime"] ? new Date(_data["lastModifiedTime"].toString()) : <any>undefined;
            this.entryType = _data["entryType"];
            this.isContainer = _data["isContainer"];
            this.isLeaf = _data["isLeaf"];
            this.templateName = _data["templateName"];
            this.templateId = _data["templateId"];
            if (Array.isArray(_data["templateFieldNames"])) {
                this.templateFieldNames = [] as any;
                for (let item of _data["templateFieldNames"])
                    this.templateFieldNames!.push(item);
            }
            this.volumeName = _data["volumeName"];
            this.rowNumber = _data["rowNumber"];
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(EntryFieldValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Entry {
        data = typeof data === 'object' ? data : {};
        if (data["entryType"] === "Document") {
            let result = new Document();
            result.init(data);
            return result;
        }
        if (data["entryType"] === "Shortcut") {
            let result = new Shortcut();
            result.init(data);
            return result;
        }
        if (data["entryType"] === "Folder") {
            let result = new Folder();
            result.init(data);
            return result;
        }
        if (data["entryType"] === "RecordSeries") {
            let result = new RecordSeries();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'Entry' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entryType"] = this._discriminator;
        data["id"] = this.id;
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        data["fullPath"] = this.fullPath;
        data["folderPath"] = this.folderPath;
        data["creator"] = this.creator;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifiedTime"] = this.lastModifiedTime ? this.lastModifiedTime.toISOString() : <any>undefined;
        data["entryType"] = this.entryType;
        data["isContainer"] = this.isContainer;
        data["isLeaf"] = this.isLeaf;
        data["templateName"] = this.templateName;
        data["templateId"] = this.templateId;
        if (Array.isArray(this.templateFieldNames)) {
            data["templateFieldNames"] = [];
            for (let item of this.templateFieldNames)
                data["templateFieldNames"].push(item);
        }
        data["volumeName"] = this.volumeName;
        data["rowNumber"] = this.rowNumber;
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEntry {
    /** The ID of the entry. */
    id?: number;
    /** The name of the entry. */
    name?: string | undefined;
    /** The ID of the parent entry. */
    parentId?: number | undefined;
    /** The full path in the Laserfiche repository to the entry. */
    fullPath?: string | undefined;
    /** The path in the Laserfiche repository to the parent folder. */
    folderPath?: string | undefined;
    /** The name of the user that created this entry. */
    creator?: string | undefined;
    /** The creation time of the entry. */
    creationTime?: Date;
    /** The last modification time of the entry. */
    lastModifiedTime?: Date;
    /** The type of the entry. */
    entryType?: EntryType;
    /** A boolean indicating if this entry is a container object; it can have other entries as children. */
    isContainer?: boolean;
    /** A boolean indicating if this entry is a leaf object; it cannot have other entries as children. */
    isLeaf?: boolean;
    /** The name of the template assigned to this entry. */
    templateName?: string | undefined;
    /** The id of the template assigned to this entry. */
    templateId?: number;
    /** The names of the fields assigned to the template assigned to this entry. */
    templateFieldNames?: string[] | undefined;
    /** The name of the volume that this entry is associated with. */
    volumeName?: string | undefined;
    /** Row number assigned to this entry in the listing. */
    rowNumber?: number;
    /** The fields assigned to this entry. */
    fields?: EntryFieldValue[] | undefined;
}

export enum EntryType {
    Folder = "Folder",
    RecordSeries = "RecordSeries",
    Document = "Document",
    Shortcut = "Shortcut",
}

export class EntryFieldValue implements IEntryFieldValue {
    /** The name of the field. */
    fieldName?: string | undefined;
    /** The values assigned to the field. */
    values?: { [key: string]: any; }[] | undefined;
    /** The type of the field. The possible field types are listed below. */
    fieldType?: WFieldType;
    /** The ID of the field. */
    fieldId?: number;
    /** A boolean indicating if the represented field supports multiple values. */
    isMultiValue?: boolean;
    /** A boolean indicating if the represented field must have a value set on entries assigned to a template that the field is a member of. */
    isRequired?: boolean;
    /** A boolean indicating if there are more field values. */
    hasMoreValues?: boolean;

    
    
    constructor(data?: IEntryFieldValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldName = _data["fieldName"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(item);
            }
            this.fieldType = _data["fieldType"];
            this.fieldId = _data["fieldId"];
            this.isMultiValue = _data["isMultiValue"];
            this.isRequired = _data["isRequired"];
            this.hasMoreValues = _data["hasMoreValues"];
        }
    }

    static fromJS(data: any): EntryFieldValue {
        data = typeof data === 'object' ? data : {};
        let result = new EntryFieldValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        data["fieldType"] = this.fieldType;
        data["fieldId"] = this.fieldId;
        data["isMultiValue"] = this.isMultiValue;
        data["isRequired"] = this.isRequired;
        data["hasMoreValues"] = this.hasMoreValues;
        return data;
    }
}

export interface IEntryFieldValue {
    /** The name of the field. */
    fieldName?: string | undefined;
    /** The values assigned to the field. */
    values?: { [key: string]: any; }[] | undefined;
    /** The type of the field. The possible field types are listed below. */
    fieldType?: WFieldType;
    /** The ID of the field. */
    fieldId?: number;
    /** A boolean indicating if the represented field supports multiple values. */
    isMultiValue?: boolean;
    /** A boolean indicating if the represented field must have a value set on entries assigned to a template that the field is a member of. */
    isRequired?: boolean;
    /** A boolean indicating if there are more field values. */
    hasMoreValues?: boolean;
}

export class RecordSeries extends Entry implements IRecordSeries {

    
    
    constructor(data?: IRecordSeries) {
        super(data);
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "RecordSeries";
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): RecordSeries {
        data = typeof data === 'object' ? data : {};
        let result = new RecordSeries();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IRecordSeries extends IEntry {
}

export class Document extends Entry implements IDocument {
    /** The size of the electronic document attached to the represented document,
if there is one, in bytes. */
    elecDocumentSize?: number;
    /** The extension for the document. */
    extension?: string | undefined;
    /** A boolean indicating if there is an electronic document attached to the represented document. */
    isElectronicDocument?: boolean;
    /** A boolean indicating if the represented document is a record. */
    isRecord?: boolean;
    /** The MIME type of the electronic document. */
    mimeType?: string | undefined;
    /** The page count of the represented document. */
    pageCount?: number;
    /** A boolean indicating if the represented document is checked out. */
    isCheckedOut?: boolean;
    /** A boolean indicating if the represented document is under version control. */
    isUnderVersionControl?: boolean;
    /** The electronic document attached to the represented document. */
    edoc?: Edoc | undefined;

    
    
    constructor(data?: IDocument) {
        super(data);
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "Document";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.elecDocumentSize = _data["elecDocumentSize"];
            this.extension = _data["extension"];
            this.isElectronicDocument = _data["isElectronicDocument"];
            this.isRecord = _data["isRecord"];
            this.mimeType = _data["mimeType"];
            this.pageCount = _data["pageCount"];
            this.isCheckedOut = _data["isCheckedOut"];
            this.isUnderVersionControl = _data["isUnderVersionControl"];
            this.edoc = _data["edoc"] ? Edoc.fromJS(_data["edoc"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Document {
        data = typeof data === 'object' ? data : {};
        let result = new Document();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elecDocumentSize"] = this.elecDocumentSize;
        data["extension"] = this.extension;
        data["isElectronicDocument"] = this.isElectronicDocument;
        data["isRecord"] = this.isRecord;
        data["mimeType"] = this.mimeType;
        data["pageCount"] = this.pageCount;
        data["isCheckedOut"] = this.isCheckedOut;
        data["isUnderVersionControl"] = this.isUnderVersionControl;
        data["edoc"] = this.edoc ? this.edoc.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IDocument extends IEntry {
    /** The size of the electronic document attached to the represented document,
if there is one, in bytes. */
    elecDocumentSize?: number;
    /** The extension for the document. */
    extension?: string | undefined;
    /** A boolean indicating if there is an electronic document attached to the represented document. */
    isElectronicDocument?: boolean;
    /** A boolean indicating if the represented document is a record. */
    isRecord?: boolean;
    /** The MIME type of the electronic document. */
    mimeType?: string | undefined;
    /** The page count of the represented document. */
    pageCount?: number;
    /** A boolean indicating if the represented document is checked out. */
    isCheckedOut?: boolean;
    /** A boolean indicating if the represented document is under version control. */
    isUnderVersionControl?: boolean;
    /** The electronic document attached to the represented document. */
    edoc?: Edoc | undefined;
}

export class Edoc implements IEdoc {

    
    
    constructor(data?: IEdoc) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): Edoc {
        data = typeof data === 'object' ? data : {};
        let result = new Edoc();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IEdoc {
}

export class Shortcut extends Entry implements IShortcut {
    /** The entry ID of the shortcut target. */
    targetId?: number;
    /** The extension of the shortcut target. */
    extension?: string | undefined;
    /** The entry type of the shortcut target. */
    targetType?: EntryType;

    
    
    constructor(data?: IShortcut) {
        super(data);
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "Shortcut";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.targetId = _data["targetId"];
            this.extension = _data["extension"];
            this.targetType = _data["targetType"];
        }
    }

    static fromJS(data: any): Shortcut {
        data = typeof data === 'object' ? data : {};
        let result = new Shortcut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetId"] = this.targetId;
        data["extension"] = this.extension;
        data["targetType"] = this.targetType;
        super.toJSON(data);
        return data;
    }
}

export interface IShortcut extends IEntry {
    /** The entry ID of the shortcut target. */
    targetId?: number;
    /** The extension of the shortcut target. */
    extension?: string | undefined;
    /** The entry type of the shortcut target. */
    targetType?: EntryType;
}

export class Folder extends Entry implements IFolder {
    /** A boolean indicating if the folder that this instance represents is known
to be a record folder. */
    isRecordFolder?: boolean;
    /** A boolean indicating if the folder that this instance represents is known
to directly or indirectly under a record series in the repository. */
    isUnderRecordSeries?: boolean;
    /** The entries in this folder. */
    children?: Entry[] | undefined;

    
    
    constructor(data?: IFolder) {
        super(data);
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "Folder";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.isRecordFolder = _data["isRecordFolder"];
            this.isUnderRecordSeries = _data["isUnderRecordSeries"];
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(Entry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Folder {
        data = typeof data === 'object' ? data : {};
        let result = new Folder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isRecordFolder"] = this.isRecordFolder;
        data["isUnderRecordSeries"] = this.isUnderRecordSeries;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IFolder extends IEntry {
    /** A boolean indicating if the folder that this instance represents is known
to be a record folder. */
    isRecordFolder?: boolean;
    /** A boolean indicating if the folder that this instance represents is known
to directly or indirectly under a record series in the repository. */
    isUnderRecordSeries?: boolean;
    /** The entries in this folder. */
    children?: Entry[] | undefined;
}

export class FindEntryResult implements IFindEntryResult {
    /** The entry found by path. This property is set if entry is found. */
    entry?: Entry | undefined;
    /** The closest entry ancestor. This property is set if entry is not found and fallbackToClosestAncestor is set to true. */
    ancestorEntry?: Entry | undefined;

    
    
    constructor(data?: IFindEntryResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entry = _data["entry"] ? Entry.fromJS(_data["entry"]) : <any>undefined;
            this.ancestorEntry = _data["ancestorEntry"] ? Entry.fromJS(_data["ancestorEntry"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FindEntryResult {
        data = typeof data === 'object' ? data : {};
        let result = new FindEntryResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entry"] = this.entry ? this.entry.toJSON() : <any>undefined;
        data["ancestorEntry"] = this.ancestorEntry ? this.ancestorEntry.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFindEntryResult {
    /** The entry found by path. This property is set if entry is found. */
    entry?: Entry | undefined;
    /** The closest entry ancestor. This property is set if entry is not found and fallbackToClosestAncestor is set to true. */
    ancestorEntry?: Entry | undefined;
}

export class AcceptedOperation implements IAcceptedOperation {
    /** A token that can be used to check on the status of the operation. */
    token?: string | undefined;

    
    
    constructor(data?: IAcceptedOperation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): AcceptedOperation {
        data = typeof data === 'object' ? data : {};
        let result = new AcceptedOperation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data;
    }
}

export interface IAcceptedOperation {
    /** A token that can be used to check on the status of the operation. */
    token?: string | undefined;
}

export class DeleteEntryWithAuditReason implements IDeleteEntryWithAuditReason {
    /** The reason id for this audit event. */
    auditReasonId?: number | undefined;
    /** The comment for this audit event. */
    comment?: string | undefined;

    
    
    constructor(data?: IDeleteEntryWithAuditReason) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.auditReasonId = _data["auditReasonId"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): DeleteEntryWithAuditReason {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteEntryWithAuditReason();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["auditReasonId"] = this.auditReasonId;
        data["comment"] = this.comment;
        return data;
    }
}

export interface IDeleteEntryWithAuditReason {
    /** The reason id for this audit event. */
    auditReasonId?: number | undefined;
    /** The comment for this audit event. */
    comment?: string | undefined;
}

export class PatchEntryRequest implements IPatchEntryRequest {
    /** The ID of the parent entry that the entry will be moved to. */
    parentId?: number | undefined;
    /** The name that will be assigned to the entry. */
    name?: string | undefined;

    
    
    constructor(data?: IPatchEntryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PatchEntryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PatchEntryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["name"] = this.name;
        return data;
    }
}

export interface IPatchEntryRequest {
    /** The ID of the parent entry that the entry will be moved to. */
    parentId?: number | undefined;
    /** The name that will be assigned to the entry. */
    name?: string | undefined;
}

export class ODataValueOfIListOfEntry implements IODataValueOfIListOfEntry {
    value?: Entry[];

    
    
    constructor(data?: IODataValueOfIListOfEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(Entry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ODataValueOfIListOfEntry {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueOfIListOfEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

export interface IODataValueOfIListOfEntry {
    value?: Entry[];
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export class ODataValueContextOfIListOfEntry extends ODataValueOfIListOfEntry implements IODataValueContextOfIListOfEntry {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;

    
    
    constructor(data?: IODataValueContextOfIListOfEntry) {
        super(data);
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.odataNextLink = _data["@odata.nextLink"];
            this.odataCount = _data["@odata.count"];
        }
    }

    static fromJS(data: any): ODataValueContextOfIListOfEntry {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueContextOfIListOfEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["@odata.nextLink"] = this.odataNextLink;
        data["@odata.count"] = this.odataCount;
        super.toJSON(data);
        return data;
    }
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export interface IODataValueContextOfIListOfEntry extends IODataValueOfIListOfEntry {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;
}

export class ODataValueOfIListOfFieldValue implements IODataValueOfIListOfFieldValue {
    value?: FieldValue[];

    
    
    constructor(data?: IODataValueOfIListOfFieldValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(FieldValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ODataValueOfIListOfFieldValue {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueOfIListOfFieldValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

export interface IODataValueOfIListOfFieldValue {
    value?: FieldValue[];
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export class ODataValueContextOfIListOfFieldValue extends ODataValueOfIListOfFieldValue implements IODataValueContextOfIListOfFieldValue {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;

    
    
    constructor(data?: IODataValueContextOfIListOfFieldValue) {
        super(data);
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.odataNextLink = _data["@odata.nextLink"];
            this.odataCount = _data["@odata.count"];
        }
    }

    static fromJS(data: any): ODataValueContextOfIListOfFieldValue {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueContextOfIListOfFieldValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["@odata.nextLink"] = this.odataNextLink;
        data["@odata.count"] = this.odataCount;
        super.toJSON(data);
        return data;
    }
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export interface IODataValueContextOfIListOfFieldValue extends IODataValueOfIListOfFieldValue {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;
}

export class FieldValue extends EntryFieldValue implements IFieldValue {
    /** The group id of the multi value field group. If the field is not a part of a multi value field group, then there is no group id. */
    groupId?: number | undefined;

    
    
    constructor(data?: IFieldValue) {
        super(data);
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.groupId = _data["groupId"];
        }
    }

    static fromJS(data: any): FieldValue {
        data = typeof data === 'object' ? data : {};
        let result = new FieldValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupId"] = this.groupId;
        super.toJSON(data);
        return data;
    }
}

export interface IFieldValue extends IEntryFieldValue {
    /** The group id of the multi value field group. If the field is not a part of a multi value field group, then there is no group id. */
    groupId?: number | undefined;
}

export class ODataValueOfIListOfWTagInfo implements IODataValueOfIListOfWTagInfo {
    value?: WTagInfo[];

    
    
    constructor(data?: IODataValueOfIListOfWTagInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(WTagInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ODataValueOfIListOfWTagInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueOfIListOfWTagInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

export interface IODataValueOfIListOfWTagInfo {
    value?: WTagInfo[];
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export class ODataValueContextOfIListOfWTagInfo extends ODataValueOfIListOfWTagInfo implements IODataValueContextOfIListOfWTagInfo {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;

    
    
    constructor(data?: IODataValueContextOfIListOfWTagInfo) {
        super(data);
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.odataNextLink = _data["@odata.nextLink"];
            this.odataCount = _data["@odata.count"];
        }
    }

    static fromJS(data: any): ODataValueContextOfIListOfWTagInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueContextOfIListOfWTagInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["@odata.nextLink"] = this.odataNextLink;
        data["@odata.count"] = this.odataCount;
        super.toJSON(data);
        return data;
    }
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export interface IODataValueContextOfIListOfWTagInfo extends IODataValueOfIListOfWTagInfo {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;
}

export class WTagInfo implements IWTagInfo {
    /** The ID of the tag definition. */
    id?: number;
    /** The name of the tag definition. */
    name?: string | undefined;
    /** The localized name of the tag definition. */
    displayName?: string | undefined;
    /** The description of the tag definition. */
    description?: string | undefined;
    /** A boolean indicating whether or not the tag definition is classified
as a security tag (true) or an informational tag (false). */
    isSecure?: boolean;
    /** The watermark properties associated with the tag definition. */
    watermark?: Watermark | undefined;

    
    
    constructor(data?: IWTagInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isSecure = _data["isSecure"];
            this.watermark = _data["watermark"] ? Watermark.fromJS(_data["watermark"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WTagInfo {
        data = typeof data === 'object' ? data : {};
        let result = new WTagInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isSecure"] = this.isSecure;
        data["watermark"] = this.watermark ? this.watermark.toJSON() : <any>undefined;
        return data;
    }
}

export interface IWTagInfo {
    /** The ID of the tag definition. */
    id?: number;
    /** The name of the tag definition. */
    name?: string | undefined;
    /** The localized name of the tag definition. */
    displayName?: string | undefined;
    /** The description of the tag definition. */
    description?: string | undefined;
    /** A boolean indicating whether or not the tag definition is classified
as a security tag (true) or an informational tag (false). */
    isSecure?: boolean;
    /** The watermark properties associated with the tag definition. */
    watermark?: Watermark | undefined;
}

export class Watermark implements IWatermark {
    /** The watermark text associated with the tag defintion. */
    watermarkText?: string | undefined;
    /** The size of the watermark text, in points, associated with the tag definition. */
    watermarkTextSize?: number;
    /** The position of the watermark on the page. */
    watermarkPosition?: WatermarkPosition;
    /** The rotation angle, in degrees, of the watermark associated with the tag definition. */
    watermarkRotationAngle?: number;
    /** A boolean indicating whether or not the watermark associated with the tag is mandatory. */
    isWatermarkMandatory?: boolean;
    /** The intensity of the watermark associated with the tag definition. Valid value 
ranges from 0 to 100, with -1 as the default values. */
    watermarkIntensity?: number;

    
    
    constructor(data?: IWatermark) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.watermarkText = _data["watermarkText"];
            this.watermarkTextSize = _data["watermarkTextSize"];
            this.watermarkPosition = _data["watermarkPosition"];
            this.watermarkRotationAngle = _data["watermarkRotationAngle"];
            this.isWatermarkMandatory = _data["isWatermarkMandatory"];
            this.watermarkIntensity = _data["watermarkIntensity"];
        }
    }

    static fromJS(data: any): Watermark {
        data = typeof data === 'object' ? data : {};
        let result = new Watermark();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["watermarkText"] = this.watermarkText;
        data["watermarkTextSize"] = this.watermarkTextSize;
        data["watermarkPosition"] = this.watermarkPosition;
        data["watermarkRotationAngle"] = this.watermarkRotationAngle;
        data["isWatermarkMandatory"] = this.isWatermarkMandatory;
        data["watermarkIntensity"] = this.watermarkIntensity;
        return data;
    }
}

export interface IWatermark {
    /** The watermark text associated with the tag defintion. */
    watermarkText?: string | undefined;
    /** The size of the watermark text, in points, associated with the tag definition. */
    watermarkTextSize?: number;
    /** The position of the watermark on the page. */
    watermarkPosition?: WatermarkPosition;
    /** The rotation angle, in degrees, of the watermark associated with the tag definition. */
    watermarkRotationAngle?: number;
    /** A boolean indicating whether or not the watermark associated with the tag is mandatory. */
    isWatermarkMandatory?: boolean;
    /** The intensity of the watermark associated with the tag definition. Valid value 
ranges from 0 to 100, with -1 as the default values. */
    watermarkIntensity?: number;
}

export enum WatermarkPosition {
    TopLeft = "TopLeft",
    TopCenter = "TopCenter",
    TopRight = "TopRight",
    MiddleLeft = "MiddleLeft",
    DeadCenter = "DeadCenter",
    MiddleRight = "MiddleRight",
    BottomLeft = "BottomLeft",
    BottomCenter = "BottomCenter",
    BottomRight = "BottomRight",
}

export class PutTagRequest implements IPutTagRequest {
    /** The tag names to assign to the entry. */
    tags?: string[] | undefined;

    
    
    constructor(data?: IPutTagRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(item);
            }
        }
    }

    static fromJS(data: any): PutTagRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PutTagRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data;
    }
}

export interface IPutTagRequest {
    /** The tag names to assign to the entry. */
    tags?: string[] | undefined;
}

export class ODataValueOfIListOfWEntryLinkInfo implements IODataValueOfIListOfWEntryLinkInfo {
    value?: WEntryLinkInfo[];

    
    
    constructor(data?: IODataValueOfIListOfWEntryLinkInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(WEntryLinkInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ODataValueOfIListOfWEntryLinkInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueOfIListOfWEntryLinkInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

export interface IODataValueOfIListOfWEntryLinkInfo {
    value?: WEntryLinkInfo[];
}

export class WEntryLinkInfo implements IWEntryLinkInfo {
    /** The ID of the entry link. */
    linkId?: number;
    /** The ID of the source entry of the represented link. */
    sourceId?: number;
    /** The full path to the source entry of the represented link. */
    sourceFullPath?: string | undefined;
    /** The label for the source entry in the link type. */
    sourceLabel?: string | undefined;
    /** The ID of the target entry of the represented link. */
    targetId?: number;
    /** The full path to the target entry of the represented link. */
    targetFullPath?: string | undefined;
    /** The label for the target entry in the link type. */
    targetLabel?: string | undefined;
    /** The descriptive text for the represented entry link. */
    description?: string | undefined;
    /** The description of the link type. */
    linkTypeDescription?: string | undefined;
    /** The ID of the entry link type. */
    linkTypeId?: number;
    /** The properties for the entry link. */
    linkProperties?: { [key: string]: string; } | undefined;
    /** The navigation link to the source entry. */
    sourceLink?: string | undefined;
    /** The navigation link to the target entry. */
    targetLink?: string | undefined;

    
    
    constructor(data?: IWEntryLinkInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.linkId = _data["linkId"];
            this.sourceId = _data["sourceId"];
            this.sourceFullPath = _data["sourceFullPath"];
            this.sourceLabel = _data["sourceLabel"];
            this.targetId = _data["targetId"];
            this.targetFullPath = _data["targetFullPath"];
            this.targetLabel = _data["targetLabel"];
            this.description = _data["description"];
            this.linkTypeDescription = _data["linkTypeDescription"];
            this.linkTypeId = _data["linkTypeId"];
            if (_data["linkProperties"]) {
                this.linkProperties = {} as any;
                for (let key in _data["linkProperties"]) {
                    if (_data["linkProperties"].hasOwnProperty(key))
                        (<any>this.linkProperties)![key] = _data["linkProperties"][key];
                }
            }
            this.sourceLink = _data["sourceLink"];
            this.targetLink = _data["targetLink"];
        }
    }

    static fromJS(data: any): WEntryLinkInfo {
        data = typeof data === 'object' ? data : {};
        let result = new WEntryLinkInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["linkId"] = this.linkId;
        data["sourceId"] = this.sourceId;
        data["sourceFullPath"] = this.sourceFullPath;
        data["sourceLabel"] = this.sourceLabel;
        data["targetId"] = this.targetId;
        data["targetFullPath"] = this.targetFullPath;
        data["targetLabel"] = this.targetLabel;
        data["description"] = this.description;
        data["linkTypeDescription"] = this.linkTypeDescription;
        data["linkTypeId"] = this.linkTypeId;
        if (this.linkProperties) {
            data["linkProperties"] = {};
            for (let key in this.linkProperties) {
                if (this.linkProperties.hasOwnProperty(key))
                    (<any>data["linkProperties"])[key] = this.linkProperties[key];
            }
        }
        data["sourceLink"] = this.sourceLink;
        data["targetLink"] = this.targetLink;
        return data;
    }
}

export interface IWEntryLinkInfo {
    /** The ID of the entry link. */
    linkId?: number;
    /** The ID of the source entry of the represented link. */
    sourceId?: number;
    /** The full path to the source entry of the represented link. */
    sourceFullPath?: string | undefined;
    /** The label for the source entry in the link type. */
    sourceLabel?: string | undefined;
    /** The ID of the target entry of the represented link. */
    targetId?: number;
    /** The full path to the target entry of the represented link. */
    targetFullPath?: string | undefined;
    /** The label for the target entry in the link type. */
    targetLabel?: string | undefined;
    /** The descriptive text for the represented entry link. */
    description?: string | undefined;
    /** The description of the link type. */
    linkTypeDescription?: string | undefined;
    /** The ID of the entry link type. */
    linkTypeId?: number;
    /** The properties for the entry link. */
    linkProperties?: { [key: string]: string; } | undefined;
    /** The navigation link to the source entry. */
    sourceLink?: string | undefined;
    /** The navigation link to the target entry. */
    targetLink?: string | undefined;
}

export class PutLinksRequest implements IPutLinksRequest {
    /** The target entry ID to create a link to. */
    targetId?: number;
    /** The link type ID to create the link with. */
    linkTypeId?: number;
    /** Custom properties (key, value pairs) to be added to the link */
    customProperties?: { [key: string]: string; } | undefined;

    
    
    constructor(data?: IPutLinksRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.targetId = _data["targetId"];
            this.linkTypeId = _data["linkTypeId"];
            if (_data["customProperties"]) {
                this.customProperties = {} as any;
                for (let key in _data["customProperties"]) {
                    if (_data["customProperties"].hasOwnProperty(key))
                        (<any>this.customProperties)![key] = _data["customProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): PutLinksRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PutLinksRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetId"] = this.targetId;
        data["linkTypeId"] = this.linkTypeId;
        if (this.customProperties) {
            data["customProperties"] = {};
            for (let key in this.customProperties) {
                if (this.customProperties.hasOwnProperty(key))
                    (<any>data["customProperties"])[key] = this.customProperties[key];
            }
        }
        return data;
    }
}

export interface IPutLinksRequest {
    /** The target entry ID to create a link to. */
    targetId?: number;
    /** The link type ID to create the link with. */
    linkTypeId?: number;
    /** Custom properties (key, value pairs) to be added to the link */
    customProperties?: { [key: string]: string; } | undefined;
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export class ODataValueContextOfIListOfWEntryLinkInfo extends ODataValueOfIListOfWEntryLinkInfo implements IODataValueContextOfIListOfWEntryLinkInfo {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;

    
    
    constructor(data?: IODataValueContextOfIListOfWEntryLinkInfo) {
        super(data);
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.odataNextLink = _data["@odata.nextLink"];
            this.odataCount = _data["@odata.count"];
        }
    }

    static fromJS(data: any): ODataValueContextOfIListOfWEntryLinkInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueContextOfIListOfWEntryLinkInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["@odata.nextLink"] = this.odataNextLink;
        data["@odata.count"] = this.odataCount;
        super.toJSON(data);
        return data;
    }
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export interface IODataValueContextOfIListOfWEntryLinkInfo extends IODataValueOfIListOfWEntryLinkInfo {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;
}

export class PostEntryChildrenRequest implements IPostEntryChildrenRequest {
    /** The name of the entry. */
    name?: string | undefined;
    /** The type of the entry. */
    entryType?: PostEntryChildrenEntryType | undefined;
    /** The TargetId is only needed for creating a shortcut. This will be the entry ID of the shortcut target. */
    targetId?: number;
    /** The SourceId is needed for some operations that require a source/destination. One example is the Copy operation. */
    sourceId?: number;
    /** The name of the volume to use. Will use the default parent entry volume if not specified. This is ignored in Laserfiche Cloud. */
    volumeName?: string | undefined;

    
    
    constructor(data?: IPostEntryChildrenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.entryType = _data["entryType"];
            this.targetId = _data["targetId"];
            this.sourceId = _data["sourceId"];
            this.volumeName = _data["volumeName"];
        }
    }

    static fromJS(data: any): PostEntryChildrenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PostEntryChildrenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["entryType"] = this.entryType;
        data["targetId"] = this.targetId;
        data["sourceId"] = this.sourceId;
        data["volumeName"] = this.volumeName;
        return data;
    }
}

export interface IPostEntryChildrenRequest {
    /** The name of the entry. */
    name?: string | undefined;
    /** The type of the entry. */
    entryType?: PostEntryChildrenEntryType | undefined;
    /** The TargetId is only needed for creating a shortcut. This will be the entry ID of the shortcut target. */
    targetId?: number;
    /** The SourceId is needed for some operations that require a source/destination. One example is the Copy operation. */
    sourceId?: number;
    /** The name of the volume to use. Will use the default parent entry volume if not specified. This is ignored in Laserfiche Cloud. */
    volumeName?: string | undefined;
}

export enum PostEntryChildrenEntryType {
    Folder = "Folder",
    Shortcut = "Shortcut",
}

export class CopyAsyncRequest implements ICopyAsyncRequest {
    /** The name of the entry. */
    name?: string;
    /** The source entry Id to copy. */
    sourceId?: number;
    /** The name of the volume to use. Will use the default parent entry volume if not specified. This is ignored in Laserfiche Cloud. */
    volumeName?: string | undefined;

    
    
    constructor(data?: ICopyAsyncRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.sourceId = _data["sourceId"];
            this.volumeName = _data["volumeName"];
        }
    }

    static fromJS(data: any): CopyAsyncRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CopyAsyncRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["sourceId"] = this.sourceId;
        data["volumeName"] = this.volumeName;
        return data;
    }
}

export interface ICopyAsyncRequest {
    /** The name of the entry. */
    name?: string;
    /** The source entry Id to copy. */
    sourceId?: number;
    /** The name of the volume to use. Will use the default parent entry volume if not specified. This is ignored in Laserfiche Cloud. */
    volumeName?: string | undefined;
}

export class ODataValueOfBoolean implements IODataValueOfBoolean {
    value?: boolean;

    
    
    constructor(data?: IODataValueOfBoolean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ODataValueOfBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueOfBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data;
    }
}

export interface IODataValueOfBoolean {
    value?: boolean;
}

export class GetEdocWithAuditReasonRequest implements IGetEdocWithAuditReasonRequest {
    /** The reason id for this audit event. */
    auditReasonId?: number | undefined;
    /** The comment for this audit event. */
    comment?: string | undefined;

    
    
    constructor(data?: IGetEdocWithAuditReasonRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.auditReasonId = _data["auditReasonId"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): GetEdocWithAuditReasonRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetEdocWithAuditReasonRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["auditReasonId"] = this.auditReasonId;
        data["comment"] = this.comment;
        return data;
    }
}

export interface IGetEdocWithAuditReasonRequest {
    /** The reason id for this audit event. */
    auditReasonId?: number | undefined;
    /** The comment for this audit event. */
    comment?: string | undefined;
}

export class GetDynamicFieldLogicValueRequest implements IGetDynamicFieldLogicValueRequest {
    /** The template id. */
    templateId?: number;
    /** The dynamic fields. */
    fieldValues?: { [key: string]: string; } | undefined;

    
    
    constructor(data?: IGetDynamicFieldLogicValueRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.templateId = _data["templateId"];
            if (_data["fieldValues"]) {
                this.fieldValues = {} as any;
                for (let key in _data["fieldValues"]) {
                    if (_data["fieldValues"].hasOwnProperty(key))
                        (<any>this.fieldValues)![key] = _data["fieldValues"][key];
                }
            }
        }
    }

    static fromJS(data: any): GetDynamicFieldLogicValueRequest {
        data = typeof data === 'object' ? data : {};
        let result = new GetDynamicFieldLogicValueRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateId"] = this.templateId;
        if (this.fieldValues) {
            data["fieldValues"] = {};
            for (let key in this.fieldValues) {
                if (this.fieldValues.hasOwnProperty(key))
                    (<any>data["fieldValues"])[key] = this.fieldValues[key];
            }
        }
        return data;
    }
}

export interface IGetDynamicFieldLogicValueRequest {
    /** The template id. */
    templateId?: number;
    /** The dynamic fields. */
    fieldValues?: { [key: string]: string; } | undefined;
}

export class PutTemplateRequest implements IPutTemplateRequest {
    /** The template that will be assigned to the entry. */
    templateName?: string | undefined;
    /** The template fields that will be assigned to the entry. */
    fields?: { [key: string]: FieldToUpdate; } | undefined;

    
    
    constructor(data?: IPutTemplateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.templateName = _data["templateName"];
            if (_data["fields"]) {
                this.fields = {} as any;
                for (let key in _data["fields"]) {
                    if (_data["fields"].hasOwnProperty(key))
                        (<any>this.fields)![key] = _data["fields"][key] ? FieldToUpdate.fromJS(_data["fields"][key]) : new FieldToUpdate();
                }
            }
        }
    }

    static fromJS(data: any): PutTemplateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PutTemplateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateName"] = this.templateName;
        if (this.fields) {
            data["fields"] = {};
            for (let key in this.fields) {
                if (this.fields.hasOwnProperty(key))
                    (<any>data["fields"])[key] = this.fields[key] ? this.fields[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IPutTemplateRequest {
    /** The template that will be assigned to the entry. */
    templateName?: string | undefined;
    /** The template fields that will be assigned to the entry. */
    fields?: { [key: string]: FieldToUpdate; } | undefined;
}

export class RepositoryInfo implements IRepositoryInfo {
    /** The repository id. */
    repoId?: string | undefined;
    /** The repository name. */
    repoName?: string | undefined;
    /** The corresponding repository WebClient url. */
    webclientUrl?: string | undefined;

    
    
    constructor(data?: IRepositoryInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.repoId = _data["repoId"];
            this.repoName = _data["repoName"];
            this.webclientUrl = _data["webclientUrl"];
        }
    }

    static fromJS(data: any): RepositoryInfo {
        data = typeof data === 'object' ? data : {};
        let result = new RepositoryInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["repoId"] = this.repoId;
        data["repoName"] = this.repoName;
        data["webclientUrl"] = this.webclientUrl;
        return data;
    }
}

export interface IRepositoryInfo {
    /** The repository id. */
    repoId?: string | undefined;
    /** The repository name. */
    repoName?: string | undefined;
    /** The corresponding repository WebClient url. */
    webclientUrl?: string | undefined;
}

export class AuditReasons implements IAuditReasons {
    /** The audit reasons associated with delete entry. */
    deleteEntry?: WAuditReason[] | undefined;
    /** The audit reasons associated with export document. */
    exportDocument?: WAuditReason[] | undefined;

    
    
    constructor(data?: IAuditReasons) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["deleteEntry"])) {
                this.deleteEntry = [] as any;
                for (let item of _data["deleteEntry"])
                    this.deleteEntry!.push(WAuditReason.fromJS(item));
            }
            if (Array.isArray(_data["exportDocument"])) {
                this.exportDocument = [] as any;
                for (let item of _data["exportDocument"])
                    this.exportDocument!.push(WAuditReason.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AuditReasons {
        data = typeof data === 'object' ? data : {};
        let result = new AuditReasons();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.deleteEntry)) {
            data["deleteEntry"] = [];
            for (let item of this.deleteEntry)
                data["deleteEntry"].push(item.toJSON());
        }
        if (Array.isArray(this.exportDocument)) {
            data["exportDocument"] = [];
            for (let item of this.exportDocument)
                data["exportDocument"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAuditReasons {
    /** The audit reasons associated with delete entry. */
    deleteEntry?: WAuditReason[] | undefined;
    /** The audit reasons associated with export document. */
    exportDocument?: WAuditReason[] | undefined;
}

export class WAuditReason implements IWAuditReason {
    /** The audit reason id. */
    id?: number;
    /** The audit reason text. */
    name?: string | undefined;

    
    
    constructor(data?: IWAuditReason) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): WAuditReason {
        data = typeof data === 'object' ? data : {};
        let result = new WAuditReason();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IWAuditReason {
    /** The audit reason id. */
    id?: number;
    /** The audit reason text. */
    name?: string | undefined;
}

export class AdvancedSearchRequest implements IAdvancedSearchRequest {
    /** Search command for advanced search */
    searchCommand?: string | undefined;
    /** Fuzzy type (None, Percentage, or NumberOfLetters) */
    fuzzyType?: FuzzyType;
    /** Fuzzy factor (percentage as int or int value) */
    fuzzyFactor?: number;

    
    
    constructor(data?: IAdvancedSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchCommand = _data["searchCommand"];
            this.fuzzyType = _data["fuzzyType"];
            this.fuzzyFactor = _data["fuzzyFactor"];
        }
    }

    static fromJS(data: any): AdvancedSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AdvancedSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchCommand"] = this.searchCommand;
        data["fuzzyType"] = this.fuzzyType;
        data["fuzzyFactor"] = this.fuzzyFactor;
        return data;
    }
}

export interface IAdvancedSearchRequest {
    /** Search command for advanced search */
    searchCommand?: string | undefined;
    /** Fuzzy type (None, Percentage, or NumberOfLetters) */
    fuzzyType?: FuzzyType;
    /** Fuzzy factor (percentage as int or int value) */
    fuzzyFactor?: number;
}

export enum FuzzyType {
    None = "None",
    Percentage = "Percentage",
    NumberOfLetters = "NumberOfLetters",
}

export class OperationProgress implements IOperationProgress {
    /** The operation token of the operation associated with this OperationProgress. */
    operationToken?: string | undefined;
    /** The type of the operation associated with this OperationProgress. */
    operationType?: string | undefined;
    /** Determines what percentage of the execution of the associated operation is completed. */
    percentComplete?: number;
    /** The status of the operation associated with this OperationProgress. */
    status?: OperationStatus;
    /** The list of errors occurred during the execution of the associated operation. */
    errors?: OperationErrorItem[] | undefined;
    /** The URI which can be used (via api call) to access the result(s) of the associated operation. */
    redirectUri?: string | undefined;
    /** The ID of the entry affected (e.g. created or modified) by the execution of the associated operation. */
    entryId?: number;
    /** The timestamp representing when the associated operation's execution is started. */
    startTimestamp?: Date;
    /** The timestamp representing the last time when the associated task's status has changed. */
    statusTimestamp?: Date;

    
    
    constructor(data?: IOperationProgress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.operationToken = _data["operationToken"];
            this.operationType = _data["operationType"];
            this.percentComplete = _data["percentComplete"];
            this.status = _data["status"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(OperationErrorItem.fromJS(item));
            }
            this.redirectUri = _data["redirectUri"];
            this.entryId = _data["entryId"];
            this.startTimestamp = _data["startTimestamp"] ? new Date(_data["startTimestamp"].toString()) : <any>undefined;
            this.statusTimestamp = _data["statusTimestamp"] ? new Date(_data["statusTimestamp"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): OperationProgress {
        data = typeof data === 'object' ? data : {};
        let result = new OperationProgress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["operationToken"] = this.operationToken;
        data["operationType"] = this.operationType;
        data["percentComplete"] = this.percentComplete;
        data["status"] = this.status;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["redirectUri"] = this.redirectUri;
        data["entryId"] = this.entryId;
        data["startTimestamp"] = this.startTimestamp ? this.startTimestamp.toISOString() : <any>undefined;
        data["statusTimestamp"] = this.statusTimestamp ? this.statusTimestamp.toISOString() : <any>undefined;
        return data;
    }
}

export interface IOperationProgress {
    /** The operation token of the operation associated with this OperationProgress. */
    operationToken?: string | undefined;
    /** The type of the operation associated with this OperationProgress. */
    operationType?: string | undefined;
    /** Determines what percentage of the execution of the associated operation is completed. */
    percentComplete?: number;
    /** The status of the operation associated with this OperationProgress. */
    status?: OperationStatus;
    /** The list of errors occurred during the execution of the associated operation. */
    errors?: OperationErrorItem[] | undefined;
    /** The URI which can be used (via api call) to access the result(s) of the associated operation. */
    redirectUri?: string | undefined;
    /** The ID of the entry affected (e.g. created or modified) by the execution of the associated operation. */
    entryId?: number;
    /** The timestamp representing when the associated operation's execution is started. */
    startTimestamp?: Date;
    /** The timestamp representing the last time when the associated task's status has changed. */
    statusTimestamp?: Date;
}

export enum OperationStatus {
    NotStarted = "NotStarted",
    InProgress = "InProgress",
    Completed = "Completed",
    Failed = "Failed",
    Cancelled = "Cancelled",
}

export class OperationErrorItem implements IOperationErrorItem {
    /** The ID of the entry to which the error is related.  */
    objectId?: number;
    /** The short description of the error. */
    errorMessage?: string | undefined;

    
    
    constructor(data?: IOperationErrorItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.objectId = _data["objectId"];
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): OperationErrorItem {
        data = typeof data === 'object' ? data : {};
        let result = new OperationErrorItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["objectId"] = this.objectId;
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface IOperationErrorItem {
    /** The ID of the entry to which the error is related.  */
    objectId?: number;
    /** The short description of the error. */
    errorMessage?: string | undefined;
}

export class ODataValueOfIListOfContextHit implements IODataValueOfIListOfContextHit {
    value?: ContextHit[];

    
    
    constructor(data?: IODataValueOfIListOfContextHit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(ContextHit.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ODataValueOfIListOfContextHit {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueOfIListOfContextHit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

export interface IODataValueOfIListOfContextHit {
    value?: ContextHit[];
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export class ODataValueContextOfIListOfContextHit extends ODataValueOfIListOfContextHit implements IODataValueContextOfIListOfContextHit {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;

    
    
    constructor(data?: IODataValueContextOfIListOfContextHit) {
        super(data);
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.odataNextLink = _data["@odata.nextLink"];
            this.odataCount = _data["@odata.count"];
        }
    }

    static fromJS(data: any): ODataValueContextOfIListOfContextHit {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueContextOfIListOfContextHit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["@odata.nextLink"] = this.odataNextLink;
        data["@odata.count"] = this.odataCount;
        super.toJSON(data);
        return data;
    }
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export interface IODataValueContextOfIListOfContextHit extends IODataValueOfIListOfContextHit {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;
}

export class ContextHit implements IContextHit {
    hitType?: HitType;
    /** A boolean indicating if this context hit occurs on an annotation. */
    isAnnotationHit?: boolean;
    /** The ID of the annotation that the context hit is in. */
    annotationId?: number;
    /** The page number in the document of the search hit's context. */
    pageNumber?: number;
    /** The offset from the beginning of the page of the starting character of the search hit's context line. */
    pageOffset?: number;
    /** The line of context for the search hit. */
    context?: string | undefined;
    /** The character offset from the beginning of the context line of the start of the first highlight. */
    highlight1Offset?: number;
    /** The length of the first highlight in characters. */
    highlight1Length?: number;
    /** The character offset from the beginning of the context line of the start of the second highlight. */
    highlight2Offset?: number;
    /** The length of the second highlight in characters. */
    highlight2Length?: number;
    /** The number of words in the context hit. */
    hitWidth?: number;
    /** The number of hits in the electronic document. */
    edocHitCount?: number;
    /** The number of hits in the template. */
    fieldHitCount?: number;
    /** The name of a template field containing the hit. */
    fieldName?: string | undefined;
    /** The hit number. */
    hitNumber?: number;

    
    
    constructor(data?: IContextHit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hitType = _data["hitType"];
            this.isAnnotationHit = _data["isAnnotationHit"];
            this.annotationId = _data["annotationId"];
            this.pageNumber = _data["pageNumber"];
            this.pageOffset = _data["pageOffset"];
            this.context = _data["context"];
            this.highlight1Offset = _data["highlight1Offset"];
            this.highlight1Length = _data["highlight1Length"];
            this.highlight2Offset = _data["highlight2Offset"];
            this.highlight2Length = _data["highlight2Length"];
            this.hitWidth = _data["hitWidth"];
            this.edocHitCount = _data["edocHitCount"];
            this.fieldHitCount = _data["fieldHitCount"];
            this.fieldName = _data["fieldName"];
            this.hitNumber = _data["hitNumber"];
        }
    }

    static fromJS(data: any): ContextHit {
        data = typeof data === 'object' ? data : {};
        let result = new ContextHit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hitType"] = this.hitType;
        data["isAnnotationHit"] = this.isAnnotationHit;
        data["annotationId"] = this.annotationId;
        data["pageNumber"] = this.pageNumber;
        data["pageOffset"] = this.pageOffset;
        data["context"] = this.context;
        data["highlight1Offset"] = this.highlight1Offset;
        data["highlight1Length"] = this.highlight1Length;
        data["highlight2Offset"] = this.highlight2Offset;
        data["highlight2Length"] = this.highlight2Length;
        data["hitWidth"] = this.hitWidth;
        data["edocHitCount"] = this.edocHitCount;
        data["fieldHitCount"] = this.fieldHitCount;
        data["fieldName"] = this.fieldName;
        data["hitNumber"] = this.hitNumber;
        return data;
    }
}

export interface IContextHit {
    hitType?: HitType;
    /** A boolean indicating if this context hit occurs on an annotation. */
    isAnnotationHit?: boolean;
    /** The ID of the annotation that the context hit is in. */
    annotationId?: number;
    /** The page number in the document of the search hit's context. */
    pageNumber?: number;
    /** The offset from the beginning of the page of the starting character of the search hit's context line. */
    pageOffset?: number;
    /** The line of context for the search hit. */
    context?: string | undefined;
    /** The character offset from the beginning of the context line of the start of the first highlight. */
    highlight1Offset?: number;
    /** The length of the first highlight in characters. */
    highlight1Length?: number;
    /** The character offset from the beginning of the context line of the start of the second highlight. */
    highlight2Offset?: number;
    /** The length of the second highlight in characters. */
    highlight2Length?: number;
    /** The number of words in the context hit. */
    hitWidth?: number;
    /** The number of hits in the electronic document. */
    edocHitCount?: number;
    /** The number of hits in the template. */
    fieldHitCount?: number;
    /** The name of a template field containing the hit. */
    fieldName?: string | undefined;
    /** The hit number. */
    hitNumber?: number;
}

/** The type of context hit. */
export enum HitType {
    PageContent = "PageContent",
    Note = "Note",
    Callout = "Callout",
    TextBox = "TextBox",
    Edoc = "Edoc",
    Prop = "Prop",
    Name = "Name",
    Extension = "Extension",
    VersionGroupNote = "VersionGroupNote",
    VersionComment = "VersionComment",
    Field = "Field",
    SignatureComment = "SignatureComment",
    CertificateSubject = "CertificateSubject",
    TagComment = "TagComment",
    AnnotationComment = "AnnotationComment",
    Attachment = "Attachment",
}

export class SimpleSearchRequest implements ISimpleSearchRequest {
    /** Search command for simple search */
    searchCommand?: string | undefined;

    
    
    constructor(data?: ISimpleSearchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.searchCommand = _data["searchCommand"];
        }
    }

    static fromJS(data: any): SimpleSearchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleSearchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["searchCommand"] = this.searchCommand;
        return data;
    }
}

export interface ISimpleSearchRequest {
    /** Search command for simple search */
    searchCommand?: string | undefined;
}

export class ODataValueOfIListOfWTemplateInfo implements IODataValueOfIListOfWTemplateInfo {
    value?: WTemplateInfo[];

    
    
    constructor(data?: IODataValueOfIListOfWTemplateInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(WTemplateInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ODataValueOfIListOfWTemplateInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueOfIListOfWTemplateInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

export interface IODataValueOfIListOfWTemplateInfo {
    value?: WTemplateInfo[];
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export class ODataValueContextOfIListOfWTemplateInfo extends ODataValueOfIListOfWTemplateInfo implements IODataValueContextOfIListOfWTemplateInfo {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;

    
    
    constructor(data?: IODataValueContextOfIListOfWTemplateInfo) {
        super(data);
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.odataNextLink = _data["@odata.nextLink"];
            this.odataCount = _data["@odata.count"];
        }
    }

    static fromJS(data: any): ODataValueContextOfIListOfWTemplateInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueContextOfIListOfWTemplateInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["@odata.nextLink"] = this.odataNextLink;
        data["@odata.count"] = this.odataCount;
        super.toJSON(data);
        return data;
    }
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export interface IODataValueContextOfIListOfWTemplateInfo extends IODataValueOfIListOfWTemplateInfo {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;
}

export class WTemplateInfo implements IWTemplateInfo {
    /** The ID of the template definition. */
    id?: number;
    /** The name of the template definition. */
    name?: string | undefined;
    /** The localized name of the template definition. */
    displayName?: string | undefined;
    /** The description of the template definition. */
    description?: string | undefined;
    /** The color assigned to the template definition. */
    color?: LFColor | undefined;
    /** The number of fields assigned to the template. */
    fieldCount?: number;

    
    
    constructor(data?: IWTemplateInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.color = _data["color"] ? LFColor.fromJS(_data["color"]) : <any>undefined;
            this.fieldCount = _data["fieldCount"];
        }
    }

    static fromJS(data: any): WTemplateInfo {
        data = typeof data === 'object' ? data : {};
        let result = new WTemplateInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["color"] = this.color ? this.color.toJSON() : <any>undefined;
        data["fieldCount"] = this.fieldCount;
        return data;
    }
}

export interface IWTemplateInfo {
    /** The ID of the template definition. */
    id?: number;
    /** The name of the template definition. */
    name?: string | undefined;
    /** The localized name of the template definition. */
    displayName?: string | undefined;
    /** The description of the template definition. */
    description?: string | undefined;
    /** The color assigned to the template definition. */
    color?: LFColor | undefined;
    /** The number of fields assigned to the template. */
    fieldCount?: number;
}

export class LFColor implements ILFColor {
    a?: number;
    r?: number;
    g?: number;
    b?: number;

    
    
    constructor(data?: ILFColor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.a = _data["a"];
            this.r = _data["r"];
            this.g = _data["g"];
            this.b = _data["b"];
        }
    }

    static fromJS(data: any): LFColor {
        data = typeof data === 'object' ? data : {};
        let result = new LFColor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["a"] = this.a;
        data["r"] = this.r;
        data["g"] = this.g;
        data["b"] = this.b;
        return data;
    }
}

export interface ILFColor {
    a?: number;
    r?: number;
    g?: number;
    b?: number;
}

export class ODataValueOfIListOfTemplateFieldInfo implements IODataValueOfIListOfTemplateFieldInfo {
    value?: TemplateFieldInfo[];

    
    
    constructor(data?: IODataValueOfIListOfTemplateFieldInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(TemplateFieldInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ODataValueOfIListOfTemplateFieldInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueOfIListOfTemplateFieldInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        return data;
    }
}

export interface IODataValueOfIListOfTemplateFieldInfo {
    value?: TemplateFieldInfo[];
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export class ODataValueContextOfIListOfTemplateFieldInfo extends ODataValueOfIListOfTemplateFieldInfo implements IODataValueContextOfIListOfTemplateFieldInfo {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;

    
    
    constructor(data?: IODataValueContextOfIListOfTemplateFieldInfo) {
        super(data);
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.odataNextLink = _data["@odata.nextLink"];
            this.odataCount = _data["@odata.count"];
        }
    }

    static fromJS(data: any): ODataValueContextOfIListOfTemplateFieldInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueContextOfIListOfTemplateFieldInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["@odata.nextLink"] = this.odataNextLink;
        data["@odata.count"] = this.odataCount;
        super.toJSON(data);
        return data;
    }
}

/** A wrapper around the ODataValue with extra odata.nextLink and odata.count. */
export interface IODataValueContextOfIListOfTemplateFieldInfo extends IODataValueOfIListOfTemplateFieldInfo {
    /** It contains a URL that allows retrieving the next subset of the requested collection. */
    odataNextLink?: string | undefined;
    /** It contains the count of a collection of entities or a collection of entity references. */
    odataCount?: number;
}

export class TemplateFieldInfo extends WFieldInfo implements ITemplateFieldInfo {
    /** A form logic rule associated with a Laserfiche template and field definition. */
    rule?: Rule | undefined;
    /** The group id of the field in the template. */
    groupId?: number;
    /** The name of field group. */
    groupName?: string | undefined;

    
    
    constructor(data?: ITemplateFieldInfo) {
        super(data);
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.rule = _data["rule"] ? Rule.fromJS(_data["rule"]) : <any>undefined;
            this.groupId = _data["groupId"];
            this.groupName = _data["groupName"];
        }
    }

    static fromJS(data: any): TemplateFieldInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateFieldInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rule"] = this.rule ? this.rule.toJSON() : <any>undefined;
        data["groupId"] = this.groupId;
        data["groupName"] = this.groupName;
        super.toJSON(data);
        return data;
    }
}

export interface ITemplateFieldInfo extends IWFieldInfo {
    /** A form logic rule associated with a Laserfiche template and field definition. */
    rule?: Rule | undefined;
    /** The group id of the field in the template. */
    groupId?: number;
    /** The name of field group. */
    groupName?: string | undefined;
}

export class Rule implements IRule {
    /** The IDs of the parent fields in the template according to the
form logic rule. */
    ancestors?: number[] | undefined;

    
    
    constructor(data?: IRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ancestors"])) {
                this.ancestors = [] as any;
                for (let item of _data["ancestors"])
                    this.ancestors!.push(item);
            }
        }
    }

    static fromJS(data: any): Rule {
        data = typeof data === 'object' ? data : {};
        let result = new Rule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ancestors)) {
            data["ancestors"] = [];
            for (let item of this.ancestors)
                data["ancestors"].push(item);
        }
        return data;
    }
}

export interface IRule {
    /** The IDs of the parent fields in the template according to the
form logic rule. */
    ancestors?: number[] | undefined;
}

export class ODataValueOfDateTime implements IODataValueOfDateTime {
    value?: Date;

    
    
    constructor(data?: IODataValueOfDateTime) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"] ? new Date(_data["value"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ODataValueOfDateTime {
        data = typeof data === 'object' ? data : {};
        let result = new ODataValueOfDateTime();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toISOString() : <any>undefined;
        return data;
    }
}

export interface IODataValueOfDateTime {
    value?: Date;
}

export class HttpResponseHead<TResult> {
    status: number;
    headers: { [key: string]: any; };
    result: TResult;

    constructor(status: number, headers: { [key: string]: any; }, result: TResult)
    {
        this.status = status;
        this.headers = headers;
        this.result = result;
    }
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiExceptionDummy extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiExceptionDummy = true;

    static isApiExceptionDummy(obj: any): obj is ApiExceptionDummy {
        return obj.isApiExceptionDummy === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    throw new ApiException(message, status, response, headers, result);
}

class ClientBase {}
export interface IRepositoryApiClient {
  attributesClient: IAttributesClient;
  auditReasonsClient: IAuditReasonsClient;
  entriesClient: IEntriesClient;
  fieldDefinitionsClient: IFieldDefinitionsClient;
  repositoriesClient: IRepositoriesClient;
  searchesClient: ISearchesClient;
  serverSessionClient: IServerSessionClient;
  simpleSearchesClient: ISimpleSearchesClient;
  tagDefinitionsClient: ITagDefinitionsClient;
  tasksClient: ITasksClient;
  templateDefinitionsClient: ITemplateDefinitionsClient;
  linkDefinitionsClient: ILinkDefinitionsClient;
  defaultRequestHeaders: Record<string, string>;
}

// @ts-ignore
export class RepositoryApiClient implements IRepositoryApiClient {
  private baseUrl: string;

  public attributesClient: IAttributesClient;
  public auditReasonsClient: IAuditReasonsClient;
  public entriesClient: IEntriesClient;
  public fieldDefinitionsClient: IFieldDefinitionsClient;
  public repositoriesClient: IRepositoriesClient;
  public searchesClient: ISearchesClient;
  public serverSessionClient: IServerSessionClient;
  public simpleSearchesClient: ISimpleSearchesClient;
  public tagDefinitionsClient: ITagDefinitionsClient;
  public tasksClient: ITasksClient;
  public templateDefinitionsClient: ITemplateDefinitionsClient;
  public linkDefinitionsClient: ILinkDefinitionsClient;

  private repoClientHandler: RepositoryApiClientHttpHandler;

  /**
   * Get the headers which will be sent with each request.
   */
  public get defaultRequestHeaders(): Record<string, string> {
    return this.repoClientHandler.defaultRequestHeaders;
  }

  /**
   * Set the headers which will be sent with each request.
   */
  public set defaultRequestHeaders(headers: Record<string, string>) {
    this.repoClientHandler.defaultRequestHeaders = headers;
  }

  private constructor(httpRequestHandler: HttpRequestHandler, baseUrlDebug?: string) {
    this.repoClientHandler = new RepositoryApiClientHttpHandler(httpRequestHandler);
    let fetch = this.repoClientHandler.httpHandler;
    fetch = fetch.bind(this.repoClientHandler);
    let http = {
      fetch,
    };
    this.baseUrl = baseUrlDebug ?? '';
    this.attributesClient = new AttributesClient(this.baseUrl, http);
    this.auditReasonsClient = new AuditReasonsClient(this.baseUrl, http);
    this.entriesClient = new EntriesClient(this.baseUrl, http);
    this.fieldDefinitionsClient = new FieldDefinitionsClient(this.baseUrl, http);
    this.repositoriesClient = new RepositoriesClient(this.baseUrl, http);
    this.searchesClient = new SearchesClient(this.baseUrl, http);
    this.serverSessionClient = new ServerSessionClient(this.baseUrl, http);
    this.simpleSearchesClient = new SimpleSearchesClient(this.baseUrl, http);
    this.tagDefinitionsClient = new TagDefinitionsClient(this.baseUrl, http);
    this.tasksClient = new TasksClient(this.baseUrl, http);
    this.templateDefinitionsClient = new TemplateDefinitionsClient(this.baseUrl, http);
    this.linkDefinitionsClient = new LinkDefinitionsClient(this.baseUrl, http);
  }

  /**
   * Create a Laserfiche repository client.
   * @param httpRequestHandler The http request handler for the Laserfiche repository client.
   * @param baseUrlDebug (optional) override for the Laserfiche repository API base url.
   */
  public static createFromHttpRequestHandler(
    httpRequestHandler: HttpRequestHandler,
    baseUrlDebug?: string
  ): RepositoryApiClient {
    if (!httpRequestHandler) throw new Error('Argument cannot be null: httpRequestHandler');
    const repoClient = new RepositoryApiClient(httpRequestHandler, baseUrlDebug);
    return repoClient;
  }

  /**
   * Create a Laserfiche repository client that will use Laserfiche Cloud OAuth client credentials to get access tokens.
   * @param servicePrincipalKey The service principal key created for the service principal from the Laserfiche Account Administration.
   * @param accessKey The access key exported from the Laserfiche Developer Console.
   * @param scope (optional) The requested space-delimited scopes for the access token.
   * @param baseUrlDebug (optional) override for the Laserfiche repository API base url.
   */
  public static createFromAccessKey(
    servicePrincipalKey: string,
    accessKey: AccessKey,
    scope?: string,
    baseUrlDebug?: string
  ): RepositoryApiClient {
    const handler = new OAuthClientCredentialsHandler(servicePrincipalKey, accessKey, scope);
    return RepositoryApiClient.createFromHttpRequestHandler(handler, baseUrlDebug);
  }

  /**
   * Create a Laserfiche repository client that will use username and password to get access tokens for Laserfiche API. Password credentials grant type is implemented by the Laserfiche Self-Hosted API server. Not available in cloud.
   * @param repositoryId The repository ID
   * @param username The username
   * @param password The password
   * @param baseUrl API server base URL e.g., https://{APIServerName}/LFRepositoryAPI
   */
  public static createFromUsernamePassword(
    repositoryId: string,
    username: string,
    password: string,
    baseUrl: string
  ): RepositoryApiClient {
    const baseUrlWithoutSlash: string = StringUtils.trimEnd(baseUrl, '/');
    const handler = new UsernamePasswordHandler(repositoryId, username, password, baseUrlWithoutSlash, undefined);
    return new RepositoryApiClient(handler, baseUrlWithoutSlash);
  }
}
/** @internal */
export class RepositoryApiClientHttpHandler { 
  private _httpRequestHandler: HttpRequestHandler;
  public defaultRequestHeaders: Record<string, string>;

  constructor(httpRequestHandler: HttpRequestHandler) {
    this._httpRequestHandler = httpRequestHandler;
    this.defaultRequestHeaders = {};
  }

  public async httpHandler(url: string, init: RequestInit): Promise<Response> {
    const maxRetries = 1;
    let retryCount = 0;
    let shouldRetry = true;

    if (this.defaultRequestHeaders) {
      init.headers = Object.assign({}, this.defaultRequestHeaders, init.headers);
    }
    let response: Response | undefined;
    while (retryCount <= maxRetries && shouldRetry) {
      const beforeSendResult = await this._httpRequestHandler.beforeFetchRequestAsync(url, init);
      let absoluteUrl: string;
      if (url.startsWith('http')) {
        absoluteUrl = url;
      } else {
        const apiBasedAddress = DomainUtils.getRepositoryEndpoint(beforeSendResult.regionalDomain);
        absoluteUrl = UrlUtils.combineURLs(apiBasedAddress, url);
      }

      try {
        response = await fetch(absoluteUrl, init);
        shouldRetry =
          (await this._httpRequestHandler.afterFetchResponseAsync(absoluteUrl, response, init)) ||
          isRetryable(response, init);
        if (!shouldRetry) {
          return response;
        }
      } catch (err) {
        if (retryCount >= maxRetries) {
          throw err;
        }
        shouldRetry = true;
        console.warn(`Retrying fetch due to exception: ${err}`);
      } finally {
        retryCount++;
      }
    }
    if (!response) {
      throw new Error('Undefined response, there is a bug!');
    }
    return response;
  }
}

function isRetryable(response: Response, init: RequestInit): boolean {
  const isIdempotent = init.method != 'POST';
  return (response.status >= 500 || response.status == 408) && isIdempotent;
}

async function getNextLinkListing<T>(
  http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> },
  processListing: (response: Response) => Promise<T>,
  nextLink: string,
  maxPageSize?: number
): Promise<T> {
  if (!nextLink) {
    throw new Error('Next Link is undefined');
  }
  const prefer = createMaxPageSizePreferHeaderPayload(maxPageSize);
  const options_ = <RequestInit>{
    method: 'GET',
    headers: {
      Prefer: prefer !== undefined && prefer !== null ? prefer : '',
      Accept: 'application/json',
    },
  };
  const processListingTwo = processListing.bind(http);

  const resp = await http.fetch(nextLink, options_);
  return await processListingTwo(resp);
}

function createMaxPageSizePreferHeaderPayload(maxSize?: number): string | undefined {
  //puts the max size into the prefer header of the GET request
  if (!maxSize) {
    return undefined;
  } else {
    return `maxpagesize=${maxSize}`;
  }
}

export interface IAttributesClient {
  /**
   * It will continue to make the same call to get a list of attributes key value pairs of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repoId The requested repository ID.
   * @param args.everyone (optional) Boolean value that indicates whether to return attributes key value pairs associated with everyone or the currently authenticated user.
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of attributes key value pairs allowed per API response schema
   */
  getTrusteeAttributeKeyValuePairsForEach(args: {
    callback: (response: ODataValueContextOfListOfAttribute) => Promise<boolean>;
    repoId: string;
    everyone?: boolean;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;

  /**
   * Returns the attribute key value pairs using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of attribute keys allowed per API response schema
   * @return Get trustee attribute keys with the next link successfully
   */
  getTrusteeAttributeKeyValuePairsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfListOfAttribute>;
}

export interface IEntriesClient {
  /**
   * It will continue to make the same call to get a list of entry listings of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repoId The requested repository ID.
   * @param args.entryId The requested entry ID.
   * @param args.groupByEntryType (optional) An optional query parameter used to indicate if the result should be grouped by entry type or not.
   * @param args.fields (optional) Optional array of field names. Field values corresponding to the given field names will be returned for each entry.
   * @param args.formatFields (optional) Boolean for if field values should be formatted. Only applicable if Fields are specified.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
          The value should be a standard language tag. The formatFields query parameter must be set to true, otherwise
          culture will not be used for formatting. 
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of entry listings allowed per API response schema.
   */
  getEntryListingForEach(args: {
    callback: (response: ODataValueContextOfIListOfEntry) => Promise<boolean>;
    repoId: string;
    entryId: number;
    groupByEntryType?: boolean;
    fields?: string[];
    formatFields?: boolean;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;
  /**
   * It will continue to make the same call to get a list of field values of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repoId The requested repository ID.
   * @param args.entryId The requested entry ID.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.formatValue (optional) An optional query parameter used to indicate if the field values should be formatted.
          The default value is false. 
   * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
          The value should be a standard language tag. The formatFields query parameter must be set to true, otherwise
          culture will not be used for formatting. 
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of field values allowed per API response schema.
   */
  getFieldValuesForEach(args: {
    callback: (response: ODataValueContextOfIListOfFieldValue) => Promise<boolean>;
    repoId: string;
    entryId: number;
    prefer?: string;
    formatValue?: boolean;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;
  /**
   * It will continue to make the same call to get a list of link values from entry of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repoId The requested repository ID.
   * @param args.entryId The requested entry ID.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of link values from entry allowed per API response schema.
   */
  getLinkValuesFromEntryForEach(args: {
    callback: (response: ODataValueContextOfIListOfWEntryLinkInfo) => Promise<boolean>;
    repoId: string;
    entryId: number;
    prefer?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;
  /**
   * It will continue to make the same call to get a list of tags assigned to entry of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repoId The requested repository ID.
   * @param args.entryId The requested entry ID.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of tags assigned to entry allowed per API response schema.
   */
  getTagsAssignedToEntryForEach(args: {
    callback: (response: ODataValueContextOfIListOfWTagInfo) => Promise<boolean>;
    repoId: string;
    entryId: number;
    prefer?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;
  /**
   * Returns the children entries of a folder in the repository using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of entry listings allowed per API response schema
   * @return Get the children entries of a Folder with the next link successfully
   */
  getEntryListingNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfEntry>;
  /**
   * Returns the fields assigned to an entry using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of field values allowed per API response schema
   * @return Get field values with the next link successfully
   */
  getFieldValuesNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfFieldValue>;
  /**
   * Get the links assigned to an entry using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of link values from entry allowed per API response schema
   * @return Get links with the next link successfully
   */
  getLinkValuesFromEntryNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfWEntryLinkInfo>;
  /**
   * Get the tags assigned to an entry using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of tags assigned to entry allowed per API response schema
   * @return Get entry tags with the next link successfully
   */
  getTagsAssignedToEntryNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfWTagInfo>;
}

export interface IFieldDefinitionsClient {
  /**
   * It will continue to make the same call to get a list of field definitions of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repoId The requested repository ID.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
          The value should be a standard language tag. The formatFields query parameter must be set to true, otherwise
          culture will not be used for formatting.  
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of field definitions allowed per API response schema.
   */
  getFieldDefinitionsForEach(args: {
    callback: (response: ODataValueContextOfIListOfWFieldInfo) => Promise<boolean>;
    repoId: string;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;
  /**
   * Returns a paged listing of field definitions available in the specified repository using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of field definitions allowed per API response schema
   * @return Get field definitions with the next link successfully
   */
  getFieldDefinitionsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfWFieldInfo>;
}

export interface ISearchesClient {
  /**
   * It will continue to make the same call to get a list of search results of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repoId The requested repository ID.
   * @param args.searchToken The requested searchToken.
   * @param args.groupByEntryType (optional) An optional query parameter used to indicate if the result should be grouped by entry type or not.
   * @param args.refresh (optional) If the search listing should be refreshed to show updated values.
   * @param args.fields (optional) Optional array of field names. Field values corresponding to the given field names will be returned for each entry.
   * @param args.formatFields (optional) Boolean for if field values should be formatted. Only applicable if Fields are specified.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
          The value should be a standard language tag. The formatFields query parameter must be set to true, otherwise
          culture will not be used for formatting.  
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of search results allowed per API response schema.
   */
  getSearchResultsForEach(args: {
    callback: (response: ODataValueContextOfIListOfEntry) => Promise<boolean>;
    repoId: string;
    searchToken: string;
    groupByEntryType?: boolean;
    refresh?: boolean;
    fields?: string[];
    formatFields?: boolean;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;
  /**
   * It will continue to make the same call to get a list of search context hits of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repoId The requested repository ID.
   * @param args.searchToken The requested searchToken.
   * @param args.rowNumber The search result listing row number to get context hits for.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of search context hits allowed per API response schema.
   */
  getSearchContextHitsForEach(args: {
    callback: (response: ODataValueContextOfIListOfContextHit) => Promise<boolean>;
    repoId: string;
    searchToken: string;
    rowNumber: number;
    prefer?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;
  /**
   * Returns a search result listing if the search is completed using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of search results allowed per API response schema
   * @return Get search result with the next link successfully
   */
  getSearchResultsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfEntry>;
  /**
   * Returns the context hits associated with a search result entry using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of search context hits allowed per API response schema
   * @return Get search context hits with the next link successfully
   */
  getSearchContextHitsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfContextHit>;
}

export interface ITagDefinitionsClient {
  /**
   * It will continue to make the same call to get a list of tag definitions of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repoId The requested repository ID.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
          The value should be a standard language tag. The formatFields query parameter must be set to true, otherwise
          culture will not be used for formatting.  
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of tag definitions allowed per API response schema.
   */
  getTagDefinitionsForEach(args: {
    callback: (response: ODataValueContextOfIListOfWTagInfo) => Promise<boolean>;
    repoId: string;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;
  /**
   * Returns all tag definitions in the repository using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of tag definitions allowed per API response schema
   * @return Get tag definitions with the next link successfully
   */
  getTagDefinitionsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfWTagInfo>;
}

export interface ITemplateDefinitionsClient {
  /**
   * It will continue to make the same call to get a list of template definitions of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repoId The requested repository ID.
   * @param args.templateName (optional) An optional query parameter. Can be used to get a single template definition using the template name.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
          The value should be a standard language tag. The formatFields query parameter must be set to true, otherwise
          culture will not be used for formatting.  
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of template definitions allowed per API response schema.
   */
  getTemplateDefinitionsForEach(args: {
    callback: (response: ODataValueContextOfIListOfWTemplateInfo) => Promise<boolean>;
    repoId: string;
    templateName?: string;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;
  /**
   * It will continue to make the same call to get a list of template field definitions of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repoId The requested repository ID.
   * @param args.templateName (optional) An optional query parameter. Can be used to get a single template definition using the template name.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
          The value should be a standard language tag. The formatFields query parameter must be set to true, otherwise
          culture will not be used for formatting.  
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of template field definitions allowed per API response schema.
   */
  getTemplateFieldDefinitionsForEach(args: {
    callback: (response: ODataValueContextOfIListOfTemplateFieldInfo) => Promise<boolean>;
    repoId: string;
    templateId: number;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;
  /**
   * It will continue to make the same call to get a list of template field definitions by template name of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repoId The requested repository ID.
   * @param args.templateName (optional) An optional query parameter. Can be used to get a single template definition using the template name.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.culture (optional) An optional query parameter used to indicate the locale that should be used for formatting.
          The value should be a standard language tag. The formatFields query parameter must be set to true, otherwise
          culture will not be used for formatting.  
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of template field definitions by template name allowed per API response schema.
   */
  getTemplateFieldDefinitionsByTemplateNameForEach(args: {
    callback: (response: ODataValueContextOfIListOfTemplateFieldInfo) => Promise<boolean>;
    repoId: string;
    templateName: string;
    prefer?: string;
    culture?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;
  /**
   * Returns all template definitions (including field definitions) in the repository using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of template definitions allowed per API response schema
   * @return Get template definitions with the next link successfully
   */
  getTemplateDefinitionsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfWTemplateInfo>;
  /**
   * Returns the field definitions assigned to a template definition using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of template field definitions allowed per API response schema
   * @return Get field definitions with the next link successfully
   */
  getTemplateFieldDefinitionsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfTemplateFieldInfo>;
  /**
   * Returns the field definitions assigned to a template definition by template name using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of template field definitions by template name allowed per API response schema
   * @return Get field definitions by template name with the next link successfully
   */
  getTemplateFieldDefinitionsByTemplateNameNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfTemplateFieldInfo>;
}

export interface ILinkDefinitionsClient {
  /**
   * It will continue to make the same call to get a list of link definitions of a fixed size (i.e. maxpagesize) until it reaches the last page (i.e. when next link is null/undefined) or whenever the callback function returns false.
   * @param args.callback async callback function that will accept the current page results and return a boolean value to either continue or stop paging.
   * @param args.repoId The requested repository ID.
   * @param args.prefer (optional) An optional OData header. Can be used to set the maximum page size using odata.maxpagesize.
   * @param args.select (optional) Limits the properties returned in the result.
   * @param args.orderby (optional) Specifies the order in which items are returned. The maximum number of expressions is 5.
   * @param args.top (optional) Limits the number of items returned from a collection.
   * @param args.skip (optional) Excludes the specified number of items of the queried collection from the result.
   * @param args.count (optional) Indicates whether the total count of items within a collection are returned in the result.
   * @param args.maxPageSize (optional) the maximum page size or number of link definitions allowed per API response schema.
   */
  getLinkDefinitionsForEach(args: {
    callback: (response: ODataValueContextOfIListOfEntryLinkTypeInfo) => Promise<boolean>;
    repoId: string;
    prefer?: string;
    select?: string;
    orderby?: string;
    top?: number;
    skip?: number;
    count?: boolean;
    maxPageSize?: number;
  }): Promise<void>;

  /**
   * Returns all link definitions in the repository using a next link
   * @param args.nextLink a url that allows retrieving the next subset of the requested collection
   * @param args.maxPageSize (optional) the maximum page size or number of link definitions allowed per API response schema
   * @return Get link definitions with the next link successfully
   */
  getLinkDefinitionsNextLink(args: {
    nextLink: string;
    maxPageSize?: number;
  }): Promise<ODataValueContextOfIListOfEntryLinkTypeInfo>;
}

const OPERATION_ID_HEADER: string = "x-requestid";
export class ApiException extends ApiExceptionCore  {
  message: string;
  status: number;
  headers: { [key: string]: any; };
  problemDetails: ProblemDetails;

  constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
    super(message, status, headers, result);

    let problemDetails = new ProblemDetails();

    if (result instanceof CreateEntryResult) {
      problemDetails = ProblemDetails.fromJS({
        "title": result.getSummary(),
        "status": status,
        "operationId": headers[OPERATION_ID_HEADER],
      });

      problemDetails.extensions = {
        "createEntryResult": Object.assign({}, result)
      }
    } else { 
      problemDetails = result != null && result.status !== undefined ? result : ProblemDetails.fromJS({
        "title": "HTTP status code " + status,
        "status": status,
        "operationId": headers[OPERATION_ID_HEADER],
      });
    }

    this.message = problemDetails?.title ??  message;
    this.status = status;
    this.headers = headers;
    this.problemDetails = problemDetails 
  }

}